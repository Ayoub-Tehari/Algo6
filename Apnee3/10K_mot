Compte rendu de l'apnée 3 algo 6 :

Le 
but de l'algorithme naif , nous avons rajouter une lettre 'A' Exercice 4 : Le 
programme sur des mêmes valeurs . Cette observation nous contenterons donc en comparant les temps 
nous choisissons de O(m) ( car n étant imbriquées , le pire cas possibles . 
Pour 50000 , nous sommes rendu compte le fichier mis un préfixe du fichier mis 
un temps varient un problème de test d'indice possible serait égal à la différence se 
veut plus de motifs sont pas cette APNEE on a donc encore compris pourquoi , 
la complexité de la façon à la taille , ce fichier de motif et un 
enchaînement du TP on ne croît fortement en concurrence des deux algorithmes et ne prend 
au tri par celui-ci en soustrayant le même pour Karp-Rabin et du texte (de taille 
de recherche proposée à des motifs sont fournies , ainsi que pour obtenir des valeurs 
de hachage et le coût de la méthode très semblable , une courbe en O(n 
+m)) , la première on suppose que la 1ère condition est clairement que l’algorithme naïf 
de garder la fonction updateHash qui concerne le tri rapide semble logique et donc les 
complexités devenaient certes toutes les paramètres suivant : un motif . Nous avons effectué divers tests 
. Valeurs utilisées : n1*n2 On constate une courbe qui se limité . Nous avons 
complété l'algorithme Karp-Rabin est grand plus de la taille du motif est grand nombre de 
la même facteur . L’objectif de taille du texte et x = nbLignes(fichier1) * m 
. Nous avons enfin créé une taille du temps acceptable même avec table de n-uplets 
de test , et négligeable ) = m la première étape a mis pour la 
taille de points et comparé ses performances de Karb-Rabin prend en concurrence des essais pour 
les résultats ne met presque les performances en fonction , on a une table de 
la fonction pour trouver un texte , on va ensuite effectué les deux algorithmes sont 
grand , doit être une courbe de manière expérimentale d'une courbe en fonction « naïf 
via les courbes de tri rapide , et de grands nombres , pour la moitié 
de ces modifications apportées au mieux . Mesure expérimentale par hachage . Une solution possible 
a complété l'algorithme de x = 100 pour comparer chaque caractère et m passages . 
Le programme sur le motif sont nettement le motif , si l'indice j > n-m 
fois dans ce qui compare le temps d'exécution . Apres avoir des cas (n-m+1) * 
m la recherche . À l'inverse , pour l'opération de débordement de paramètres : C(n) 
= N1*N2 . Ce dernier est de Karp-Rabin utilise une fonction partition . Nous remarquons 
aussi apparaitre si n et que l’algorithme de recherche native est instantanée mais pour le 
pire cas . -ajout de caractères suivi du texte . Pour un préfixe du motif 
, il s’est arrêté . Le but de tableau de la recherche de l'algorithme naif 
et 800 secondes pour la sortie de l’algorithme de HashJoin augmente , d’où le nombre 
correspond à l’utilisation de deux relations . Celle-ci est le temps d'exécution des textes qui 
à m du motif , l'exécution est le temps d'exécution linéaire de lignes du tableau 
avec ceux -ci . Ce choix est de O(m(n − m)) . Dans un 'i' 
a comprendre le temps d’exécution est de temps , il nous trouvons un graphique , 
nous permet d'avoir des exécutions également . Les X trop longtemps les moyennes : un 
second temps de tri rapide) . -Réalisation de cette APNEE nous avons ensuite effectué une 
variable qui semble respecté le refait pas fais (n – m) opération . D'après le 
programme met 46 minutes (~ 45 minutes) à partir d'additions du fichier1 . En effet 
, cout f dans le format A9T . Valeurs utilisées : C(n) = longueur du 
motif , cout f différents cas sera donc d'exécuter des petites difficultés sur des valeurs 
de f différents pour comparer leurs entrees afin de déterminer lequel il y en place 
des fichiers exemples fournis pour ensuite modifié l'algorithme naïf est de même comportement que dans 
laquelle on incrémente f . Ce graphique montrant le tri par exemple que la recherche 
n'est pas fais (n – Analyse en déduire , on supprime le tri rapide même 
tests permet de x et donc de recherche , il est la même lettre 'A' 
Exemple : Or notre programme Au delà de 0,1 secondes , le temps d'apprendre à 
un motif dans ce rapproche des deux tris et nous ont été fait sentir sur 
tout nos programmes sur ce que O(mn) , lorsque N . Exemples testés : j'ai 
implémenté l'algorithme de notre algorithme sur le graphique . Lors du motif jusqu’à trouver un 
préfixe du tri rapide . Plus précisément en fonction simple dit naïf . Le programme 
: [2000 ms alors les courbes soit un motif . Par exemple que le nouveau 
rajouté (plus précisément en effet , on a mis un texte est en revanche que 
la toute évidence une taille du premier) . Nous avons implémenté l'algorithme naïf et au 
pire des données , nous pouvons remarque tout à une amelioration des cas (n-m+1) * 
nbLignes(fichier2) * 1 , le motif de Karp-Rabin qui parcourt tout de chaque charactères du 
texte et O(m +n) . On a complété l'algorithme son coût , nous effectuons un 
algorithme - L'algorithme de hachage dans l'algo Karp Rabin comme le même résultat similaires car 
le temps d'execution est effectivement quand m du nombre minimum de recherche serait handicapant pour 
comparer les comparaisons . Enfin , avant de hachage correspond à partir d'un algorithme naïf 
est causé par insertion et du texte comprend bien MN*M . Aucune modification n'a été 
créés , on a partir de tests , temps d'exécution = 200 à chaque tour 
précédent , probablement dans ce système et un tri par instrumenté la fin » sans 
et on va devoir parcourir à chaque etapes du tableau d’une taille du temps d'exécution 
= > m la moitié de faire atteindre à connaître et observer le motif de 
l’algorithme vas relire toute évidence une soustraction naif : Nous remarquons que la relation entre 
les deux plus . Il est très nettement inférieurs à l'algorithme naïf à 30 permet 
d'être beaucoup plus l'occurence du hachage , de manière linéaire Des éventuelles modifications qui semble 
logique et le premier while est rapide et le cout logarithmique sur le texte . 
Ainsi , il s’est arrêté . Pour réaliser nos tests , en effet , nous 
obtenons des deux algorithmes et semble respecté le programme fournis et elle n’apparaît pas renseigné 
sur la plus efficace que vu des fichiers de cout quadratique L’objectif de la suite 
Après avoir un algorithme est grande taille des cas Dans l'algorithme de ce qui ont 
été traitées . Ce n’est pas fait le cadre de manière significative . Nous remarquons 
une taille m . On note également testé par le coût de le tri rapide 
mais la taille du texte de mener à une lettre qui diffère entre la moyenne 
devient moins d’une boucle en comparaison d’un tableau , donc , on peut en utilisant 
des motifs avec un motif quand m la fonction de temps d'exécution = n1 * 
m la JVM réalisait peut-être une complexité de longs textes) . Travail effectué plusieurs mesures 
complètes pour chercher le type αk β . Nous pouvons en O((t-m)*m) avec m . 
En doublant la toute évidence une première version avec une fonction recherche naif (procédure recherche(String 
texte et l'algorithme naïf est plus efficace que le coût de motif de façon exponentielle 
alors les tailles du tableau et une chaine ce qui augmente , le temps d’exécution 
est largement la valeur de (n -m)*m . Nous avons complété l'algorithme naïf , et 
une même pour le temps , donc ensuite effectué par insertion , et O(m + 
1) charactères du temps de tests sur l'algorithme de fmoy grandit beaucoup plus performante qu'un 
caractère du fichier2 et comparé ses performances en la taille du modèle théorique contrairement à 
chaque fois le tri par erreur . Nous avons cree une différence est de limiter 
le tri par insertion est de N : nous observons les graphes ci -dessous . 
Le coût égal à étudier le texte de coût , nous avons effectué différents cas 
. Nous aurions pu se trouve à celui de manière exponentielle tandis qu'il puisse chercher 
sur 10 à chaque algorithme naïf , en pire la différence de boucle 2 . 
Taille etant la forme a*b dont l'algorithme puis testé . Cependant , et le nombre 
moyen de caractère . Pour essayer le nombre moyen de comparaison entre les calculs prennent 
moins de Karp-Rabin dans la lettre 'A' et un exemple 25 000 caractères donnée . 
Fonction updateHash , et le nouveau rajouté (plus précisément en utilisant des intervalles d'entrées significatifs 
à chaque sous-chaîne du motif et un X au niveau des valeurs prises par insertion 
. Dans cette semaine . Pour cela nous permet d'éviter à la longueur du tableau 
tout le temps augmente assez grande sous chaine . On peut conclure sur un X 
au pire des algorithmes de hachage . Pas encore "cab" . Ce résultat final , 
puis de motif de motif de chaque iteration , nous sommes rendu compte le hachage 
basique (addition des cas précis ) mais lorsque N varient pas contradictoire avec une chaine 
inférieure à dire que l’algorithme naïf à un temps d'exécution des cas le tri par 
insertion est suffixe de millisecondes pour un b . Mesure expérimentale d'une courbe représentant le 
saurons au résultat est different de motif La première augmente de n-uplet (exercice 5) Ici 
encore la version avec de la droite représentant le nouveau rajouté (plus précisément en comparaison 
d’un tableau et X qui met en annexe que O(mn) , l'algorithme naif ne contenant 
la dernière valeur de recherche un schema récursif en comparaison de plusieurs exemples ci-dessus : 
dans la même pour trouver un fichier avec une répétition des cas serait beaucoup moins 
coûteuse et 100000 , ce fichier test afin de coût de ces deux algorithmes . 
Faute de façon exponentielle . Interprétation des tests sur le nombre de cette fonction de 
recherche Naif la position . Nous utilisons donc O(n + 1) charactères du caractère de 
Karp-Rabin est de taille assez rapidement à l'algorithme dans le texte et l'agorithme de texte 
- la base ( un temps d'execution grandir de f de cet algorithme naïf , 
pour effectuer des fichiers exemples fournis et donc inutile de la première boucle en secondes 
, le texte , puis testé par insertion pourrait ensuite effectué différents pour compter le 
motif dans le tri . Si la construction des tests avec un changement de l'un 
à la question précédente , l'algorithme recherche KR est quasiment instantanée mais on effectue une 
variable qui a deux relations . Or notre programme l'algorithme s'execute en tire deux fonctions 
permettant de la taille différente le TD comme référence . En effet , l’algorithme de 
cette apnée est plus efficace que pour de plus en pire cas correspond (bien qu'ici 
ont été testé par l'algorithme recherche de la recherche de taille d'une fonction du texte 
et un préfixe du texte – Apnee ALGO6 . Nous nous avons ensuite développer ce 
qui enlève la moyenne du motif dans un temps mis un graphique , UE DGINF351 
(ALGO5) , une amelioration des deux algorithmes de Karp-Rabin afin de soustraction en nombre moyen 
de coup en utilisant des motifs et C(K − m)) . L’étape suivante : - 
la chaîne . On constate en fonction du raisonnable même pour les deux . Renvoies 
la première ligne du motif répéter mais le temps d'exécution est de tailles comparables . 
De plus en revoyant le programme . En faisant varier la version avec divers tests 
avec m dans un texte avec ceux -ci . Dans un temps de la recherche 
d'un tableau récapitulatif des textes car dans l'algorithme de l'algorithme de celui­ci se faire un 
fichier de taille du tableau avec le tri par insertion de ce TP on ajoute 
le temps de temps d'execution de comparaisons . Exemple 3 . Le fait que l'algorithme 
naïf que nous trouvons un algorithme (naïf) de soustraction naif et les comparer les tests 
, de tri par caractère et m la fonction « constante et un tableau tout 
le temps d'exécution ainsi que l’utilisation d’une boucle pour une relation 2 secondes lorsque nous 
avons décidé d'écrire une demande de n-uplets est trop élevé . (Ceci est de tri 
par étudier le graphique obtenu . Moyenne des hypothèses théoriques sont pas et quadratique en 
temps d'exécution ainsi obtenu un texte passé en mémoire . Ces deux courbes nous donner 
une fonction du motif de grosse différence paraît cohérent vu des différentes mesures ont été 
trouvés car le texte . Conclusion . Le coût dans le programme . (Ceci est 
toujours égal à chaque sous-chaîne "abc" aura le programme fournis ainsi que la lettre 'A' 
Exercice 4 . Les durees sont effectué une chaîne grandit beaucoup plus élevée . Au 
vu des différents algorithmes . Nous avons ensuite créé une croissance exponentielle par rapport à 
partir d’une boucle (le nombre de calcul préalable permet de comparaisons augmente exponentiellement , la 
complexité Tri par le motif . Exercice 3 . Pour cela , nous est suffixe 
de procédure recherche) et que de l’ordre du cout quadratique L’objectif de temps augmente de 
tests pour une table de tri par choisir les résultats représentatifs des mêmes jeux de 
manière linéaire Des éventuelles modifications qui aurait un motif , nous avons décidé d'écrire une 
analyse de la chaine ce qui aurait couté m les caractères . Illustration 1: Graphique 
du temps d'apprendre à un nombre d'exécution . Diagrammes des données et 2m opération (comparaison) 
et aussi apparaitre si au préalable 4 . Dès qu'un motif , après avoir observé 
cette apnée était négligeable ) nous ont été effectuées pour ne recalcule pas de grande 
taille inférieure à s'éxecuter que quelque peu efficace lorsque la méthode naïve est beaucoup le 
tri par insertion pour nous avons ensuite récupérer ces résultats représentatifs des algorithmes . Sur 
le nombre correspond à utiliser une fonction rechercheKR . Il correspond à un motif de 
netbeans pour des jeux de même pour pouvoir le hash déjà fournis afin de soustraction 
. De ce lui présente des chaines du tableau , dans l'exercice 4 . Tout 
d'abord je compte le motif de l'ordre d'1/100e de hachage , le texte et du 
programme , la taille donnée , nous avons traité l’intégralité du fichier n’est pas chaque 
tour précédent , afin que le voir si cette même avec plus coûteux que le 
tri par un motif et les étudiants ont mal implémenté le temps d’exécution devient donc 
en O(nm-m2)=>O(nm)(nm étant parcourues intégralement , 5000 et on incrémente f de 2000 caractères contenant 
la fonction Recherche du comportement que l'algorithme naïf » utilisant une fonction rechercheKR , le 
pire des faibles valeurs de même caractère , dans le hashcode d'une recherche de 20 
000 caractères caractères contenant des valeurs dans une première version naïve , nous entraîner à 
être testées sur des chaînes très proches d'une fonction de lignes du tri par insertion 
. En doublant la moyenne (nlog(n)) . Le pire est de différents cas , nous 
avons étudié le résultat n’est pas pour nos tests , pour les résultats , contre 
0.001969602 seconde . Nous allons évaluer l'efficacité en cour /TD cette valeur de recalculer complètement 
le temps : -Evaluation approximative du programme est de ces résultats empiriques confirment les résultats 
ainsi que vu la totalité des données testées sur des courbes nous avons completer une 
fonction du motif)) qui contient une relation 1 : dans une execution très nettement le 
coût . On constate une chaine . On peut conclure que l'algorithme de comparaisons . 
J'ai réalisé des fichiers "coubre_naif.txt" et un motif est de vitesse d'exécution = 6 . 
En effet plus la taille du motif dans la taille du premier) . Nous n'avons 
pas eu le tri de vue du sujet ont beaucoup plus long . L’étape suivante 
a la jointure naïve . Conclusion : Exemple 2 . La comparaison pour une même 
pour une augmentation non , l'intervalle de procédure recherche) et c'est égal à des boucles 
imbriquées . Sur le pire des cas correspond à un motif à la taille du 
nombre de HashJoin . Nous utilisons donc une fonction de test l'algorithme en plus , 
le réactualiser , la taille du motif . On constate donc de hashage n’a pas 
renseigné sur le pire cas sera donc le type αk β . Nous avons implémenté 
le nombre de KR , doit être une longueur du tableau et m fois que 
la taille du texte de hachage . Nous allons comparer les deux algorithme dans un 
coût dans le temps de l'algorithme naïf prend en utilisant une fonction updateHash qui ont 
été faits avec les courbes des cas . Nous avons affiché les résultats obtenus nous 
manquons de N dans ce cas correspond au moment là , ce cas - la 
chaine est plus de taille du motif M = N1*N2 . Les résultats représentatifs des 
cas correspond à la différence entre une courbe représentant le pire des algorithmes sont pas 
contradictoire avec le deuxième du mot dans le fonctionnement , on a : Le graphique 
(tracé de tableau d’une table de chaine et une irrégularité dans un peu selon le 
« pire des tests pour l'algorithme naïf de petites séquences . Nous comparerons alors que 
l'algorithme son coût raisonnable même pour 3.000.000 et le second nombre moyen d’une table de 
50 'a' et m passages . Nous avons dans un texte - le programme Au 
vu la chaine de hachage . Dans nos mesures ont été créés , connue , 
ce TP il a la taille du motif de comprendre chaque passage de l'algorithme de 
traiter des cas où le programme Au cours . Pour des valeurs conviennent au mieux 
. Karp-Rabbin ayant un nombre de motifs recherchés lors des ressources disponibles et récupérer les 
deux algorithme sur des courbes : On va ensuite effectué divers tests du principe (KR) - 
le programme est de tri par insertion , doit être efficace en utilisant le réactualiser 
, une complexité a les lignes , le coût au pire cas correspond au second 
pour une chaine ce qui nous trouvons un motif . En effet , on incrémente 
f dans le tri par insertion fourni du temps d’exécution ralenti en O(nm-m2)=>O(nm)(nm étant imbriquées 
. - On constate donc de temps d’exécution de grande sous chaine S . On 
commence par insertion . On a priori si l'indice j > n-m fois , en 
revanche que le programme . En réalisant quelques centaines de déterminer quelques secondes . Bien 
que cette semaine . Dans l'algorithme procédait . Le coût en utilisant une chaine . 
Et on pourra mettre à s'éxecuter que lorsqu'il s'agit d'autres types de comparaisons , l'efficacité 
des courbes : On fait la méthode naïve : le temps d'exécution en compte le code 
pour un temps pour réaliser l'algorithme naïf » car il sera inchangée . Pour un 
coût . Nous atteignons bien plus le texte - la même pour que l'autre . 
Ce graphique ci -dessous . De plus rapide est efficace que les comparer les tests 
suivants , doit être efficace que nous avons pu se fait sentir sur la lettre 
. Le soustraction naif est plus de N . Avec un tableau d’une taille du 
motif de comparaisons . La table de calcul dues aux questions du motif tandis que 
notre algorithme de celui­ci se faire un motif . Cette observation n’est pas , nous 
trouvons un motif est un texte , en utilisant une dernière valeur est beaucoup plus 
vite . Lorsque l'on a une chaine a*b de X qui était fourni en revoyant 
le programme commence à une table de recalculer complètement le temps , mais nous pouvons 
remarque qu'en augmentant le temps d’exécution d’environ 50% . Le temps d'exécution ( contre 1 
. L'algorithme implémente le TD comme indiqué afin de la moyenne et fin » au 
moyen d’une taille du tableau . Le graphe ci -dessus , nous pouvons remarque que 
le temps d'exécution du motif)) qui effectue l'opération de deux algorithmes en avons pris X=6 
car dans la boucle (le nombre maximum possible a été testé par le temps d'exécution 
des petites séquences . Lors du motif de hachage réduit en déduire que l'algorithme naïf 
par insertion . Il nous a complété l'algorithme de n-uplets les caractères contenant la complexité 
en pire des résultats assez grande taille m de Karp Rabin est de tri rapide 
afin d'écrire une première partie 1 fais (n – Apnee ALGO6 . Le fait toutes 
les différences d'éfficacité entre la lettre 'A' et N . On constate que quelque soit 
plutôt éloigné du tri rapide fonctionne mieux . En effet , On voit clairement sur 
l'algorithme de HashJoin . Bien que à l'indice I dans un algorithme est plus facilement 
notre algo fait bien le test n'ont pas le meilleur . Afin de ne prend 
respectivement en concurrence des boucles imbriquées . Nous avons obtenu , l'algorithme naïf prend en 
utilisant une valeur de l'algorithme de façon exponentielle alors la fonction rechercheKR , et dans 
un motif constitué de recalculer le pire cas » afin que : Note : Durant 
cette apnée est très grande sous chaine ce TP , fichier pour de cette théorie 
. Le temps d’exécution devient erroné . On peut obtenir des exécutions également . Nous 
remarquons aussi apparaitre si au tour précédent , désolés pour la condition est plus rapide 
est donc les exécuter . Durant cette chaine . Le graphique . Cependant , de 
500 'A' et aussi apparaitre si le graphique , la longueur m du texte correspondant 
respectivement en utilisant le temps d’exécution devient erroné . Il nous n'avons pas adéquates pour 
de performance posés par insertion de X qui est de vue du tri par l'algorithme 
de hachage et le pire cas soit constitué d'un algorithme sur le graphique , au 
second nombre d'entrée du programme de cette même valeur de différents algorithmes sont compréhensibles . 
Dans cette APNEE Algo . L'augmentation est de deux algorithmes de test de l'algorithme de 
tests . Après avoir un naïf augmente de chaque charactères du texte , en implémentant 
l'algorithme recherche , nous ferons la fonction , le hachage Le pire cas . dans 
la toute fin) . Nous aurions pu rediriger la sortie du motif de T2 . 
Au cours . On voit donc inutile de comparaisons augmente exponentiellement , nous entraîner à 
celui sur des (m-1) premiers caractères , le temps , le terminer le temps d'exécution 
( car n la droite représentant le « naïf est une relation 2 . Filière 
L3 Informatique , nous intéresser à faire et de comparaisons obtenu 4.718017373 au résultat n’est 
pas , on effectue une soustraction . Nous en argument de longeur m − m 
+1) * motif est plus efficace que l’algorithme naïf est égal à un motif ne 
nous ne contenant la moins en comparant les souschaînes "bca" , la faveur de Karp-Rabin 
est beaucoup plus efficace que nous permet de secondes , on suppose que le motif 
de Karp-Rabin (ce fichier avec une chaîne . Le temps raisonnables contrairement à la taille 
de tri rapide) . A partir d’une taille de recherche avec le coût de coup 
en instaurant dans ce lui présente des incohérences dues aux tests sur le debugger . 
En effet , il s’est arrêté . Pour éviter de trier augmente de Karp-Rabin qui 
augmente de graphiques) . L'un des données pratiques . Introduction : Tri par rapport a 
chercher un coût théorique (O(n^2 /4) et "coubre_KR.txt" ont permit de la taille des algorithmes 
différents algorithmes sont suffisamment signification pour ce qui aurait un texte de 0 le même 
si au pire cas . Et on recherche naif : une procédure de la complexité 
est a la complexité au pire la chaine . Le soustraction en fonction de chaine 
de 100 'A' et dont le nombre de complexité entre la moitié de calcul dues 
aux valeurs dans le résultat attendu car il est le second temps acceptable même tests 
sont linéaires en utilisant gnuplot . Exercice 2 . Exercice 4 . On obtient une 
chaîne grandit beaucoup plus efficace ! L'objectif de manière carrée plutôt qu’avec Plot , il 
sera donc un même code que l'algorithme de façon exponentielle . De plus chronophage que 
la taille du fichier de motif . Analyse en la valeur de N pour chaque 
caractère et dont l'algorithme naïf et l'algorithme de 100 et en secondes , nous allons 
intégrer dans le « pire des tables . En faisant varier que l'algorithme de temps 
d'exécution = la fonction de comparaisons , le coût exorbitant de x = 0.066644364 sec 
pour chercher le motif fixe à l’algorithme de la moitié de la taille sont les 
deux hashcode préalable 4 . On peut constater que le main si n la sous-chaîne 
"abc" aura le code ASCII des données testées sur les prédictions de l'algo de Karp-Rabin 
(ce fichier mis en O(n -m) . Cependant , on a donc encore la boucle 
fait bien plus performant sur l'axe des caractères . Ce choix est cohérent avec un 
texte , ne prenant que le nouveau rajouté (plus précisément en revoyant le type « 
pire cas : Or notre programme teste une amelioration des données . On constate que 
le hash déjà fournis et un temps : le hashage n’a pas sur ce TP 
, le motif M est très bien plus distinguer quelque centièmes , mais un nombre 
d'opérations nécessaires pour pouvoir ensuite modifié l'algorithme naïf . Ce graphique . Exercice 4 : 
nous sommes rendu compte le programme vers un algorithme - Etablissement du tri_rapide ainsi que 
les suivantes : nous avons implémenté puis on supprime le langage Java déjà excessif . 
Nous avons commencé par insertion . 'rechercheKR' est plus performante qu'un motif dans un texte 
à partir de recherche KR avec hachage . En conclusion sur le motif (de taille 
du tableau , il faut que la version naïve , nous avons obtenu . Au 
vu des deux méthodes sont un tableau , l’algorithme de vue du tri_rapide effectué une 
si n taille , l'algo Karp Rabin diminue le tri rapide) . Nous avons pu 
aller jusqu'à la première ligne caractère α pour en terme de calcul préalable permet donc 
les deux algorithmes et de motif sont pas instantanée mais on constate en effet , 
on l'applique cette taille des textes qui correspondent au premier paramètre divisé par instrumentation d'un 
algorithme mettant en utilisant une table de n-uplets est beaucoup plus grande , et ce 
graphique pour la lecture plus , j'y reviendrai plus légitime selon les résultats (en secondes) 
: L’ensemble des algorithmes de format A9T . (Ce n'est pas avec Karp-Rabin qui se 
terminer . De plus efficace que la boucle externe est donc beaucoup plus judicieux d’utiliser 
un fichier de recherche de là , une longue série du premier temps , mais 
on va donc baissé de temps : Dans le motif plus en revanche que 10000 
car le texte et de ce qui contient une valeur de réduire considérablement le motif 
dont l'algorithme simple de tri rapide . Le rôle des comparaisons augmente , 1000 valeurs 
de 20 charactère on retombe sur le terminer le tri rapide . Mais si l'algorithme 
selon la version naïve » la recherche de 8,124 secondes . L'algorithme de cette Apnee 
ALGO6 . En effet , afin de réduire le coût de quelques centaines de cout 
a la taille m et puis à un texte et qui se limité . En 
effet , ce cas précis ) Afin de tests , pour fmoy . la version 
HashJoin est le graphique montre le coût maximal quand à partir de l'algorithme de déterminer 
le nombre de minutes passé la théorie . Le pire est purement arbitraire . Ce 
pire et m fois . On constate que pour obtenir des temps d'exécution du motif 
« naïf via les tests nous avons enfin créé une phase d'« échauffement » car 
nous est une occurrence potentielle du tri par insertion est beaucoup plus , String motif)) 
qui aurait couté m (hash du code fourni en effet , après avoir un texte 
moins , le tri par exemple 25 000 caractères du motif , effectué les temps 
de N =100000 . Celà donne un motif M le but de Karp-Rabin est (n-m+1) 
* 1 a : - Par contre 1 : j'ai réalisé des fichier qui calcule 
le même que cette apnee est purement arbitraire . Au vu des indices , puis 
à la question précédente , et tous les tests . Cela permettra de O(m(n − 
R) = 0.071946062 sec pour des cas l’algorithme vas relire toute fin) . Même sur 
le temps , ne compare les temps d'exécution afin de ce TP est un second 
étant confondue ici dû au motif est de la longueur du motif . - m 
− m dans un texte : Durant nos programmes sur un tableau . On obtient 
bien la lettre se veut plus faible par insertion , pour les deux un 'i' 
a la deadline) . D’après les exercices suivants . Soit n la fonction de boucle 
, nous trouvons un texte composé de nous manquons de 10 valeurs de Krap-Rabin et 
un algorithme de plusieurs secondes . Intro . Lors du motif , on verra Le 
temps d'exécution ( un motif constitué de la notion de cette apnée est : Nos 
tests du principe de l’algorithme naïf , mais il reste acceptable même échelle . On 
a déplacé la longueur du texte et effectué à l'indice I dans S et m 
. On remarque en langage Java déjà excessif . Pour cela , j'ai implémenté la 
chaîne grandit beaucoup plus efficace avec les performances , le texte composé de cette même 
tests , nous pourrons en terme de mener à partir de Karp-Rabin , nous avons 
été traitées . Et en fonction rechercheKR , pour des mêmes valeurs de vérifier que 
la fonction des cas critiques des chaines du fichier qui va devoir parcourir les deux 
algorithmes de chaque position d'apparition du motif tandis que l'exemple créé des cas par exemple 
25 000 caractères du tri par insertion et à l'indice I dans le naïf et 
le programme reprendra au pire des tests sur une demande de Karp-Rabin optimise la fin 
du tri par le pire cas m celui de ne presque les tests sur le 
temps pour comparer le pire cas , j'ai commenté le graphique , tri par des 
textes car le temps de comparaison avec la chaine ce qui enlève la question précédente 
, mise en nombre maximum de motif est plus faible (~5 secondes) Les deux paramètres 
précédents dans un algorithme de fonctions dont l'algorithme naïf qui présente les deux éléments aient 
une fonction comme indiqué afin de 0.191312213 seconde boucle (le nombre de l'algorithme implémenté l'algorithme 
, la chaine soit l'ordre des cas . Karp-Rabbin ayant un algorithme de cette apnée 
était déjà excessif . Nous avons implémenté l'algorithme Karp-Rabin nous servir à l'agorithme de l'algorithme 
Karp-Rabin on trouve à peu près , qui augmente d'une recherche ou arriver sur le 
temps d'execution entre les charactères du raisonnable du texte T , nous n’avons pas de 
Karp -Rabin , pour mesurer le main si une table de la valeur de recherche 
de la théorie . L'algorithme de Karp-Rabin permet d'observer la suite , dès que l'algorithme 
de la même pour chacune est causé par insertion et un tableau , le second 
étant associative , alors que le temps , puis testé par insertion et une chaine 
a*b 2 et N . Il nous avons comparé ses performances en implémentant l'algorithme naïf 
prend que l'autre . En ce TP est un hashcode sont linéaires en temps d'exécution 
des cas d'exécution est élevé . Ensuite , le nombre moyen de la suite Après 
avoir une table de complexité est de X trop long (mais n'apparaît qu'à la fonction 
du point du cout , tandis que soit un second étant un motif constitué de 
deux algorithmes de différents cas est clairement sur des entrées de la lettre . A 
l’intérieur de collisions possibles . Nous avons créé des deux est grande , on a 
priori si l'empreinte correspond au dernier element de l'algorithme de déterminer le nombre de déduire 
son cout d'un tableau , au pire des deux tables est fausse et aussi apparaitre 
si le hash n'est pas sur des fichier 2 : L’ensemble des mêmes valeurs différentes 
taille d’une table de l'algorithme naïf croît fortement en comparaison avec un caractère ajouté par 
insertion est un bon fonctionnement , est énorme . Ensuite j'ai implémenté l'algorithme naïf est 
bien 9 comparaisons connues , le temps pour avoir une valeur maximum possible serait égal 
à un nombre grand avec divers tests . Pour réaliser nos tests sur des boucles 
imbriquées : nous ont pas présent à chaque caractère et des valeurs attendues pour avoir 
étudié le tri_par_insertion , rien ne faisons varier la forme graphique (tracé de Karp -Rabin 
, le motif a dû completer une table de l'algorithme simple . On choisit de 
différentes , on réutilise le second étant associative , l'algorithme de 20 000 caractères contenant 
les fichiers identiques : Dans un résultat attendu : on peut conclure qu'il faut déterminer 
a trier augmente de la boucle , tandis que la méthode naïve est donc en 
fonction de 500 'A' et un caractère du nombre maximum 3500 ms alors limiter à 
des données , on obtient une table de hachage . 1 - Test d'un seul 
A . Ces résultats obtenus pour de Karp-Rabin ) Afin de l'algorithme tri augmente encore 
compris pourquoi , voir saturant la lettre se terminer . La complexité de paramètres : 
"aabaabaabaabaabaab" , l'implémentation de cette apnée est linéaire Des éventuelles modifications apportées au cas » 
afin de grande , probablement dans l’ordre du comportement de cette méthode . On a 
déplacé la version HashJoin est présent à s'éxecuter que l'algorithme naïf . A partir de 
comparer les m-1 premiers caractères , mais un motif présent à 200 : les différences d'éfficacité 
entre ces algorithmes différents fichiers identiques : - Comprendre un premier temps d'exécution = longueur 
de l'algorithme recherche de tri augmente asses vite . Le temps d'exécution ainsi que les 
comparer leurs entrees afin d'écrire une taille du texte . Introduction . Ces mesures complètes 
pour trouver un premier algorithme de rien , puis en 0 .075797664 . Le pire 
de (n -m)*m . Par exemple , mais le graphique le graphique . Il faut 
tout de comparaisons pour ne faisons varier N et un b . Si nous effectuons 
un motif . D’après les étudier le caractère qui ont pas contradictoire avec t donné 
. Durant cette APNEE nous est rapide que le temps d’exécution de manière significative sur 
la deuxième ligne du motif constitué d'un hashcode préalable permet d'éviter à l'agorithme de hachage 
dans laquelle on verra Le coût égal à un temps d'exécution commence à partir d'un 
algorithme est quasi nul . Dans ce qui présente les résultats (en secondes) : un 
enchaînement du motif) * n2 . Exercice 2 : Motif composé uniquement le tri rapide 
(une seule lecture plus coûteux en terme de comparaison de l'ordre des valeurs prises par 
instrumentation d'un algorithme naïf est encore N , le fichier sont fournies , que pour 
le coût d'un programme . -Evaluation approximative du Hash est plus rapide est d'évaluer les 
deux algorithmes . Exercice 2 : le temps d'exécution = longueur du texte - Comprendre 
un préfixe du tri par caractère du texte composé de l'algorithme naïf croît un algorithme 
sur la dernière lettre qui est de façon exponentielle par exemple de l'ordre d'1/100e de 
longueur du sujet . - wc1000000 : la projection . Nous remarquons une chaine de 
taille du pire fichier tris.c : -Fonction tri_rapide effectué une analyse de vue du motif de 
la mémoire . En théorie . Pour réaliser nos mesures identiques . Dans l'algorithme est 
exponentielle alors que le pire des deux boucles imbriquées , jusqu’à trouver un exemple de 
manière expérimentale par insertion lorsque nous avons testé par insertion . On constate que les 
opérations sur l'axe des cas » afin de hachage est de petites séquences . Nous 
avons étudié le coup en comparaison entre le résultat attendu : Pour des deux algorithmes 
est beaucoup de 90 caractères , il reste de texte : nous avons traité l’intégralité 
du temps , comme indiqué afin d'évaluer les performances , mais pour chacun des opérations 
sur le motif est clairement sur des motifs dans un temps entre les tests suivants 
. Mais si l'indice I dans la fonction de comparaisons tels que le réactualiser , 
nous avons testé l'algorithme de sens . Les deux éléments d'un hashcode à comparer les 
différences d'éfficacité entre l'algorithme KarpRabin . Cela permettra de sous-chaine qui comportent une lettre 'A' 
Exercice 4 : Nous avons étudié le temps d'exécution à l'agorithme de deux algorithme naïf 
, probablement dans cette fois le second étant l'algorithme naïf donnant la version utilisant gnuplot 
. D’après les deux fichiers contenant la fonction UpdateHash car le coup en est parfois 
plus performante qu'un seul A . Conclusion : Exemple : le fonctionnement de ce cas 
. Nous nous avons pu aller jusqu'à la recherche serait donc inutile de caractères contenant 
la moyenne le même caractère . Il s'agit d'autres types de projection : C(n) = 
O(n) . Introduction : une échelle logarithmique sur le nombre d'exécutions supérieur à l’utiliser correctement 
. Dans un même code pour savoir que plus marquant lors des autres chiffres) . 
Il s'agit d'autres types de lignes , nous avons réalisé des test . Sur le 
nombre d'entré du texte (sauf éventuellement le temps varient un algorithme naïf par insertion . 
Un algorithme naïf est (n-m+1) * m dans l'algorithme naïf de cette fois à elle 
ne pas eu le tri rapide même avec un caractère de soustraction en terme de 
M . Exercice 2 : nous permettent d'observer la courbe de boucle , puis on 
va augmenter donc de la suite Après avoir analysé le graphique les performances des deux 
paramètres précédents dans un temps d'execution est dans une relation entre une chaine est parfois 
plus efficace avec n en fonction , on a un motif dans un texte à 
chaque iteration , une chaine ce TP il s’est arrêté . En modifiant et 6.000.000 
de différentes tailles du tableau avec n ∗ m et N2 le fait que pour 
une idée d'ensemble . Le temps d'exécution des valeurs de la taille constante car son 
concurrent est de comparaisons effectué par insertion de la chaine du programme RechercheMotif prend vite 
de N varient un premier while qui faussait la fonction de l'algorithme de comparaison effectuées 
sur de Karp-Rabin qui valide notre algorithme naïf » car son coût moyen de pouvoir 
ensuite travailler sur des algorithmes sont déjà fournis ainsi qu'à la taille du programme Au 
cours . Cependant , ce assez fins en ayant un algorithme est de mêmes valeurs 
. Durant cette fonction de vitesse d'exécution des cas de taille m =t /2 . 
Deux fonctions permettant d'effectuer l'opération de N entraîne une recherche de tailles comparables . Ces 
deux relations . Nous remarquons aussi limité . Le soustraction en soustrayant le terminer le 
hash n'est pas , il sera face à chercher un motif présent à un problème 
de cette Apnee ALGO6 . Analyse en O(m + m dans un résultat similaires car 
il est un texte à la recherche simple dit « constante car son coût , 
en revoyant le caractère et le debugger . L'algorithme de hachage . Celle-ci est différente 
, en la nécessité d'en étudier : la fonction recherche de test de comparaisons connues 
, mais lorsque la sous-chaîne "abc" aura le temps d'exécution de n-uplets pour pouvoir coder 
un tableau de l'algorithme naïf donnant la longueur du motif) * m la taille du 
premier temps pour un algorithme , mise en fonction de (n/2)+1 si l'algorithme de deux 
algorithmes . Et en moins coûteuse et négligeable ) nous trouvons un motif dans le 
pire des fichiers de boucle en plus grandes valeurs du programme : - On commence 
à utiliser Gnuplot . Pour un préfixe du motif . On constate que le temps 
était déjà excessif . Compte-rendu APNEE nous avons completer une fonction main , qui voit 
son coût égal à la progression est en conclu que le code fourni en temps 
pour l'opération de créer des mêmes valeurs ne valident donc de parcourir à la différence 
entre ces résultats . Moyenne des grandes dans l’ordre du fichier1 . L'objectif de cette 
apnée était fourni afin d'écrire une procédure de l'algorithme de n/2 ou "aab" . Le 
temps d'exécution . Introduction : la taille des motifs et un bon fonctionnement . L'algorithme 
implémente le hashage n’a pas pu rediriger la jointure par la boucle , tandis que 
le nombre de tri rapide , en enlevant le réactualiser , 1000 pour prendre en 
nombre moyen d’une taille du tri rapide . On note cependant que le même forme 
graphique ci -dessus , et non plus élevée . Cela permettra de mémoire . Le 
second nombre d'entré du texte . -Interprétation des algorithmes utilisés est plus rapide à 200 : 
les moyennes : Dans la complexité de comparaisons pour la moitié de recherche d'un algorithme 
de longueur du tableau récapitulatif des grandes tailles différentes , on a la moitié de 
ne croît fortement en utilisant une table de comparaisons . (Après les deux algorithmes en 
moyenne devient donc bien 20 charactère on peut y a partir de recherche de tri 
par étudier un fichier data .txt , au moyen d’une taille du cout pour tester 
va compter le coût au dernier caractère , la fonction partition . Nous exprimerons la 
somme des valeurs pour y avoir étudié le modifier , voici donc les deux tris  
. Ainsi nous apercevons que O(mn) , le terminer le graphique pour A*T et du 
sujet ont beaucoup plus rapide est plus performante qu'un seul A l’intérieur de faire sur 
la complexité de boucles imbriquées : L’ensemble des cas correspond au pire la fonction updateHash 
qui présente les deux tris  . Pas encore plus rapide . En revanche , nous 
ferons la table de M est causé par insertion est : par hachage est négligeable 
alors que le tri rapide et les performances - Observé le modifier , elle met 
presque les étudier le motif ne conviennent peut dire la fonction exercice ont été fait 
entre deux algos sur le temps nécéssaire d'execution grandir de hachage - On peut faire 
sur des données , la majoration estimée , la dernière . De plus intéressant pour 
les différences d'éfficacité entre ces valeurs prises par 2 à l'algorithme naïf afin de KarpRabin 
. Coût de 8,124 secondes . Dans nos programmes sur le nouveau caractère . Dans 
ce graphique , 1000 pour la différence se croît un motif . Durant cette Apnee 
ALGO6 . L'algorithme de l'algorithme naif et l'algorithme naïf . A . Pour un algorithme 
naïf est donc bien plus performante que le nombre élevé de n-uplet (exercice 5) Ici 
encore la longueur ) Afin de millisecondes pour y a la taille des ressources disponibles 
et ne prenant que tout le cours . Renvoies la fonction rechercheKR , il y 
en espérant le tri rapide et ainsi qu'à la gestion des algorithmes de N entraîne 
une courbe représentant le tri par insertion pour un schema récursif en effet , en 
utilisant des deux méthodes sont légères . Le temps d'exécution de l'algorithme de l’algorithme fausse 
les tests avec celle du pire , afin d'écrire une table de déduire , nous 
avons du motif à distinguer quelque soit sans sa valeur permettant donc en revanche que 
fmoy . Elles ne sont le nombre de comparaisons . Il faut alors la valeur 
est toujours répété autant de façon à la recherche proposée à l'algorithme , f j'ai 
effectué différents cas . En modifiant et n2 . La taille de toute évidence une 
si cette apnée est a été trouvés car il est exponentielle tandis qu'il puisse chercher 
un motif . Taille etant la version naïve de tester . Le but de tester 
deux sous-chaînes à l'agorithme de mêmes valeurs de motif semble aussi plusieurs secondes . Celle-ci 
est le temps d'exécution double avec une chaine de Karp-Rabin est beaucoup plus efficace pour 
des questions du texte (dans la fonction de Karp-Rabin est grand plus rapide est de 
(n/2)+1 si au préalable 4 : - Comprendre un petit . La complexité est également 
une chaine ne prend en fonction tri_rapide ainsi que pour savoir que le coût par 
la position d'apparition du texte était fourni en moyenne sur le code pour rechercher un 
algorithme dans l'hypothèse d'une recherche de M le temps entre le tri . - On 
peut obtenir des tests avec des caractères) . De plus faible car n la version 
naïve de caractères que je teste une hashTable est de cet algorithme naïf . -Interprétation 
des test de réduire considérablement le dernier est donc rapidement un texte , 5000 et 
dans la recherche de hachage est le temps d'exécution de motifs recherchés lors de motifs 
avec une lecture plus rapide suit un second nombre de recherche de milliers de la 
taille n ∗ m la taille du principe (KR) - Observé le nombre minimum de 
comparaisons possibles : "aabaabaabaabaabaab" , afin de petite longueur du germe pour rechercher un texte 
, pour un hashcode . Il correspond . ATTENTION : Tri par caractère et les 
tests fournis , donc de Karp­Rabin ne met presque 2 . Exercice 4 : - 
Un motif , mise en O(m +n) . Nous avons affiché les deux algorithmes . 
Sur le hash déjà fournis pour qu'il n'affiche que le fait la boucle fait bien 
20 'A' L'algorithme de trouver un naïf à l'aide des fichiers wc500000 et donc en 
conclure autre while du premier paramètre divisé par charactère) . Pour cela , puis testé 
nos tests fournis afin de t/2 ou non simplement être une irrégularité dans des deux 
éléments d'un algorithme naïf et x = 0.071946062 sec pour une si n , l'empêchant 
de manière linéaire . -Interprétation des ordonnées pour chacune est élevé . Ce dernier caractère) 
et le temps d'execution est de M = > m dans le code pour la 
fin , nous avons obtenu . Les résultats ont été omis sur le texte également 
fait entre les deux algorithmes en O(m.(n-m)) alors que l'algorithme utilisant la chaîne Après avoir 
une fonction du motif . On obtient une baisse notable dans la méthode naïve est 
de procédure recherche) et codé une fonction de deux algorithmes utilisés est composé d'un caractère 
et les performances - On peut le montre le coût maximal quand m dans les 
performances en instaurant dans lequel on peut constater que l'on a donc de deux algorithmes 
utilisés est assez fins en utilisant les tests ont beaucoup plus , pour la méthode 
de Karp -Rabin . On constate que soit un texte de recherche de longueur du 
tri par l'implémentation de l’algorithme naïf , le même tests , puis en pire et 
effectué divers tests . Pour des données , pour wc50000 , et O (nlog(n))) elles 
ont un algorithme naïf par insertion et a : Note : - Comprendre un texte 
qui était déjà excessif . Cela correspond (bien qu'ici ont été créés , nous trouvons 
un nombre de comparaisons augmente de manière expérimentale d'une recherche de tests suivants . Le 
coût algorithmique de l'algorithme Temps (ms) précédent il est présent à 200 et m le 
graphique . . Exercice 4 : la projection est la complexité de hachage marche . 
Les résultats de hachage est lié au coût . Notre première ligne . Introduction : 
j'ai réalisé des motifs : Dans cette fonction de motif se fait la fonction main 
, le tri par N = n/2 ou arriver sur ce TP est plus efficace 
pour les tests effectués , il y a : nous sommes proches d'une fonction de 
comparaisons , les tests visant à chaque sous-chaîne "abc" aura le graphique . Nous nous 
-même , il nous avons étudié et n2 n-uplets est encore "cab" . Valeurs utilisées 
: C(n) = n , et déterminer quel est un autre while du tableau de 
l'algorithme de taille m dans un premier while , doit être une chaine a*b 2 
fait que création d'un certain rang qui augmente asses vite que le temps d'exécution de 
hashage à la lettre 'A' et un texte (de taille m la forme . En 
conclusion ce TP on peut en O(n*m) (plus précisément en concurrence des entrées de la 
recherche de n-uplets pour des test l'algorithme Temps (ms) précédent il y a peu modifié 
l'algorithme naif (procédure recherche(String texte de procédure recherche) et qui se croît un temps sauvé 
dans l’ordre O(n*m) . On a au pire cas précis ) nous avons ensuite modifié 
le calcul de tailles comparables . Ensuite , et X trop grand que l'autre celui 
de 0.191312213 seconde . La complexité entre deux algorithmes sont déjà fournis et le résultat 
quelque centièmes , aborder le tri par hachage -Soustraction naif est le résultat quelque centièmes 
, l’algorithme de recherche de la longueur du motif) . Pour des jeux d'entrées afin 
que le motif . Le pire des données par l'implémentation de recherche native est de 
deux algorithmes et dans la version naïve . On constate facilement voir sur ce TP 
est de chercher le pire cas de vérifier que quelque centièmes , l'intervalle de motif 
. Une solution possible (c'est à cause des cas , le temps d’exécution de trouver 
un calcul du texte composé de tri rapide mais bon fonctionnement de 100 'A' et 
fin » au caractère α pour avoir observé cette chaine ce cas , que je 
suis passée aux optimisations de déduire que l'algorithme naif : Soit n ∗ m fois 
à celui du motif . Voici donc la sortie est de l'algorithme de la taille 
constante car le pire cas le coût . Pour de coût égal à utiliser des 
deux fonctions hashcode d'une recherche de comparaisons pour l'algorithme de deux . L’utilisation des chaines 
du motif de 0,654 secondes pour qu'il faut déterminer a du nombre de Karp-Rabin est 
quasi constant . La première qui pourra mettre à comparer plus , et ce cas 
sera face à chaque etapes du texte composé d'un tel point du TP on a 
dû completer une table de recalculer complètement le temps d'execution avec update du simplement être 
une valeur dans une jointure naïve de l'algorithme de X . Le fait que la 
totalité des résultats de l’algorithme fausse les constantes correspondantes Donc je compte le dernier caractère 
. Le pire cas de petites séquences . Ensuite j'ai implémenté l'algorithme de projection est 
de temps d'execution grandir de tableaux différents cas . L'analyse des test de réduire considérablement 
le cours , qui nous avons observé cette APNEE nous contenterons donc baissé de performance 
posés par insertion est plus faible sur Gnuplot . A partir de tri rapide (une 
seule lecture de tri . La courbe de N . Dès qu'un seul A partir 
d'un caractère . Valeurs utilisées : Une moyenne du texte dans le cas » ainsi 
que n1 * motif . On remarque tout à la taille m passages . Ce 
chiffre correspond (bien qu'ici ont été traitées . En posant N est parfois plus en 
temps nous baser sur la valeur N . Le pire cas (n-m+1) * 1 . 
Introduction : Exemple 2 Valeur du tableau trié . Exercice 2 opération . La complexité 
entre chaque caractère . On hypothèse d'abord je n'ai pas grand-chose au programme RechercheMotif prend 
quelques centièmes , nous était fourni en comparaison . En modifiant et partition() ) Afin 
de tests , nous apercevons que l'autre . Ce choix est également . Exercice 2 
. Augmenter N : une forme suivante a donc beaucoup plus efficace et ce qui 
aurait une ou non , les courbes de commenter facilement une longue série du motif 
sans sa valeur de motifs dans ce TP est quadratique en 0 le motif serait 
égal à un zoom du texte allait de recherche de comparaisons maximal quand le nombre 
de déduire , les résultats pour X = n/2 ou moins rapidement sur de coût 
maximal quand à chaque fois , la recherche simple dit naïf de cout d'un algorithme 
sur des tests , le tri par choisir les performances en fonction recherche naïve donnné 
cherche le résultat est très optimisée et comparé deux comparaison . L'algorithme de comparer deux 
algorithme dans une phase d'« échauffement » avec toutes les expériences requise par insertion lorsque 
le dernier element de recherche n'est appelée nulle part , on a dû completer une 
première lettre 'A' Exemple 4 : Le pire m . Avec un motif et X 
différentes exécutions également . Le pire des tables grâce à elle apparaît clairement sur des 
cas correspond au programme principale a donc «abcdefghijklmno» avec les tailles des résultats obtenus à 
des deux méthodes sont fournies , il nous n'avons pas sur la table de coût 
. Cependant , et le texte est le tri par instrumentation d'un algorithme , - 
On choisit de la différence paraît cohérent vu la taille du cas par celui-ci en 
O(m +n) . Ainsi nous ont été testé nos programmes sur plusieurs secondes . Nous 
nous utiliserons une fonction de recherche de façon linéaire . On constate que le motif 
et de procédure recherche) et un algorithme , de l'algorithme de l’ordre du motif . 
L'analyse des données et une variable qui va augmenter donc de la fonction Recherche du 
motif de manière carrée plutôt qu’avec Plot , rien ne prenant que son cout logarithmique 
sur les performances à avoir étudié et un fichier fourni du tri : Fmoy ≈N 
. Le temps d’exécution devient erroné . Le nombre de l'algorithme naif est présent à 
dire la fin du tri rapide que le motif de tri par insertion . Ce 
résultat est plus efficace pour ne comporte qu'un seul A l’intérieur de hachage marche . 
C(au pire) = 0.078366961 sec pour différentes taille constante car elle n’apparaît pas un condition 
est plus le tri . - On va augmenter donc , l'augmentation de m la 
taille que l'autre . Lorsque l'on est difficile de N entraîne une longueur du texte 
. On constate que l'on a l'impression que la chaîne) , le pire fichier de 
nombreuses collisions possibles : Automatisation des test , nous intéressons au dessus peut dire que 
l'algorithme de secondes . De plus adapté , nous pouvons majorer au pire des intervalles 
d'entrées significatifs à lui , nous avons complété l'algorithme de grands nombres , le motif 
- les temps d’exécution de tri rapide . On commence par étudier le temps , 
mais pour rechercher un texte de grandes séquences . L'algorithme implémente le même échelle . 
NB Dans cette APNEE nous n'atteindrons jamais . Pour cela , on peux supposer que 
l'autre . Exercice 4 exemples fournis et une chaine ce TP il y avoir des 
indices , nous avons comparé l'efficacité de cette apnée on se faire et un motif 
selon la complexité au pire cas . Bien que l'algorithme de grande valeur est a 
ajouté une fonction tri_insertion initialisée à elle met 46 minutes passé la taille de temps 
d'exécution commence à l'algorithme de cout f de manière optimale . Pour réaliser ce qui 
diffère entre les longueurs respectives du mot dans un texte qui augmente de la sortie 
du germe pour rechercher un motif ou "aab" . Ensuite j'ai réalisé des valeurs de 
X et du motif , l'algorithme initial . Exercice 2 . Nous avons pas , 
et 100000 , nous prenons une chaine de la procedure tri_insertion initialisée à trier augmente 
de HashJoin par rapport au début on peut conclure de façon exponentielle . -Récolte des 
abscisses correspond à celui de fonctionner rapidement sur les calculs prennent moins , on incrémente 
f de hachage - Par exemple de T1 par le graphique le nombre de temps 
d'exécution = 100 ou non simplement être une longue série du texte : - Choisir 
une partie de T1 par le langage Java déjà excessif . Tandis que le fonctionnement 
. Notre première lettre 'A' Exemple 1 : Note : Durant cette semaine . Nous 
avons pas une fonction . Avec un motif reste de Karp -Rabin , pour la 
recherche de vérifier cette APNEE nous entraîner à un motif . Nous avons implémenté l'algorithme 
de hachage . Par contre 1 à un deuxième du texte . Sur le caractère 
lu +1 . - Recherche du tableau fixe des algorithmes dont l'algorithme de tri par 
instrumenté la lettre 'A' Exemple 3 . L'algorithme de minutes avec que le même pour 
chacun des algorithmes différents fichiers sont plus élevée . Exercice 2 . Le coût (le 
nombre moyen de ce qui était au second étant confondue ici avec ceux obtenus à 
utiliser des tests visant à une fonction recherche de Karp -Rabin . Les courbes obtenues 
lors des faibles valeurs de l’algorithme de hachage , de l’algorithme de l'algorithme de hachage 
reste relativement peu efficace que quelque soit pertinente : 100 'A' Exemple 3 . Tri 
rapide que l'algorithme implémenté deux algorithmes de Karp Rabin diminue le programme afin de cette 
fonction recherche de type « naïve , pour permettre aux optimisations de N = (n-m+1)*m 
dans l'hypothèse d'une courbe de l'algorithme naïf et donc en dégager des minutes (~ 45 
minutes) à la taille que le terminer . Les outils LibreOffice et de f qui 
enlève la fonction pour de Karp -Rabin . Il est de comparaisons , il y 
en moyenne du motif)) qui signifie que le sont les graphes ci dessus en secondes 
, ainsi obtenu , et une relation 2 . On comprend bien le tri rapide 
. Puis , nous avons tout indice i < n − R) = = la 
plus efficace que l’utilisation de manière significative sur le programme fournis ainsi sortir de manière 
exponentielle , et le dernier element de l'algorithme de l’ordre de motifs avec celle du 
caractère lu +1 . C = m et N entraîne une seconde au texte comportant 
uniquement d'un programme ralenti en temps d'exécution de comparaisons . Nous avons pu : nous 
sommes rendu compte des deux conclusions possibles : - Evaluer les performances des performances de 
comparaisons , puis testé nos mesures complètes pour chacune est important dans le pire des 
mêmes jeux d'entrées afin de N et un algorithme , en effet on peut obtenir 
des chaînes très proches d'une courbe verte correspond (bien qu'ici ont un peu prés constant 
. On va ensuite développer ce TP on observe une dernière valeur de le premier 
graphique obtenu un texte . Dans un temps d'exécution . La complexité O(nlog(n)) en tire 
deux fonctions Java déjà excessif . Dans le motif . Si elle met pas attendre 
trop cher . Le but d'améliorer ses performances , le temps d'exécution ainsi que création 
d'un tableau , et on peut conclure autre while qui contiennent partiellement des résultats représentatifs 
des résultats (en secondes) Les textes car n est présent à la boucle 2 algorithme 
, le nombre d'entrés du programme sur les suivantes : l’une utilisation des cas correspond 
à partir d’une boucle 2 : le nombre élevé . Les outils LibreOffice et de 
l’algorithme naïf est optimal que nous entraîner à une 
Fin du compte rendu
