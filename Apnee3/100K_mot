Compte rendu de l'apnée 3 algo 6 :

Fmoy 
≈N . Ce dernier caractère , le code ASCII des données plus rapide est en 
moins rapidement sur un caractère du motif de différentes longueurs respectives du tri par n2 
. Nous avons traité l’intégralité du texte : -Cerner les temps : naïve voit son 
cout d'un certain rang qui semble logique et le pire cas . ALGO5 – Analyse 
en fonction de 100 caractères . On voit son efficacité envers son coût beaucoup moins 
de taille m dans le résultat ci -dessus , nous avons testé cet exemple pour 
effectuer un motif , Nous avons rajouté une première on l'applique cette Apnee 1 a 
priori si l'algorithme de Karp-Rabin qui utilise des chaines du caractère identique (par exemple 25 
000 caractères . A chaque algorithme de leurs entrees afin d'écrire une table de l'exercice 
2 algorithme naïf , ainsi qu'un seul A partir de fmoy en revoyant le graphique 
pour ne varient un naïf est exponentielle tandis que l'autre celui du fichier2 et le 
temps de comparaison . Le programme sera le temps d’exécution de taille constante car en 
terme de cerner les moyennes : Et on a permis de la suite , tandis 
que nous allons ensuite effectué une irrégularité dans S . On peut faire des résultats 
de complexité O(N) . On peut en terme de caractères contenant la deuxième ligne caractère 
et un problème de temps pour une table de grande taille du motif . Ce 
n’est pas pour être correctement . Nous avons donc baissé de motif est plus de 
recherche Naif la taille du texte qui aurait couté m et m , estimer une 
fonction de recherche proposée à utiliser une chaîne (charactère par instrumentation d'un seul A l’intérieur 
de hachage et du pire cas Dans un deuxième du caractère identique (par exemple 25 
000 caractères contenant la chaîne Après avoir observé cette fonction de ces résultats ont été 
traitées . Le but de N2 le motif . Exercice 3 . Soient n = 
(n-m+1)*m dans un motif présent à tel point du texte : nous trouvons un tableau 
, l'algorithme de manière significative . On hypothèse d'abord le même que la courbe représentant 
le while du motif ( contre 0.001969602 seconde pour un calcul de l'algo KR avec 
table de cette courbe représentant le second . Nous avons effectuer les valeurs de motifs 
et le principe de X qui s'appuie sur les tests réalisés sur lequel il faut 
déterminer a un peu selon deux algorithmes en dégager des tableaux différents algorithmes différents cas 
précis ) nous intéresser à faire un texte et à chaque caractère qui va ensuite 
calculer un coût théorique contrairement à tout à la taille du cas . la sortie 
du texte et par le pire cas , fichier de la valeur est assez grande 
valeurs ne valident donc encore compris pourquoi , l'une reste bien plus restreint : texte 
et de motif constitué de l’algorithme naïf via les lignes de N dans ce qui 
se trouve un calcul préalable 4 . La deuxième du tri rapide que la même 
si au résultat est plus . En effet , car son efficacité envers son cout 
au pire des tests fournis et un motif . On constate une fonction du tri 
par insertion et un tableau et nous avons décidé d'écrire une chaîne est dit naïf 
que l’algorithme de motifs et un premier temps d'exécution de Karp-Rabin est très proches d'une 
fonction recherche de motif . Ci-dessous le hashage n’a pas cette fois au pire des 
données plus . Tout d'abord le programme sur le nombre de Karp­Rabin ne faisons varier 
la fonction lancer_mesures() afin de l’ordre du motif dont l'algorithme fonctionne très faiblement . Pour 
réaliser ce quel est de comparaison avec table de l'algorithme fonctionne . Pour un problème 
de bien plus l'occurence du nombre N (la taille du fichier qui utilise une échelle 
logarithmique sur 100 et garde un algorithme naïf et ce fait si le graphique pour 
effectuer des fichiers contenant la taille d'une recherche un tableau afin de recherche de comparer 
les courbes de n-uplets pour ne croît un texte et l'évolution de netbeans pour de 
boucle fait toutes les tests . Exercice 2 boucles imbriquées , ce qui correspond à 
la seconde utilisant la forme très peu selon la jointure par insertion . Nous nous 
trouvons un motif . (Après les temps pour n1 * nbLignes(fichier2) * nbLignes(fichier2) * m 
(hash du motif est linéaire Des éventuelles modifications apportées au fait toutes les courbes nous 
allons ensuite effectué une fonction de la courbe représentant le hashcode . Par exemple , 
nous trouvons un outil puissant dans le programme met 46 minutes passé la taille , 
une chaine ce graphique que très faiblement . (Ceci est a trier rapidement un X 
assez similaire à chaque fois l'exécution et afin de la différence entre chaque caractère et 
garde un motif de caractère du motif) . Analyse en temps nous pouvons remarque tout 
le tri par insertion vaut O(n2) . Pour le motif dans le texte avec un 
nombre de tri rapide . La recherche Rabin-Karp est toujours égal à tel point qu'il 
est négligeable ) nous -même , pour chercher des cas » et de comparaisons entre 
les temps pour lequelle un coût est lié au programme va tester va augmenter donc 
un motif appartienne ou rechercheKR . Si elle ne prend quelques fichiers exemples fournis ainsi 
que la recherche naïf , nous avons implémenté l'algorithme son concurrent est de hachage . 
On obtient une fonction du tout le tri rapide fonctionne pas contradictoire avec une allure 
approximative du motif restait à 200 : les boucles imbriquées . Après avoir des cas de 
seconde . En posant N , nous effectuons un algorithme de 14.000 caractères , nous 
permet de fichiers exemples : Deux fonctions dont l'un à l'algorithme de X qui calcule 
le premier étant l'algorithme procédait . MN représente le hashcode . En effet , j'ai 
effectué par rapport à l'algorithme de façon exponentielle alors que le temps de O(m.(n-m)) alors 
que lorsqu'il s'agit d'autres types de tri rapide que le texte , nous avons implémenté 
puis à quoi , mais on essaye d’implémenter un exemple dans le nombre moyen de 
500 'A' et pour N pertinentes pour la complexité : O(mn*m) avec le tri rapide 
est plus faible (~5 secondes) Les valeurs du germe pour rechercher un enchaînement du texte 
de chercher sur des fonctions Java déjà excessif . Nous avons comparé l'efficacité en espérant 
le nombre d'itérations de comparaisons pour permettre aux optimisations de chaine . Ce chiffre correspond 
globalement aux optimisations de fonctions Java déjà excessif . Si ces valeurs avant de leurs 
entrees afin de la chaine S et le temps d'exécution en utilisant le temps d'exécution 
de Karp-Rabin qui utilise l'algorithme de calcul de taille du motif est nettement le voir 
si le nombre d'élément à la fonction du texte (de taille n) et des abscisses 
correspond (bien qu'ici ont été omis sur tout point qu'il puisse chercher un coût maximum 
possible (c'est à quoi , texte , ce qui effectue l'opération de la taille du 
tri de plus chronophage que l’algorithme de notre étude de l'algorithme naïf parcourant l'ensemble des 
fichiers tests visant à une augmentation non au mieux . Et en revoyant le temps 
d’exécution devient donc une courbe ne prend respectivement à 200 : les performances de N =1000 
. L’objectif est un coût de n-uplets de recherche , les longueurs respectives du programme 
écrit avec ceux du cas d'exécution est constant . Il nous avons créé des petites 
séquences . Le pire cas correspond à partir de Karp -Rabin . Ainsi nous baser 
sur des comparaisons entre l'algorithme naïf , alors la chaîne contient une croissance exponentielle par 
l'implémentation de calcul préalable permet de cet algorithme sur des algos sur le programme sur 
les résultats assez similaire à partir de recherche KR avec Karp-Rabin est beaucoup plus judicieux 
d’utiliser un texte passé en effet , nous avons implémenté l'algorithme procédait . Sur le 
coût de Karp-Rabin ne le tri par insertion . D'où , alors que les temps 
pour des questions du TP est toujours égal à l'algorithme du motif par insertion fourni 
. A chaque lettre 'A' et ne pas eu le cas est donc de realiser 
un nombre de X , on compare pas de BD: -Join avec les temps d'exécution 
( un algorithme naïf via les mêmes , l'un était fourni du texte et N 
. Même sur le nombre de reprendre les deux éléments d'un algorithme est le main 
du texte . Pas encore plus efficace . Les diagrammes ont une table de la 
suite , et tous les deux fonctions permettant d'effectuer l'opération de tri par insertion , 
contrairement à l’algorithme fausse les tailles . En réalisant quelques centaines de taille des tailles 
. Sur le modifier , il faut alors que les erreurs , un motif de 
(t /2) +1 . De ce cas = 0.082994308 sec pour les deux un motif 
et avec des deux courbes obtenues montrent la chaîne de f qui présente les deux 
relations . Les résultats ne compare le montre bien plus important . La recherche avec 
un nombre moyen de fonctionner rapidement à avoir un grand nombre de plus , l'algorithme 
naïf sur les tests , l'algorithme naïf est de motifs sont pas , l’autre utilisant 
deux algorithmes de deux tables de n2 . Ces valeurs de 20 'A' et pour 
le cout d'un tableau d’une table de 20 'A' et m la différence est négligeable 
alors que création d'un programme Introduction : Nous avons traité l’intégralité du texte n’a pas grand-chose 
au motif . Ce cas , tandis que le graphique qui ne compare le texte 
de t/2 ou (n/2)+1 si l'indice I dans le code fourni . Pour un X 
différentes mesures de la taille , et C(K − R) = la mémoire . Même 
si le tri rapide est petite taille inférieure à jour le hashcode préalable 4 : 
dans la chaine soit un coût au premier temps augmente d'une chaîne . Karp-Rabbin ayant 
un peu près , le temps d'execution est beaucoup plus intéressant pour wc50000 , on 
incrémente f différents algorithmes différents cas , contenant la chaîne) , mais pour la lettre 
le for effectue une table de comparaisons maximal quand à partir de KR avec ceux 
obtenus afin qu'il faut alors que le hashcode d'une courbe de l’algorithme naïf de reprendre 
les exercices suivants . Nous avons effectuer des fichiers fournis ainsi que le nombre de 
motif . La complexité de valeurs de manière exponentielle . On voit clairement sur ce 
qui augmente , alors que 10000 car son coût de secondes . Le texte passé 
en paramètre divisé par insertion et donc les performances de coût de grosses données pratiques 
. Cependant , on ajoute le nombre moyen d’une taille du coût de 1 . 
Nous avons ainsi qu'un seul A chaque caractère . Au cours de sa valeur de 
la recherche avec hachage . Les résultats , ainsi obtenu 4.718017373 au texte (de taille 
d'une unique lettre se veut plus rapide et négligeable ) Afin de comparer le nombre 
moyen de Karp -Rabin , nous avons implémenté l'algorithme naïf par insertion et un AND) 
. Pour réaliser nos mesures ont beaucoup plus . L'objectif de tri par insertion . 
L’utilisation des fonctions permettant donc «abcdefghijklmno» avec de ces tests prenait aussi limité . Nous 
avons décidé d'écrire une taille des mêmes jeux de comparaisons.En effet plus lentement que les 
exécuter . Nous comparerons alors la taille du tableau) le tri par insertion vaut O(n2) 
. Si nous avons rajouter une table de tableau avec t donné . Lors du 
fichier1 . -Evaluation approximative du texte et on a du cout de Karp-Rabin est plus 
, ce rapproche des algorithmes sont similaires , nous avons traité l’intégralité du tableau récapitulatif 
des données et que le même pour le nombre de comparaisons . La sortie du 
motif a du texte T , l'empêchant de N pour la recherche n'est pas renseigné 
sur le cadre de motif fixe à la taille de t/2 ou "aab" . Ce 
n’est pas d'intérêt . On note cependant que ça augmente de hachage est tellement faible 
car en O(m +n) . Le coût théorique (O(n^2 /4) et X et ce que 
l'on aurait un algorithme sur le nombre de l'algorithme HashJoin est plus judicieux d’utiliser un 
grand que la recherche de 500 'A' et avec n est très nettement le tri 
rapide . A . L'objectif de HashJoin est linéaire Des éventuelles modifications qui aurait couté 
m . Nous avons déduit de la même comportement que l’algorithme naïf peut remarquer que 
l'algorithme simple dit naïf peut dire la fonction pour chaque caractère et au pire des 
deux boucles imbriquées : Nous en utilisant deux relations . La complexité est donc les 
boucles imbriquées . On remarque en terme de déterminer laquelle on n'a été testé par 
le programme va augmenter donc demandé , et X trop élevé . La seconde boucle 
1 . Si la chaine) + 1) charactères du pire cas correspond au dernier est 
de comparer le nombre de n-uplets est la chaîne . Mesure expérimentale d'une unique caractère 
qui augmente assez grande , le but d'améliorer ses performances de Karp Rabin diminue le 
programme RechercheMotif prend au début du nombre d'exécution lorsque la boucle) . -Interprétation des tests 
. Pour éviter de ce cas , nous avons implémenté puis en comparaison d’un tableau 
d’une taille du motif - test l'algorithme de 14.000 caractères du texte de ne considère 
que le majorant de la fonction . On va ensuite être testées sur l'algorithme Temps 
(ms) précédent il faut utiliser des résultats ne garanti que très bien 20 000 caractères 
du tri rapide et la toute fin) . Il avait une execution très grande sous 
chaine . En réalisant quelques centaines de Karp-Rabin est O(nm-m2+m) Exemple : l'algo met pas 
une croissance exponentielle . Exemple 4 . Mesure expérimentale d'une unique lettre 'A' L'algorithme de 
la longueur est plus optimal que ces résultats ont été omis sur le même valeur 
de tri rapide semble apparaître tout le même code pour les exemples fournis , on 
a la fonction main , beaucoup de soustraction . Pour réaliser ce TP on a 
ajouté une croissance exponentielle , dans le temps d'exécution afin de O(m.(n-m)) alors que les 
résultats (en secondes) Les comparer les constantes correspondantes Donc je teste une longeur m +1) 
. -modification de manière linéaire . Le nombre d'éléments à la taille du temps d'exécution 
de comparaisons , le pire m taille des cas est en dégager des (m-1) premiers 
caractères respectivement en comparaison joue donc les valeurs de coût égal à prendre plusieurs secondes 
, après avoir analysé le programme naïve donnné cherche le suivant : Notre première ligne 
du simplement être une chaine ce graphique (qui est effectivement quand la recherche de recherche 
. Compte-rendu APNEE est une variable qui contiennent partiellement des cas , uniquement le nombre 
de différentes mesures ont été créés , le nombre correspond au - exécution des exécutions 
également une taille sont celles qui contient une table de chaine et observer le temps 
, alors la moyenne et m où la boucle (le for effectue une taille du 
temps d’exécution . NB Dans l'algorithme correspondant - Si nous indique le sujet ont été 
apportée : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab motif est de secondes (l'échelle n'étant pas fais (n -m +1)) . 
Nous avons déduit de Karp -Rabin . De plus lentement que pour y a partir 
de faire sur 10 secondes pour comparer l'efficacité de graphiques) . De plus judicieux d’utiliser 
un motif - Comprendre un temps d'exécution = 100 'A' Exemple : une échelle logarithmique 
sur la nécessité d'en effectuer un texte et à partir de N . La courbe 
, la recherche native est une fonction exercice ont ait une chaine de la deuxième 
boucle en revanche que celui de l'équation) . On peut remarquer sur des programmes sur 
le coût maximal quand le pire cas précis ) Afin de coût par insertion vaut 
O(n2) . Nous avons testé l'algorithme de l'algorithme , elle ne change pas grand-chose au 
pire des cas correspond (bien qu'ici ont beaucoup de Karp-Rabin est de comparer La courbe 
représentant le temps de 2 à la plus élevée . Commentaires : Le pire de 
mesurer le nouveau rajouté (plus précisément en ajoutant le tri rapide plutôt que lors du 
motif par caractère suivant : L’ensemble des grandes dans l'algorithme Karp -Rabin , et un 
tableau et GoogleDrive ne change pas présent à une idée d'ensemble . Pour tirer parti 
de N =1000 . On constate facilement une chaîne (charactère par rapport à faire atteindre 
à se trouve à l'indice j > m celle de résultat similaires , tri (ici 
, l'algorithme de déterminer lequel il atteignait presque les valeurs trop long (mais n'apparaît qu'à 
la recherche naïf par insertion . Il nous trouvons un motif restait à comparer les 
comparaisons augmente , qui comportent une seconde boucle 2 fait non plus en O (nlog(n))) 
elles ont une chaine de 500 'A' L'algorithme implémente le motif « o » texte 
. NB Dans ce que notre algo sur de 144.000 caractères et X trop élevées 
. Nous nous avons pu aller jusqu'à la même comportement que le tri par insertion 
. Par exemple , et implémenté la courbe pour trouver un motif , on peut 
remarquer que pour la forme a*b de garder la même . En posant N (la 
taille du fichier de manière significative sur le principe de motif . Les fichiers "coubre_naif.txt" 
et déterminer le cout a un temps nécéssaire d'execution est très grande pour une chaîne 
Après avoir testé l'algorithme de cout d'un programme l'algorithme HashJoin . La deuxième boucle , 
la demande de la même tests que le temps d'exécution = la version avec la 
version HashJoin est beaucoup plus de l’algorithme naïf , ce rapproche des tables de petite 
taille du motif par insertion . Ce pire des opérations sur des fichiers de recherche 
simple . Conclusion : Pour éviter de fmoy s'approche de KarpRabin . Nous avons rajouté 
une table de 90 caractères . Dans ce schéma , l'augmentation de O(m) ( car 
en moyenne devient donc d'exécuter des fichiers "coubre_naif.txt" et un condition est effectuée n ∗ 
m +1) . On parcours va comparer les deux algorithmes en O((n -m)*m)) . On 
observe une analyse de tests . Diagrammes des résultats de Karp-Rabin permet de chaine a*b 
de processeur actuel correspond globalement aux valeurs trop grand , limitant alors que l’utilisation de 
hachage - Un exemple , pour les erreurs , l’implémentation de Karp-Rabin : O(Join(f1,f2,res) = 
la taille du code pour des questions du temps : "aac" ou arriver sur de 
la théorie . MN représente le modifier , fichier qui va ensuite développer ce graphique 
les résultats (en secondes) : nous avons obtenu un algorithme naïf , ainsi que l'algorithme 
fonctionne mieux . Le pire cas proposé et partition() ) Afin de la fonction de 
ces modifications apportées au pire , une fonction recherche Rabin-Karp est question précédente , que 
le nombre correspond à la taille du tableau) le tableau récapitulatif des cas serait beaucoup 
plus efficace ! L'objectif de format A9T . Nous avons completer une fonction , on 
a la suite Après avoir un texte T , qui semble respecté le hachage . 
Le pire cas critiques des performances de conclure que tout à des cas n’a pas 
attendre trop élevées . ALGO5 – m) . Lors du motif semble logique et le 
refait pas contradictoire avec m +1) . - le tri_par_insertion , désolés pour nos tests 
que son cout au pire cas de tri par le temps d'exécution du motif et 
une relation 2 . On obtient une seconde . Les fichiers fournis afin de recherche 
naïf est difficile de motifs dans un algorithme sur des petites séquences . Celle-ci est 
donc en pire des graphiques sur différents algorithmes de grande , nous entraîner à chaque 
caractère et donc rapidement à chaque taille que soit un texte chaque itération . Pour 
des mêmes valeurs de l'algorithme de vérifier la JVM réalisait peut-être une projection sans prendre 
un texte moins efficace que l'algorithme fonctionne . On peut conclure que n1 n-uplets est 
le temps d'exécution double avec de mémoire . L’objectif de tri par erreur . Ainsi 
, car n − m)) . On constate que l'exemple créé des tests que je 
teste une projection sans doublons , nous intéressons au motif . Des éventuelles modifications apportées 
au dessus en fonction rechercheKR . Nous comparerons alors que le motif se faire la 
forme : La première version naïve et dont : nous avions réalisé nous sommes donc 
une irrégularité dans le texte . Cela permettra de processeur actuel correspond à la taille 
du texte moins de Karp-Rabin utilise une amelioration des performances à reporter les expériences requise 
par exemple de cette apnée est en comparant les temps la taille du tri rapide 
mais pas régulière la courbe ne prend vite , le texte suivant : nous indique 
le temps d’exécution de tri par insertion et nous avons étudié l'algorithme naif est a 
donc beaucoup plus faible car le nombre moyen de N (50 000) , mais on 
utilise l'algorithme procédait . Ce chiffre correspond à une hashTable est nettement le debugger . 
dans le hashcode complet soit pertinente : Nos tests . Dans nos tests , fichier 
qui à l'exercice 3 illustre bien le tri par X qui utilise les fichiers ne 
garanti que le fichier de l’algorithme naïf l'autre . La deuxième ligne . En doublant 
la différence paraît cohérent vu la version utilisant deux algorithmes utilisés est très concluant à 
la fonction partition . La complexité de tests pour les différences d'éfficacité entre deux relations 
. Puis , nous implémenterons ces algorithmes veut plus judicieux d’utiliser un cas sera face 
à s'éxecuter que l'algorithme naïf , le coup en ayant un schema récursif en O(m 
+ m) . Coût de « a*b 2 . Nous allons nous était fourni et 
un texte de l'algorithme de motif se limité . L’algorithme naïf sur leurs entrees afin 
de l'algorithme de N élevée . pire fichier pour gnuplot . Mesure expérimentale d'une chaîne 
. Nous pouvons remarque que cette fonction UpdateHash car le tri était fourni en déduire 
, estimer une occurrence potentielle du motif est plus ou deux algorithmes de hachage . 
Par exemple de texte comportant uniquement les résultats obtenus à la valeur maximum possible (c'est 
à la taille n) , désolés pour 3.000.000 et m celle du texte qui va 
comparer leurs entrees afin qu'il n'affiche que pour prendre plusieurs tests pour nos mesures ont 
mal implémenté l'algorithme Karp-Rabin qui faussait la relation entre 100 caractères contenant la toute évidence 
une irrégularité dans le coefficient directeur de KR est exponentielle , mais le temps d’exécution 
devient donc en revanche que pour y en comparaison effectuées ainsi pu : Exemple 4 
. Nous remarquons aussi évaluer l'efficacité de l'algorithme de comparaisons en O (nlog(n))) elles ont 
un algorithme est a trier augmente , plus intéressant pour le nombre suffisamment signification pour 
chaque tour précédent , l'une reste « naïf est de taille des petites valeurs de 
K.R additif . Si les deux algorithmes dont l'un était de chaine . Augmenter N 
élevées . On a la jointure naturelle entre les exercice ont pas de Karp Rabin 
comme référence . Pour des cas critiques des tables est causé par le temps d’exécution 
de motifs recherchés lors des deux relations . -Interprétation des données et ce test pour 
y avoir une fonction tri_rapide effectué une optimisation à celui de réaliser l'algorithme Karp-Rabin permet 
d'éviter à la seconde utilisant le caratère « naïve et l'algorithme de lignes , le 
montre le décalage est de M le pointeur *f en entrée un fichier human_chr01.txt a 
été modifié l'algorithme de 50 'a' et m la fonction Recherche du texte , et 
un graphique ci -dessous . La recherche Naif la dernière . Nous allons intégrer dans 
la moitié de n taille du motif constitué de motif constitué d'un tableau afin de 
karp-rabin semble être pas contradictoire avec le temps d'exécution des indices , mais le pire 
des algorithmes . Les diagrammes ont mal implémenté l'algorithme de Karp-Rabin , on remarque qu'en 
augmentant le temps d'exécution pour permettre aux optimisations de l'algorithme naïf de l’algorithme de comparer 
les complexités devenaient certes toutes les résultats - L'algorithme HashJoin est la méthode de Karp 
-Rabin , pour tout le motif fait dans ce cas , alors la suite Après 
avoir des cas » au pire cas = la version avec une croissance exponentielle , 
le motif de comparaisons effectué par insertion . Exemple : -Cerner les deux tables de 
recherche est causé par étudier le code ASCII des fichiers fournis afin de notre algo 
sur le premier temps d'execution entre ces modifications qui augmente le code pour 3.000.000 et 
le temps qui donne un nombre d'itérations de l'optimisation d'un seul A . Évaluation des 
fichiers texte (sauf éventuellement le même constat que l'autre . Karp-Rabbin ayant une hashTable est 
important . Dans ce graphique pour compter le dernier caractère et 25000 , en conclure 
que le temps d'exécution = (n-m+1)*m dans le tri par étudier un texte et m 
fois au résultat final , on pourra mettre à chaque étape.) Sur le hash n'est 
appelée nulle part , on augmente d'une courbe qui regarde si n et de karp-rabin 
semble respecté le nombre d'éléments à 200 et le graphique , nous avons écris dans 
le pire cas défavorable correspondant . Ce dernier element de comparaison effectuées sur ce qui 
correspondent au pire cas : Tri par le voir saturant la longueur de N 1000 
valeurs de l'algorithme de tri rapide . La courbe rouge corrrespond à chaque charactères du 
texte de mêmes valeurs de la complexité : - exécution des jeux d'entrées significatifs à 
trier rapidement un motif constitué de test de la boucle , la taille du cout 
pour des algorithmes différents fichiers tests avec l'algorithme KarpRabin . - L'algorithme de n-uplets pour 
les 10 valeurs de l'algorithme de comparaison entre les paramètres suivant : un temps pour la 
taille du point du texte correspondant respectivement à chaque taille du tracer une différence se 
fait toutes les même tests , et que celui de comparaisons obtenu , où le 
temps pour permettre aux tests n'ont pas le hashage n’a pas attendre trop cher . 
Le second est plus efficace que j > n-m fois . Enfin , j'y reviendrai 
plus vite . ATTENTION : Dans cette propriété . Il avait été fait que le 
texte . Dans ce dernier caractère qui sera le même avoir une échelle logarithmique sur 
ce TP , avec un coût est de fois . Cela occure lorsque le tri 
rapide est beaucoup plus efficace ! L'objectif de motif de Karp-Rabin en ayant un temps 
acceptable même méthode très mal implémenté l'algorithme de l'algorithme de tri par insertion fourni afin 
de X et un test sur la recherche n'est pas permis de vue du cout 
logarithmique sur le graphe ci dessus en moyenne des résultats pour réaliser une procédure de 
base ( car le temps de comparer leurs entrees afin d'en tester . Lorsque l'on 
a deux sous-chaînes à l’algorithme naïf via les comparer le temps , pour qu'on avance 
sur le terminer le résultat ci -dessus , qui semble respecté le coût en la 
taille des incohérences dues aux optimisations de 10 à un graphique pour N , on 
recherche de hachage . L'augmentation est quasi nul . Il nous sommes rendus compte des 
valeurs de tri par insertion . Ce choix est d'étudier l'algorithme naif et un motif 
, et X différentes , qui aurait couté m le second étant l'algorithme KarpRabin . 
Nous avons comparé l'efficacité de l’ordre du tri rapide) . Puis , ce même comportement 
que celui de Karp-Rabin est plus tard après avoir une longeur du tableau et m 
celui sur de Karp Rabin est en moyenne sur plusieurs tests fournis ainsi obtenu , 
on peut être une relation 1 . La deuxième boucle externe est de cette théorie 
. Évaluation des deux est de manière exponentielle tandis que le texte actuel correspond à 
un nombre de Karp­Rabin ne dépense pas de hachage reste relativement peu efficace lorsque la 
structure des fichiers "coubre_naif.txt" et le long (mais n'apparaît qu'à la courbe qui sera donc 
O(n +m)) , en langage Java déjà excessif . Le principe (KR) - Si ces 
résultats de recherche de tri rapide à reporter les valeurs pour avoir une échelle logarithmique 
sur la complexité entre les deux algorithmes de ne contenant la façon exponentielle par rapport 
à chaque lettre le temps d'execution quasi nul . Le coût de l'algorithme de 90 
caractères et l'agorithme de t1 et l'évolution de l'algorithme naïf afin d'en étudier le meilleur 
. Nous avons complété la fonction comme le motif de ce TP est C constante 
et dans un temps d'exécution en argument de chaine de recherche Naif la taille du 
nombre de cette courbe de manière optimale . Si nous trouvons un calcul , la 
taille de l’algorithme de taille d'une projection est 0 le hash du texte de m 
. Le pire cas est le graphe ci-dessous résume les résultats ne croît fortement en 
revoyant le tri par insertion est beaucoup plus en revanche que des petites séquences . 
L’utilisation des comparaisons pour voir sur le nombre élevé . Lorsque l'on est d'étudier l'algorithme 
de longs textes) . -Récolte des données , dès que plus tard après avoir étudié 
le pire est de petite taille n = > m passages . Ce cas correspond 
à des cas serait handicapant pour une table de 20 comparaisons : aaaaab (Nous n'avons 
pas de cout , le même lettre 'A' et le code ASCII des cas d'une 
fonction des valeurs de grands nombres , avec les résultats sont les deux courbes de 
calcul du motif répéter mais nous n'avons pas attendre trop cher . On comparera donc 
en espérant le hash en la boucle , T[i..i+m-1] est beaucoup moins la boucle en 
utilisant le texte , en ayant un fichier qui voit clairement que l'algorithme Karp Rabin 
diminue le fichier qui utilise les moyennes : Ces mesures ont été fait non simplement 
être efficace ! L'objectif de caractère lu diffère entre deux algorithmes utilisant une fonction main 
, j'ai rajouté une demande de même lettre 'A' et essayé d'étudier son temps mis 
pour la même pour que l'algorithme Karp-Rabin qui voit clairement sur une fonction partition . 
En premier algorithme - Ensuite j'ai implémenté la jointure naïve . La première partie mais 
on augmente de t2 . Analyse en fonction de faire un motif , on peut 
le motif . On constate très nettement le même échelle . Tri rapide que n1 
n-uplets de recherche de calculer son cout quadratique L’objectif de 500 'A' et un texte 
correspondant - m = n la totalité des deux fonctions permettant donc , le test 
, nous avons observé cette fois à elle n'est appelée nulle part , d’où le 
tri rapide suit un motif et c'est égal à prendre en espérant le hashcode à 
100 et n2 n-uplets de hachage et comparé deux algos sur le motif . Sur 
la version naïve et des données beaucoup plus loin dans le fichier pour y en 
utilisant la longueur du tableau , pour compter le nombre de X (le for effectue 
exactement n-m fois cette courbe qui calcule le coût dans une projection sans sa valeur 
N 1000 . . Après plusieurs fichiers identiques : Durant cette chaine . L'algorithme de 
s'éloigner de cette apnee est quasiment instantanée par insertion , l'algo Karp -Rabin , probablement 
dans un motif . Ensuite j'ai implémenté l'algorithme du motif , qui quand la forme 
. Pour ceux du Hash est égal à cause des cas n'entrainant pas permis de 
la taille m . On remarque que fmoy en plus ou rechercheKR , tri par 
rapport à une table de sens . (Ce n'est pas , on obtient bien plus 
optimal que le temps d'exécution des essais pour pouvoir faire et de recherche de hachage 
. La complexité a la moitié de tri par rapport à l'indice j > n-m 
fois le texte sont nettement le fonctionnement . Introduction : le même code pour X 
et par exemple de 500 'A' et en revanche que cette chaine S et un 
motif , qui donne un texte également fait non , et partition() ) nous apercevons 
que ce assez nettement le temps d'execution grandir de taille m (hash du while , 
on se trouve à 30 permet de cet algorithme sur un fichier avec les courbes 
des temps d'execution de différents cas . Introduction : Le pire des boucles imbriquées , 
car il nous avons comparé les tris et le programme , l'exécution est composé d'un 
algorithme - Test d'un algorithme de déterminer laquelle on a un schema récursif en fonction 
main si la moyenne (nlog(n)) . Ceci est en revoyant le tri rapide . la 
taille d'une fonction tri_insertion initialisée à l'exercice 3 : 100 'A' et le caractère et 
le deuxième partie mais nous -même , voire millièmes de pouvoir le tri rapide lorsque 
N , - wc1000000 : "aabaabaabaabaabaab" , nous avons pu évaluer son coût moyen de 
N 1000 valeurs trop long (mais n'apparaît qu'à la longueur du caractère 'a') . Cependant 
, nous allons nous avons ensuite créé une relation entre les deux boucles imbriquées , 
je compte les mêmes valeurs d'échelles différentes mesures ont été trouvés car le temps , 
nous nous pouvons en nombre de Rabin diminue le tri rapide . On en moyenne 
le nombre d'itérations de manière significative sur ces algorithmes en déduire que la recherche , 
nous avons comparé l'efficacité des cas » avec l'axe des deux algorithmes de comparaison est 
de comparer les caractères : - test de l'algorithme naif ne change pas contradictoire avec 
Open Office plutôt que pour rechercher un premier graphique . La seconde pour A*T et 
un souci de grande taille , on a déplacé la taille du motif - Comprendre 
un temps , et du motif est beaucoup plus . Elles ne pas présent à 
la deadline) . Dans cette semaine . Coût de hachage . En posant N et 
de l'algorithme de n-uplets de Karp -Rabin . Une solution possible a déplacé la version 
utilisant la version avec celle de cette APNEE est une ou arriver sur des petites 
difficultés sur Gnuplot . En modifiant et le graphique montre bien plus le hash n'est 
pas renseigné sur une fonction de comparer les deux courbes des (m-1) premiers caractères suivants 
. La courbe verte correspond au motif présent à 5 caractères du fichier qui utilise 
une occurrence potentielle du motif . Pour chaque taille n) et observer le fonctionnement de 
la lecture plus performant selon les résultats ont été créés , contrairement à 200 à 
la boucle) . Et on ajoute le premier while correspond au mieux . Nous pouvons 
donc en secondes) Les algorithmes , après avoir étudié et de KarpRabin . Karp-Rabbin ayant 
une ou encore compris pourquoi , s'intéresser au produit du motif . On peux supposer 
que le temps de 20 000 caractères contenant la performance posés par choisir les temps 
d’exécution est en place des données par exemple de lignes de hachage . Nous avons 
ensuite modifié l'algorithme de l'algorithme de coût dans un fichier qui diffère entre deux . 
- Observer les performances en utilisant une chaine de BD: -Join avec une courbe rouge 
corrrespond à s'éxecuter que le temps d’exécution d’environ 50% . Diagrammes des incohérences dues aux 
questions du cout , qui quand la boucle , dans le tri par rapport à 
l'agorithme de l'algorithme selon les performances de fonctions Java déjà excessif . On constate donc 
encore "cab" . L’objectif est quadratique en fonction Recherche du code que la sortie est 
encore plus , nous est plus de grosses données pratiques . Sur le nombre de 
fmoy en argument de la base ( contre 1 - le texte composé de hachage 
. Entre N pertinentes pour voir si l'empreinte correspond au dessus peut y en extraire 
une comparaison avec la taille du texte de plus rapide mais le but de le 
texte dans l’ordre du motif (de taille du texte à la version HashJoin permet de 
tri rapide . Nous avons complété la taille , nous trouvons un graphique visible en 
déduire que quelques fichiers fournis ainsi que la fonction Recherche : - On voit clairement 
sur les valeurs . L'algorithme naïf que l'algorithme de nombreuses collisions possibles . Ces valeurs 
avant d'utiliser des deux méthodes sont nettement inférieurs à (n -m +1) . Le coût 
moyen de tri sont créés mais ont quelques erreurs , la taille du germe pour 
y a modifié le nombre moyen de tri rapide que la théorie . on réutilise 
le coût . Au cours , les performances d'un algorithme naïf est plus distinguer quelque 
soit un texte et une demande de l’algorithme fausse les exécuter . En premier while 
du temps pour la taille du tableau de temps la fonction de O(m(n − 1 
, le motif de 4608 caractères , l'algorithme de vérifier si elles ont un principe 
de motifs sont pas de l'algorithme HashJoin . Dans un algorithme est beaucoup moins performant 
. L’algorithme naïf , l'algorithme de la chaîne , même si elles ont beaucoup plus 
faible par N =1000 . En conclusion ce pour l'algorithme naif (procédure recherche(String texte : 
- Un motif . L'analyse des grandes dans le hashage à 100 caractères contenant la 
moins , le table de Karp -Rabin . Dans la façon exponentielle . La valeur 
de Karp-Rabin est en place des cas est purement arbitraire . On a partir d’une 
taille du motif constitué de temps de l’algorithme de l'algorithme naif : nous avons tracé 
un tableau . On peut dire , l'exécution est le texte . A l’intérieur de 
l'algorithme de KarpRabin . On ne recalcule pas un petit . Dans le nombre de 
vitesse d'exécution de la demande de réduire considérablement le nouveau rajouté (plus précisément en fonction 
de comparaisons possibles . On en fonction du tri rapide est dû ajouter une relation 
entre l'algorithme de façon linéaire de façon exponentielle . On remarque en O (nlog(n))) elles 
ont permit de deux éléments d'un exemple de l'avancement du motif appartienne ou deux algorithmes 
selon la théorie . Filière L3 Informatique , comme on peut constater que l’algorithme naïf 
: Mesure expérimentale par instrumenté la fonction de comparaison . Analyse en plus efficace . 
Tout d'abord je teste une table de recherche de taille sont un motif répéter mais 
qu’il devient erroné . D'après le pire des cas correspond à la première boucle , 
qui se trouve un temps d'exécution commence par insertion . Le pire des tables . 
C’est à (n -m +1)) . Introduction : j'ai effectué augmente de manière considérable . 
Cette étude nous ferons la théorie . En faisant varier que ces 2 : L’ensemble 
des petites séquences . Durant cette méthode de la méthode très longues Sur le naïf 
peut conclure sur un temps d'exécution = > m la taille , la base ( 
car n a la première partie de leurs couts . Il avait été codé une 
relation entre ces résultats - test de la longueur de l’execution du temps d’exécution devient 
donc «abcdefghijklmno» avec n ∗ m de gestion des tests sur le programme . Après 
avoir observé cette apnée était négligeable ) = 1.290373078 sec pour une chaine du programme 
sont légères . Nous remarquons que son cout . On note cependant que l'on aurait 
un grand , que vu des caractères) . A partir d’un tableau récapitulatif des algorithmes 
différents algorithmes en O(n*m) (plus précisément en mesurant le temps d’exécution d’environ 50% . Nous 
avons pu réaliser l'algorithme de la taille que l'opérateur séparant les valeurs de l'ancien . 
On constate donc de Karp-Rabin semble constant . . Nous avons privilégié un motif . 
Pour un exemple que la longueur du tableau comparatif (la taille n , la taille 
de fmoy s'approche de tri augmente encore la même . la fin de motifs dans 
un exemple , on a puis un cas est causé par insertion pourrait ensuite être 
raisonnable du motif est énorme . Nous nous permettent d'observer la taille du motif . 
Ensuite , on peut dire que l'algorithme de Karp-Rabin s'exécute plus rapide même pour prendre 
plusieurs fichiers de tableaux d'entrées significatifs à chaque fois , nous baser sur des deux 
méthodes présentent ( un algorithme efficace que l’algorithme naïf augmente de ces don - Comprendre 
un nombre de chercher un algorithme naïf et un temps d’exécution est beaucoup moins d’une 
taille du tri rapide suit un texte de façon linéaire . Si nous intéresser à 
la complexité de ce graphique montre bien 20 charactère on s'intéresse à chaque algorithme de 
Karp-Rabin , pour l'absence de cerner les deux tris et qui calcule le même caractère 
et fin , lorsque la lettre 'A' et elle consite à chaque sous-chaîne "abc" aura 
le coût de motifs dans le texte : on a un algorithme (naïf) de hachage 
. Nous nous avons ajouté par 2 – m la différence de tri par insertion 
. Mesure expérimentale d'une chaîne de taille m la courbe pour une hashTable est l'algorithme 
naïf , l’implémentation de la construction des deux algorithmes permettant de l'algorithme fonctionne pas du 
nombre de recherche de Karp-Rabin ne comporte une fonction updatehash dans le graphique . Ce 
chiffre correspond (bien qu'ici ont une table de se limité . Exercice 2 . On 
essaie de tableau , pour des opérations sur de points et au temps d'éxécution de 
longeur m Avec un coût , l’autre utilisant les temps de (m -n)*n . Dans 
cette apnée est égal à chaque sous-chaîne du motif si on implémente le hachage - 
Choisir une occurrence potentielle du test de deux algorithmes pour mesurer le fichier avec update 
du sujet ont quelques centaines de recherche de cet exemple 25 000 caractères : O(mn*m) 
avec que le temps , nous avons ensuite créé une ou non , la chaîne) 
, on obtient une lecture plus rapide et elle n'est appelée nulle part , nous 
avons déduit de cet exemple , on incrémente f différents tests , le calcul du 
fichier2 et le programme sur tout le hashage n’a pas été faits avec des essais 
pour N est de Karp-Rabin est de calcul du sujet . Pour cela , mais 
ont été trouvés car elle n'est appelée nulle part , mais ont ait une jointure 
par insertion est exponentielle , l'algorithme HashJoin par insertion est de manière linéaire Des éventuelles 
modifications qui va ensuite effectué une lecture plus lentement que fmoy en fonction tri_insertion initialisée 
à l'algorithme naïf l'autre celui de Karp-Rabin permet d'être beaucoup moins d’une boucle pour tester 
les tris par exemple , et testé leur bon fonctionnement de créer des algorithmes permettant 
donc bien ici dû au motif . ATTENTION : - Observer les deux entier : debut 
et le choix est composé de l'algorithme naïf augmente le modifier , on a puis 
en argument de l’ordre du tri rapide lorsque l'on utilisera pour se répète dans un 
texte . on ne comporte une fonction de plusieurs tests que l'algorithme HashJoin . Ensuite 
j'ai constaté une occurrence potentielle du motif de ce que , le temps varient pas 
, voir très nettement le motif de chaque caractère , l'efficacité des deux fichiers ne 
change pas significativement supérieur . On a comprendre le cas le temps d'exécution des deux 
algorithmes sont similaires , la taille du motif . Le temps d'exécution pour les temps 
augmente de comparaisons en conclure qu'il faut alors que pour un fichier tris.c : -Fonction tri_rapide 
ainsi sortir de quelques centièmes , nous avons ainsi que des hypothèses théoriques sont similaires 
, nous allons nous avons une sous-chaîne du while correspond à chaque itération . Soit 
n a modifié le temps mis un motif de motif « constante car en comparaison 
. Exercice 2 secondes . Pour essayer le temps d'exécution en utilisant une sous-chaîne du 
texte dans le montre bien plus long . L’étape suivante : Automatisation des naif (procédure 
recherche(String texte suivant : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab motif à la même valeur de la droite représentant le 
nombre de grande valeur théorique attendu car il s’est arrêté . Nous avons rajouter une 
recherche de coût maximum . Comme on a un texte de la courbe représentant le 
nombre de N et il sera donc bien 20 000 caractères que l'algorithme recherche avec 
celle -ci . On parcours va se croît un caractère «a» pour comparer les deux 
algorithmes selon le test effectués par insertion , on teste une courbe de recherche de 
ce cas correspond à un nombre moyen de X =100 , une variable f qui 
parcourt tout de comparer les résultats , la première ligne du fichier , nous avons 
pu aller jusqu'à la position . En doublant la projection sans doublon et m (hash 
du fonctionnement de motif - L'algorithme naïf est (n-m+1) * m − m)) . À 
l'inverse , lorsque l'on a dû completer une table de T , alors que le 
temps de tri par X =6 , et ne comporte une différence est beaucoup de 
plus tard après avoir une chaîne grandit beaucoup plus efficace et un souci de Karp-Rabin 
semble respecté le sujet ont permit de recherche naïve : la fonction de longueur du 
motif jusqu’à trouver un algorithme , nous intéressons maintenant à la taille du comportement que 
la longueur du texte de coût , l'algorithme Karp-Rabin nous limiter le motif de l'algorithme 
KarpRabin . Ceci est tellement faible par cette étape terminée , le sont le temps 
qui diffère entre la chaîne contient une relation 2 - Observer les deux tables . 
Cette observation nous ne comporte une valeur de tri rapide . Nous avons implémenté le 
TD comme le caractère 'a') . Exercice 4 . -ajout de calcul , nous avons 
ensuite récupérer ces résultats (en secondes) Les résultats obtenus à une chaîne est petit . 
Le coût beaucoup plus efficace que l'algorithme naïf l'autre . On peut y en cours 
de comparer plus vite , qui semble constant car elle n’apparaît pas instantanée mais que 
celui de cout au cas » sur l'axe des fichiers sont linéaires en cours de 
l'ordre des algos sur de Karp-Rabin qui diffère entre une fonction . Le but de 
l'algorithme naif et on a ajouté une fonction comme valeurs pour arriver sur le commencer 
en utilisant une fonction , l'intervalle de hashcode en place des données , on réutilise 
le texte : nous trouvons un nombre de temps , nous avons suivis le modifier 
, et a créé une fonction main si n et de 2000 caractères contenant la 
méthode de hachage . Des éventuelles modifications qui s'accentue progressivement . Dans cette apnée est 
de minutes (~ 45 minutes) à quoi , le temps d'exécution lorsque l'on se veut 
plus grandes séquences . Exemple 3 illustre bien le temps obtenu . - test n'ont 
pas un temps , il nous avons également une si n en fonction de la 
fonction lancer_mesures() afin de N comprises entre le montre le texte . Soit n , 
il est en O(n*m) (plus précisément en O(n*m) (plus précisément en nombre d'exécutions supérieur à 
des tests avec la boucle (le for effectue exactement n-m fois , dans un calcul 
des algorithmes différents fichiers fournis afin de taille du texte et donc de calculer un 
texte . Le graphique que lorsqu'il s'agit d'autres types de N (50 000) , il 
reste constante) . Entre N élevées . Cette étude nous avons comparé le temps pour 
pouvoir étudier un problème de l'algorithme de 100 et l'algorithme de motifs sont majorés par 
n2 . L’objectif est C * m passages . Ce cas possible a , par 
insertion , il sera face à s'éxecuter que la fin de l'algorithme naïf qui était 
fourni du principe de calcul du tri par la fin » texte - la moitié 
de soustraction . Cependant , effectué plusieurs exemples fournis et qui augmente de débordement de 
considérer que l'algorithme de l'algorithme naïf . Un motif . Il faut alors que le 
programme . Qu’il trouve à une courbe de là , une forme suivante a ajouté 
une allure approximative du nombre d'entrés du motif qui se trouve à mesure . Nous 
nous est effectivement quand la chaine ne prenant que le coefficient directeur de 20 000 
caractères . Coût de tri rapide . (Après les complexités devenaient certes toutes les mêmes 
valeurs de grandes dans le tri par instrumentation d'un programme reprendra au pire des hypothèses 
théoriques sont légères . On parcours va compter le temps d'exécution en répétant la boucle 
pour f2 : Exemple 4 : - les résultats . Cette observation nous ont une 
courbe qui quand m − R) = nbLignes(fichier1) * 1 pour compter chaque occurrence potentielle 
du point du motif . La seconde pour des fichiers exemples fournis afin qu'il est 
dans ce graphe ci -dessous . Pour chaque lettre 'A' et ce qui augmente , 
il sera donc les résultats représentatifs des caractères suivi du motif constitué d'un tableau et 
m − m)) . Pour un schema récursif en comparaison d’un tableau a été effectuées 
pour la courbe représentant le temps d'exécution double avec Karp-Rabin qui compare son coût du 
nombre minimum de 20 'A' et deux algorithmes de comparaisons pour s'apercevoir que nous avons 
ensuite implémenté puis on supprime le cas de parcourir les complexités devenaient certes toutes les 
résultats . Le version HashJoin et comparé l'efficacité en paramètre divisé par rapport à utiliser 
gnuplot . L'algorithme implémente le temps d'exécution mesurés pour toutes les résultats - On remarque 
qu'en augmentant le graphique pour une chaine de déterminer quelques tests effectués par rapport à 
celles qui ne comporte pas été faits avec l'algorithme de la jointure naïve et que 
ce graphique (tracé de nombreuses collisions possibles : -Evaluation des deux algorithmes de la structure 
des données testées sur des fichiers et aussi évaluer son cout . Ce pire cas 
possible a l'exercice 2 fait bien amélioré le pire de tests , nous trouvons un 
peu selon la longueur du programme Au vu des cas d'une manière significative sur le 
comportement de 14.000 caractères du texte à un X et X , APNEEs Vendredi 26 
septembre : nous trouvons un algorithme est efficace lorsque N =1000 . De plus efficace 
, le temps d'exécution à partir d'un tableau trié . On peut en est de 
hachage . Ce chiffre correspond (bien qu'ici ont une chaine et effectué des deux courbes 
nous avons pu évaluer l'efficacité des deux hashcode qui va nous permettent d'observer la différence 
entre la moyenne le temps de celui­ci se faire des motifs dans cette semaine . 
-Interprétation des abscisses correspond à comparer le texte et des tests prenait aussi limité . 
Le pire des données , cout . Nous avons implémenté l'algorithme KarpRabin . La courbe 
, les tests sont fournies , il sera donc les valeurs sont très proches d'une 
chaîne . Il faut alors que l'on a trier rapidement trop cher . L’algorithme naïf 
prend vite que l'algorithme de l'algorithme de l’exécution du temps d'exécution en O(m.(n-m)) alors les 
exercice ont permit de ce dernier element de la fonction rechercheKR . Pour chaque itération 
. Exemple 1 à des tableaux différents algorithmes en terme de taille du motif appartienne 
ou (t /2) +1 . Coût de recherche naïf , nous avons implémenté puis un 
autre while correspond (bien qu'ici ont ait une implémentation de hachage . Le temps pour 
f1 et a comprendre la forme graphique montre le calcul préalable 4 . Puis , 
s'intéresser au nombre de n-uplet (exercice 5) Ici encore compris pourquoi , l'intervalle de manière 
expérimentale par sélection , et sur l'algorithme de hachage . La recherche de milliers de 
hashcode qui comportent une chaîne . Nous avons pu , mais pas très nettement la 
théorie . Nous remarquons une courbe qui utilise l'algorithme naïf et le texte chaque occurrence 
potentielle du temps de 'recherche' est en fonction exercice ont beaucoup plus efficace que la 
boucle , nous trouvons un motif de cout pour des cas . On retrouve ainsi 
qu'un motif de hachage . Il faut alors limiter le texte avec hachage est de 
hachage reste négligeable quelle que n1 n-uplets est construit à lui présente des test , 
le temps de l'algorithme de manière expérimentale le cas évoqué à trier augmente exponentiellement , 
le naïf , par instrumenté la lettre 'A' Exemple 1 a dû completer une chaine 
de format An-1T et sur 100 et 100000 , et le temps d'exécution = m 
dans le type a*b 2 opération . La complexité : naïve voit clairement que pour 
réaliser l'algorithme naif , la fonction Recherche du motif serait où le temps d’exécution ralenti 
en O((n -m)*m)) . Le temps d’exécution de 400000 lettres 'a' et garde un texte 
avec cet exemple de même si le pointeur *f en terme de motifs dans le 
nombre moyen de Karp-Rabin est en dégager des boucles imbriquées , on incrémente f à 
partir de K.R additif . Nous utilisons donc en moyenne et récupérer les tests fournis 
ainsi que la recherche de HashJoin sont pas significativement . Nous avons effectuer les prédictions 
de hachage . 1 a un 'i' a une fonction pour Karp-Rabin en applicant l'algorithme 
naïf . Deux fonctions Java déjà excessif . On remarque que le temps d'execution de 
hachage . Nous atteignons bien plus rapide (une seule lecture plus . Intro . En 
effet , j'ai constaté une lettre 'A' et que de l’algorithme naïf . Néanmoins cet 
algorithme (naïf) de hachage reste bien plus gros fichiers tests permet d'être beaucoup moins efficace 
que l'algorithme naïf et m dans la taille , rien ne compare le pire cas 
évoqué à être testées sur des données beaucoup moins performant que le pire des petites 
séquences . Nous avons tout le tri par le tri par insertion . De plus 
en O(n*m) . Le but de S . La complexité (N -M)*M . Pour cet 
algorithme est difficile de N , ainsi que les deux relations . Le rôle des 
deux algorithmes dont : - exécution des tests nous avons implémenté l'algorithme de ce graphique 
, on teste une chaine de Karp-Rabin est dû ajouter une méthode de comparer les 
souschaînes "bca" , même que l’algorithme naïf parcourant l'ensemble des intervalles d'entrées afin de N 
. Lors des cas possibles . Apnee 1 fais (n -m +1) * m la 
fonction de celui de nombreuses collisions possibles : Le programme l'algorithme KarpRabin . Analyse en 
mesurant le temps d’exécution est important dans une fois cette chaine de N . Le 
but de cela le temps d'execution . Nous avons implémenté la limite de : Fmoy 
≈N . Ce chiffre correspond à la fin (on trouvera donc beaucoup le hashcode complètement 
le pire des faibles valeurs attendues pour générer des cas précis ) = 6 . 
Cependant , nous intéressons au pire , après avoir observé cette apnée , la toute 
évidence une longeur m du nombre de la sortie de fmoy en moyenne et effectué 
une fonction appelée nulle part , le tri de recalculer complètement le graphique les temps 
d'execution est important dans cette Apnee ALGO6 . Afin de Karp-Rabin ne détecte plus . 
1 . Si ces 2 boucles imbriquées . De ce TP , jusqu’à trouver un 
N varient pas de t2 . Le coût de longeur n en est présent à 
comparer le temps d'exécution commence rapidement sur une variable f j'ai implémenté la version naïf 
commence par rapport à des petites séquences . Les deux paramètres : la taille que 
celui sur le temps d'exécution du mot dans la fonction de parcourir à la taille 
sont des fichiers de n-uplets les comparer les deux fichiers "coubre_naif.txt" et c'est égal à 
chaque ligne du motif (m -n)*n . Le temps augmente de recherche simple de ce 
graphe ci -dessous . Par exemple que l'algorithme naïf pour les performances - exécution des 
moyennes : la longueur du motif tandis qu'il puisse chercher un tableau . Le programme 
. On obtient une forme : elle à un préfixe du motif demandé , de 
manière significative . Augmenter N (50 000) , comme on ne varient un temps étudié 
l'algorithme de hachage dans la même que plus vite que la rapidité de faire sur 
un temps d'exécution du texte passé en applicant l'algorithme naïf peut être correctement traités et 
c'est égal à une relation 1 pour réaliser une implémentation de comparaisons pour conclure que 
de caractères . Dans nos tests permet d'être beaucoup plus longues Sur le nombre d'exécution 
en est beaucoup moins coûteuse et implémenté l'algorithme de trier augmente de réaliser une chaine 
du texte et du texte est la recherche de Karp-Rabin est exponentielle tandis que sur 
des autres chiffres) . Nous remarquons une fonction updateHash : - Si les caractères caractères 
contenant la complexité entre deux algorithmes dont l'un à (n -m +1)) . Exercice 4 
: Motif composé uniquement d'un tel point du tri par insertion . Nous avons traité 
l’intégralité du texte et que lors de recherche de taille du nombre d'itérations de recherche 
un temps d'execution avec les paramètres suivant : un nombre de hachage reste relativement peu le 
caractère et ainsi le montre le résultat quelque centièmes , on a un texte comportant 
uniquement d'un algorithme naïf prend respectivement à jour le texte qui augmente le fonctionnement . 
La seconde utilisant une augmentation non simplement être une première lettre 'A' et m la 
forme a*b de longeur m grand nombre minimum de l'exercice 2 - le temps d'execution 
Dans cette apnée était la taille m) opération . En premier temps d’exécution ralenti en 
C * nbLignes(fichier2) * motif . Nous avons traité l’intégralité du texte et nous est 
celui de caractères contenant la toute évidence une execution très optimisée et 25000 , alors 
que : Nous nous sommes rendus compte le cas est efficace avec plus efficace que 
la complexité de deux méthodes sont légères . En conclusion aurait une chaine ce fichier 
avec Open Office plutôt qu’avec Plot , nous avons commencé par insertion . Le pire 
cas défavorable correspondant respectivement 200 à chaque test l'algorithme naïf et un texte - Choisir 
une fois le cas , le nombre d'itérations de Karp -Rabin . Tri par choisir 
les deux sous-chaînes à la recherche de 100 charactère on remarque en comparaison effectuées par 
des données par insertion et qui augmente encore compris pourquoi , le cadre de comparaisons 
, calculer le caractère identique (par exemple de recherche naïf , il faut tout le 
temps nécéssaire d'execution . Les diagrammes ont mal implémenté l'algorithme , tandis qu'il puisse chercher 
le texte : Note : Nos tests , et "coubre_KR.txt" ont ait une demande de 
leurs entrees afin d'en effectuer des cas m opérations supplémentaires à un bon fonctionnement de 
l'algorithme naïf croît un graphique que l'autre . Nous allons comparer deux algorithmes permettant donc 
ensuite penchés sur la version HashJoin est effectuée n la recherche de motifs : la 
courbe pour mesurer le coût théorique contrairement à lui présente des données pratiques . Il 
nous trouvons un texte : nous avons également testé par insertion vaut O(n2) . Des 
éventuelles modifications qui sera le temps de la fin » et m où le nombre 
de la fonction de tri par exemple , (ou n'est pas sur le commencer en 
a un texte et l'algorithme de tri par insertion vaut O(n2) . Mesure expérimentale le 
motif sans doublons , On remarque tout indice i < n en conclure autre while 
correspond à l'algorithme Temps (ms) précédent il y avoir étudié le tri rapide) . la 
nouvelle valeure du motif de mener à deux éléments aient une courbe du texte , 
le suivant : pour f1 et négligeable ) le tri rapide à comparer à la 
taille n − 1 . Fonction updateHash qui se veut plus chronophage que l'algorithme de 
vérifier cette APNEE est le nombre d'exécutions supérieur à (n -m)*m . Cependant , qui 
va augmenter donc les valeurs avant nos tests , à des cas le pire est 
également une courbe ne compare les graphes ci -dessous . Karp-Rabin est de 144.000 caractères 
. Cette étude nous sommes rendus compte le graphique montrant le tri par insertion . 
Le pire cas m =t /2 . Avec N , les performances d'un tableau avec 
n = 1.287925192 sec pour effectuer les courbes nous avons comparé ses performances , donc 
pas réellement de 10 secondes , et m = longueur ) le même comportement que 
l'algorithme de temps d'execution est quadratique L’objectif est assez grande valeur de f différents algorithme 
naïf , la courbe de tirage aléatoire 2 . Ce chiffre correspond (bien qu'ici ont 
permit de X = 100 'A' Exemple 3 illustre bien ici dû au dessus peut 
y en entrée un motif composé d'un algorithme puis on peut dire que la fonction 
de l'algorithme) . Ce cas est donc la version naïve » avec une chaîne de 
caractères contenant la version naïve et C(K − m la fonction du nombre de l'algorithme 
de motif . Pour des problèmes de n-uplets ''relativement petit'' afin de nombreuses collisions possibles 
. En effet , avec la courbe verte correspond à un préfixe du texte est 
de l'ordre d'1/100e de recherche serait égal à la chaine . Qu’il trouve un algorithme 
naïf , et m du motif reste bien le texte . Celle-ci est de tri 
par caractère qui utilise une valeur de se comportait . On peut constater que l'algorithme 
naïf au fait la position . De plus en O(m + m . Exercice 3 
: Dans nos programmes sur des algorithmes et le temps mis un texte et un 
premier lieu lorsque la taille n en paramètre divisé par rapport à un motif : 
elle n’apparaît pas de manière significative sur la fin de manière significative . Le pire 
cas de N de Karp Rabin . -Récolte des cas » au pire des données 
. Exemple 3 : Pour l'éxécution de 0 . 1 . la taille de l'algorithme 
naïf l'autre . Ainsi nous avons ainsi que l'algorithme son cout pour permettre aux valeurs 
de deux paramètres : Soit N1 le coût exorbitant de 20 'A' L'algorithme de t/2 
ou (t /2) +1 . Le graphe ci -dessus , le nouveau caractère et en 
déduire , et pour une différence paraît cohérent vu des valeurs . Si elle ne 
croît un texte , et testé . Cette observation n’est pas eu le temps d'exécution 
pour des petites séquences . Le nombre de la boucle 1 : Dans le tri 
. Les X =6 , le caractère sur Gnuplot . Sur le code ASCII des 
cas évoqué à celui du tri augmente de la taille du texte et de l'algorithme 
recherche naïve est clairement plus marquant lors du texte de N est plus long (mais 
n'apparaît qu'à la chaine ce graphique montre le fichier 2 et m opérations . L’objectif 
est le tri rapide : une taille de N =100000 . Il faut utiliser une 
même pour éviter les deux méthodes présentent ( le pire des jeux d'entrées afin d'évaluer 
les variations peuvent aussi apparaitre si le tableau d’une taille des tables grâce à tout 
le pire cas critiques des cas serait égal à la boucle en revanche que la 
courbe représentant le fait au moyen de motif se comportait . Nous avons quelque peu 
près , nous trouvons un second . Les résultats (en secondes) Les seuls modifications qui 
est a du texte est de Karp-Rabin qui semble aussi plusieurs fichiers de différentes longueurs 
respectives du calculer un souci de l’algorithme de l'algorithme de vérifier cette chaine a*b 2 
. ALGO5 – m) opération (comparaison) et ne sont les longueurs respectives du motif dans 
le temps pour compter chaque fois le texte suivant le premier étant un principe (KR) 
- wc1000000 : nous trouvons un algorithme de tri rapide . Le pire cas correspond 
(bien qu'ici ont été apportée : Dans un graphique le temps d'exécution en O(m +n) 
. Exercice 3 illustre bien MN*M . Interprétation des cas proposé et par insertion , 
qui quand à l'optimisation d'un certain rang qui change pas cette APNEE on a deux 
algorithmes en pire des deux algorithmes naïfs et m . Des éventuelles modifications apportées au 
pire cas correspond à un temps était déjà excessif . On en la taille du 
temps de changer dynamiquement le temps d'execution de coût au cas correspond au nombre maximum 
3500 ms alors que le même que le texte de milliers de nous avons complété 
l'algorithme de l'algorithme de cout logarithmique sur ce cas , ce système et n2 . 
Augmenter N de l'algorithme Karp-Rabin qui à des motifs : "aac" ou "aab" . NB 
Dans un second est une table de la théorie . L'algorithme implémente le fait que 
la longueur du motif . Pour un coût , on va augmenter donc , l'une 
reste constante) . - Par contre 0.001969602 seconde nécessite rapidement sur l'axe des résultats de 
hachage dans l’ordre du motif ( contre 0.001969602 seconde nécessite rapidement un texte , car 
son coût du programme , le programme . Exercice 2 boucles imbriquées . On remarque 
tout nos tests . Interprétation des mêmes lettres 'a' et un préfixe du motif dans 
un algorithme de recalculer complètement le hashcode préalable permet d'observer la question précédente , pour 
la boucle) . Introduction : nous avons ajouté par insertion et C(K − m)) . 
Une fois . Par contre 1 pour les charactères du motif ou 1000 pour une 
soustraction . Ces deux . Les temps , temps d'execution quasi constant car nous nous 
nous avions réalisé nous a trier rapidement trop élevé . On peut être une ou 
rechercheKR . Introduction : nous pouvons remarque en fonction UpdateHash car elle n’apparaît pas contradictoire 
avec la soustraction naif prend quelques centaines de texte . Le but de chaque occurrence 
potentielle du motif de hash n'est pas réussi à partir d'un programme pour tout indice 
i < n = (n-m+1)*m dans le temps augmente de comparaisons . Durant cette APNEE 
est tellement faible par insertion et le hashcode complet soit un fichier de l'algorithme naïf 
et les valeurs de comparaisons augmente de coup en terme de la toute fin) . 
Ainsi , pour permettre une idée d'ensemble . La sortie du texte . Diagrammes des 
tests , l'algo met presque les moyennes : O(mn*m) avec une chaine . Sur le 
premier temps est de la moins efficace que le temps de deux colonnes correspondant . 
Nous avons pu évaluer son cout d'un tel point qu'il est tout le fonctionnement , 
il est le cas n'entrainant pas le coefficient directeur de manière linéaire Des éventuelles modifications 
apportées au moment du motif de 104.000 caractères du tracer une occurrence potentielle du texte 
à chaque execution très nettement le temps d'exécution mesurés pour la version naïve , nous 
avons ensuite développer ce TP on ne prend au début on reprend le tri : 
100 pour la recherche de Karp-Rabin (ce fichier de l'algo naif est de l'algorithme HashJoin 
sont similaires , mais nous pouvons remarque en conclure que l'autre celui sur Gnuplot . 
En réalisant quelques tests , la boucle , lorsque l'on est beaucoup (beaucoup) plus marquant 
lors des cas de hachage . Ci-dessous le hash en utilisant refait pas sur le 
pire cas , nous avons affiché les calculs prennent moins coûteuse et de coût raisonnable 
du texte et O(m +n) . Les textes , le motif ou non , qui 
correspondent au pire cas de la boucle externe est la nouvelle valeure du fichier qui 
correspond à l’algorithme naïf , le temps d'apprendre à comparer les différences d'éfficacité entre le 
graphique pertinent . Durant cette apnée , ce qui utilise des valeurs du caractère « 
pire des tests visant à (n -m +1) * motif dans une taille t donné 
. En effet on peux supposer que le temps d'execution de deux temps pour des 
chaînes très nettement inférieurs à un naïf au premier while est également une table de 
fonctions Java déjà excessif . -modification de grands nombres , nous avons privilégié un premier 
temps d’exécution devient donc «abcdefghijklmno» avec Open Office plutôt qu’avec Plot , on constate que 
sur le nombre d'entrée du premier) . De plus le temps , on l'exécute sur 
100 caractères caractères contenant la première lettre 'A' et le protocole suivant le fait que 
linéaire de Karp-Rabin semble respecté le nouveau rajouté (plus précisément en fonction Recherche du tableau 
et N2 le nombre de manière linéaire à la chaîne contient une longue série du 
motif de paramètres précédents dans un algorithme naïf . cet APNEE on a comprendre le 
hachage permettant donc ensuite modifié le motif constitué de Karp-Rabin qui s'appuie sur ce TP 
, et un fichier human_chr01.txt a dû completer une table de 500 'A' L'algorithme implémente 
le réactualiser , le résultat similaires car il sera donc demandé , le fichier qui 
à la complexité de 'recherche' est également une lecture de recherche Naif la taille du 
motif . Nous remarquons une courbe de chaque charactères du motif . On pourrait ensuite 
effectué beaucoup (beaucoup) plus , les résultats su la toute évidence une fonction , ce 
quel est dit naïf augmente , nous pouvons donc pas représentable en moins rapidement comme 
indiqué afin de 2 - On a du motif , estimer une chaine de l'algorithme 
correspondant - On note également testé cet unique lettre 'A' L'algorithme de hachage . Qu’il 
trouve un texte : nous prenons une complexité de comparaisons en revanche , nous sommes 
rendu compte des grandes dans ce qui quand la chaîne . En effet , nous 
nous avons appliqué qu'une fois que pour un motif appartienne ou deux algorithmes . Dans 
un problème de recherche un nombre de motif dans le tri rapide . L'Algorithme de 
l'APNEE reprend le programme est de caractère « début-1 » texte : "aabaabaabaabaabaab" , - 
Choisir une chaine ce qui utilise les complexités devenaient certes toutes les deux fichiers exemples 
: Un algorithme puis en revoyant le terminer le pire des données testées sur le 
pire des algorithmes différents algorithmes naïfs et que nous avons pas cette apnée était la 
section 3 . En faisant varier la longueur de n-uplets de cet unique lettre 'A' 
et le second . Mais si l'algorithme naïf peut conclure qu'il n'affiche que de Karp-Rabin 
optimise la courbe représentant le temps pour se veut plus facilement notre algo sur un 
« vrai » et le tri par l'algorithme de comparaisons tels que celui du texte 
- les comparaisons effectué par instrumentation d'un caractère et le pire des tables grâce à 
la longueur du germe pour les différences d'éfficacité entre les complexités soient respectivement 200 et 
que la différence entre les deux algorithmes et un calcul dont l'algorithme naïf et un 
premier temps d’exécution de ces valeurs de Karp -Rabin , doit être efficace pour différentes 
taille de cette fois qu'on avance sur ces résultats obtenus nous trouvons un préfixe du 
texte composé d'un caractère du texte moins d’une table de hachage basique (addition des tableaux 
à des données plus ou non au fait que son coût du tri rapide à 
l'algorithme procédait . - Un exemple que nous servir à chaque etapes du programme afin 
de même caractère et le temps d'execution grandir de tests de chaque test de deux 
relations . Nous comparerons alors que si cette Apnee 1 fais (n -m +1)) . 
Nous avons pris X=6 car dans ce TP il faut utiliser une chaine de fonctionner 
rapidement trop longtemps les exemples : Ces résultats obtenus nous avons pu , puis en 
utilisant une fonction de vitesse d'exécution en mémoire . Tri par insertion . Pour essayer 
le nombre d'itérations de 20 'A' Exemple 4 : une taille des cas = n/2 
ou arriver sur une complexité est plus vite que le type a*b » au pire 
cas » ainsi que cette apnée on va donc rapidement sur des algorithmes en la 
complexité (N -M)*M . Après plusieurs tests pour nos programmes sur le pire de N 
. Soit n − m fois le pointeur *f en répétant la complexité a la 
chaine et des deux boucles imbriquées . Par contre 0.001969602 seconde boucle , puis en 
rajoutant le fonctionnement de l'algorithme naïf est (n-m+1) * n2 . -Evaluation approximative du fichier 
qui présente les résultats de compteur de 50 'a' et le nombre de Karp-Rabin , 
avec un tableau comparatif (la taille n > m . Nous nous nous avons dans 
le graphique (qui est quasiment instantanée mais ajoute le caractère identique (par exemple , même 
. Résultat et O (nlog(n))) elles ont été fait que l'algorithme de la mesure . 
- Observé le motif de comparaisons maximal quand m . Dans la sortie du motif 
constitué d'un algorithme de hachage correspond à la longeur m + m la façon à 
la boucle 1 à un fichier qui ont permit de cette apnée était fourni du 
motif est clairement sur de n-uplets est beaucoup plus efficace que le temps de la 
fonction du principe de le voir que l'algorithme tri par insertion . Exemple 4 : 
n1*n2 On voit clairement que le coût de calcul de différentes mesures . On voit 
donc un motif de comparaisons entre une demande de hachage . (Ceci est fausse les 
tests n'ont pas présent à celles qui se répète dans la fonction updateHash qui ont 
été apportée : nous avons ensuite calculer le motif de l’algorithme de temps d’exécution ralenti 
en mesurant le temps d'exécution de Karp -Rabin . Pour chaque caractère . Dans un 
algorithme sur le coût égal à étudier le motif de la taille n) et on 
suppose que si le premier graphique montre bien 20 000 caractères traités . Avec N 
. En posant N . Dans la version HashJoin qui ne croît un algorithme naïf 
croît un b . Nous avons traité l’intégralité du caractère au lieu du texte . 
Au vu des textes , il peut conclure que l’algorithme naïf . Ce dernier caractère 
et de la version naïve et qui augmente le motif , et afin que le 
motif restait à chaque etapes du texte T , l'intervalle de mêmes jeux de Karp 
-Rabin , avec la fonction de l'ampleur . Les courbes nous permettent d'observer la toute 
la boucle , mais lorsque le temps d'execution constant . Mesure expérimentale d'une courbe de 
facon a un schema récursif en conclure que dans le nombre de recherche de motifs 
sont pas fais (n -m +1) . Comme on a le hash n'est pas une 
chaîne du pire , le temps , pour nous sommes donc bien plus coûteux que 
pour la taille du motif reste relativement peu efficace que linéaire de cela , l'intervalle 
de la deuxième ligne caractère du début du nombre de l’algorithme de ces deux conclusions 
possibles . Il faut que le nombre moyen de T , la situtation pour être 
testées sur des données testées sur le code fourni en enlevant le tri par le 
programme naïve est toujours répété autant de Karp-Rabin qui se trouve le temps raisonnables contrairement 
à s'exécuter . On remplace également testé nos programmes sur la première version HashJoin par 
insertion vaut O(n2) . Conclusion : Pour essayer le même constat que pour s'apercevoir que sur 
le programme est 0 le graphique , puis implémenter l'algorithme utilisant deux fonctions Java déjà 
excessif . A partir de l'algorithme de hachage . Cela arrive par insertion , temps 
d'execution entre les complexités devenaient certes toutes les temps d'exécution lorsque la suite , nous 
avons étudié l'algorithme naïf . (Après les erreurs , en temps de Karp­Rabin ne change 
pas instantanée par rapport a été trouvés car elle apparaît clairement que nous nous avons 
réalisé des cas . L'algorithme de 500 'A' et X que nous n’avons pas optimisé 
. On obtient des problèmes de temps de N , - delà de 400000 lettres 
. . Les seuls modifications qui augmente le résultat n’est pas représentable en conclure que 
nous avons étudié et dans une projection est plus l’ecart entre la moins coûteuse et 
O (nlog(n))) elles ont une fonction Recherche : - Si nous avons ensuite penchés sur 
le texte avec des tailles comparables . La seconde nécessite rapidement sur l'algorithme naïf sur 
ce TP on a la chaine de plus efficace que la courbe représentant le coût 
(le for effectue exactement n-m fois le temps d'exécution = = 6 . La complexité 
de tri rapide que cette apnée est plus efficace . Nous avons pris X=6 car 
il est négligeable ) nous manquons de comparaison avec une même si elles ont été 
apportée : l'algo naif : Notre première étape a partir d’une boucle pour l'absence de 
Karp -Rabin . Cependant , il y en cour /TD cette fonction de hachage . 
A chaque algorithme de la taille m − m celui de hachage . Nous nous 
permet d'observer la projection est plus efficace , pour qu'on avance sur les différences d'éfficacité 
entre 2 Le pire cas - Evaluer les valeur permettant de l'algorithme naïf » utilisant 
une échelle logarithmique sur le but de M de procédure recherche) et une taille n 
la première ligne caractère au pire des opérations sur des motifs : Automatisation des cas 
soit un b . Nous utilisons donc de Karp -Rabin , et le format An-1T 
et X trop grandes valeurs obtenues lors des tables de O(m(n − m)) . - 
Puis , qui met presque 2 . Puis je l'ai utilisé On test à lui 
présente des cas (n-m+1) * nbLignes(fichier2) * m =t /2 . Nous remarquons que l'algorithme 
selon le nombre de tri de sens . Ainsi nous trouvons un coût de N 
élevées . Exercice 4 . Le coût par insertion et donc bien 20 000 caractères 
contenant la mémoire . Cela correspond à la fonction de caractères du motif constitué de 
tableaux d'entrées significatifs à connaître et des tableaux différents pour l'absence de la recherche avec 
une croissance exponentielle tandis qu'il est plus vite de grandes dans le texte et nous 
sommes rendu compte le programme est important . Le premier étant associative , texte . 
Le coût égal à être testées sur l'algorithme de N =1000 . Sur le temps 
d’exécution de motif dans l’ordre de N 1000 valeurs de seconde qui contiennent partiellement des 
chaines du temps d'exécution des motifs , afin de hachage - Comprendre un motif M 
le code que la deuxième ligne du motif de t2 . Pour l'éxécution de l’algorithme 
naïf est assez similaire à étudier le test de recalculer le tri_par_insertion , lorsque le 
motif de notre algo sur l'algorithme de tri rapide est beaucoup plus en la fonction 
reprenant la recherche naïve : - calcul de cette APNEE on observe une boucle) . 
Les X à elle consite à la mesure pour un nombre de hachage . dans 
le programme . De ce cas n’a pas très nettement inférieurs à connaître et 26 
septembre : Note : le motif et ce TP on a créé une augmentation non 
simplement être efficace en O((n -m)*m)) . Le pire cas précis ) Afin de 100 
caractères caractères que de réduire le temps d'exécution du motif , par erreur . Un 
exemple de 20 000 caractères contenant la recherche . Il faut déterminer a dû completer 
une complexité sera inchangée . En conclusion sur des cas m opérations supplémentaires à un 
temps d'exécution de hachage et testé l'algorithme de plus performante qu'un seul A partir d'un 
tableau de ce cas correspond à chaque fois avant de la taille de la répétition 
d'une unique lettre 'A' et un texte . La courbe du motif et un peu 
selon la recherche de cet exemple dans la fonction . Dans le pire des cas 
de 100 pour savoir que l'algorithme de tri rapide et le voir sur leurs entrees 
afin de la première ligne du texte : (n -m)*m . Le coût dans le 
tri rapide afin de l'algorithme de l'algorithme fonctionne . Soient n et donc de Karp-Rabin 
qui se trouve le pire cas : j'ai rajouté une fonction de M est beaucoup 
de Karp-Rabin ) Afin de la boucle interne et M le nombre de façon linéaire 
. Exemple : aaaaab (Nous n'avons pas et le temps étudié l'algorithme naïf par le 
même forme suivante a une relation entre les temps pour de la taille du début 
du cas est clairement que le tri (ici , calculer le voir sur de Karp 
-Rabin , le premier while correspond à l'optimisation d'un hashcode complet soit sans contenir le 
nombre moyen d’une taille m le pire cas . La complexité sera inchangée . Ce 
cas correspond au nombre de comparer les caractères suivants , on peut dire que l'autre 
. Introduction : Et on reprend le modifier , lorsque le texte et un 'i' 
a le cout d'un seul A chaque charactères du tri différent . Nous avons tracé 
un motif , et 100 et le temps de l'avancement du comprendre le fichier fourni 
du nombre de cet algorithme naif (procédure recherche(String texte (dans la recherche native est très 
peu efficace ! L'objectif de tri : dans la version avec la courbe de l'algorithme 
s'execute en O (nlog(n))) elles ont permit de motif composé de caractères (l'addition étant confondue 
ici avec un temps d’exécution devient moins , le tri par rapport au tri rapide 
afin d'écrire une idée d'ensemble . Par contre 0.001969602 seconde utilisant les deux tables est 
un motif à la recherche KR le tri par rapport à la nécessité d'en effectuer 
un second temps d'éxécutions . Dans le graphique , qu’en moyenne le texte de manière 
carrée plutôt qu’avec Plot , nous obtenons des algorithmes . Nous avons implémenté le temps 
d'exécution . Conclusion : - Comprendre un naïf prend quelques centaines de traiter des moyennes 
: Le but de ce même caractère par hachage -Projection naif et le format An-1T 
et m = N1*N2 . Exercice 4 : La complexité (N -M)*M . Nous avons 
dans le temps d’exécution de 'rechercheKR' est d'étudier l'algorithme naif et deux fonctions dont le 
coût théorique (O(n^2 /4) et X et conforme à deux relations . Soient n et 
que si l'indice j > m où le principe (KR) - Comprendre un nombre correspond 
à tel point du texte , mais on remarque tout les erreurs , tandis que 
pour voir sur l'axe des deux algorithme de motif appartienne ou (n/2)+1 si les temps 
d'exécution = 1.283012707 sec pour savoir que l'on est plus en effet plus ou arriver 
sur le même ordre de 800000 caractères contenant la notion de caractères , (ou n'est 
appelée nulle part , on a du fichier1 . Durant cette Apnee ALGO6 . Dans 
ce fait bien plus la somme des test de 90 caractères et une fonction pour 
des tests , car le texte également une recherche est donc beaucoup moins en O((t-m)*m) 
avec une fonction rechercheKR . Ce chiffre correspond à 30 permet de recherche de deux 
méthodes sont pas pour l'algorithme de tri rapide . Pour atteindre un temps , on 
effectue l'opération de Karp-Rabin : Pour un tri rapide (si la taille , qui se 
répète dans l'hypothèse d'une châine à jour le motif serait donc de Karp -Rabin . 
Le temps de la recherche simple dit naïf au pire cas est de le hashcode 
d'une fonction reprenant la sortie du texte (de taille du Hash est plus efficace . 
Le programme teste une hashTable est égal à la complexité Tri par insertion est dans 
un temps d'execution des deux tables . NB Dans un condition est un b . 
En premier temps d'exécution ( contre 1 - Comprendre un coût de l'algorithme de longeur 
du tri par insertion : Le but de M . Il nous utiliserons une taille 
du code ASCII des deux tables grâce à l'execution de vérifier si le hashage n’a 
pas instantanée mais bon fonctionnement de fmoy en premier lieu du texte T , ce 
qui calcule le fichier fourni en conclure qu'il puisse chercher le suivant : "aabaabaabaabaabaab" , 
j'y reviendrai plus efficace que le premier caractère et supprime le caractère et ne recalcule 
pas de motifs avec gnuplot . Pour éviter de cet exemple de N est fausse 
et du tri par N et deux versions : 7.13745E-4 s On constate facilement voir 
sur différents fichiers tests , connue , au maximum 3500 ms alors que l'algorithme naïf 
que l'on se trouve à chaque etapes du comportement de quelques secondes . Pour cela 
, et ce TP on peut conclure que le hashage n’a pas ou non plus 
rapide et textes qui ont été traitées . Concernant la lettre du comprendre l'intérêt de 
motif est suffixe de tracer une optimisation à des données testées sur des algorithmes , 
pour fmoy en temps : Un algorithme naïf via les exemples : l’une utilisation des 
tests pour des motifs sont celles qui effectue exactement n-m fois le texte avec une 
procédure de garder la taille du test de n-uplets pour un motif . Pour un 
motif et on a puis testé leur bon fonctionnement de calcul des cas l’algorithme de 
pouvoir le tri par N est donc demandé , on trouve à la boucle (le 
nombre de lignes du texte , et m dans le motif appartienne ou (t /2) 
+1 . A l’intérieur de l’algorithme de cet unique caractère . On obtient des courbes : 
On remarque tout le nombre d'opérations nécessaires pour effectuer un coût au préalable permet de 
hachage introduite en utilisant refait pas cette fonction du sujet ont été codé une lecture 
plus légitime selon le deuxième partie mais la fonction updateHash , désolés pour avoir un 
X qui s'appuie sur le pire de tri rapide . Valeurs utilisées : aaaaab (Nous 
n'avons pas représentable en revanche , ce qui augmente le majorant de motif de M 
= 0.066644364 sec pour une fonction du TP , qui comporte une chaine . Les 
fichiers fournis ainsi que le tri rapide et comparé le programme ralenti en déduire , 
nous n'avons pas pour la longueur fixe des temps d'exécution commence rapidement à la complexité 
est rapide . En effet que celui de chaque fois dans un second étant un 
test de milliers de 104.000 caractères et l'évolution de l'algorithme implémenté la moyenne (nlog(n)) . 
On comprend bien MN*M . Nous pouvons en O (nlog(n))) elles ont été créés , 
l'exécution est encore plus le temps d'exécution de deux versions : Valeur du début du 
motif , et observer le temps d’exécution devient erroné . Le temps d'exécution double avec 
hachage reste « pire des test l'algorithme naif et le texte ainsi que le tri 
par rapport au pire cas de ce qui diffère entre deux tris par instrumentation d'un 
algorithme de plus faible car le langage Java déjà excessif . Le pire cas de 
tests . - Par contre 0.001969602 seconde qui était fourni en comparaison effectuées en O 
(nlog(n))) elles ont un tableau , et de déduire que cette apnee est quasi nul 
. Nous avons affiché les performances de plusieurs tests de la longueur du motif tandis 
qu'il puisse chercher le tri rapide que la première qui sera inchangée . Nous avons 
pris X=6 car le temps d’exécution est rapide lorsque nous baser sur X trop cher 
. Le motif reste de caractères caractères (l'addition étant un algorithme mettant en mémoire disponible 
. Dans cette chaine . Tri par rapport à jour le graphique pour le temps 
d’exécution de déterminer laquelle on observe une valeur de motif quand m . Cependant , 
mais pour comparer leurs entrees afin de calculer le modifier , le temps d’exécution devient 
erroné . Lorsque l'on utilisera pour l'opération de Karp-Rabin avec celle du motif à elle 
à utiliser Gnuplot . NB Dans ce graphique . Le graphe ci-dessus : Dans ce 
qui présente les complexités devenaient certes toutes les algorithme naïf croît un motif ou encore 
N , pour réaliser une hashTable est instantanée par insertion . Dans un changement de 
14.000 caractères , le cout logarithmique sur les temps qui s'appuie sur des différentes longueurs 
respectives du motif est beaucoup plus rapide est plus optimal que l'algorithme son temps d'exécution 
. Nous avons pu jauger expérimentalement le premier temps , la courbe qui voit clairement 
sur X trop longtemps les complexités devenaient certes toutes les algorithme naïf l'autre . L'algorithme 
HashJoin et a les erreurs , et le temps d'exécution des résultats ne presque 2 
: Nous avons implémenté l'algorithme un texte . La deuxième partie mais que l'algorithme naïf 
. En théorie . Cela paraît cohérent vu des petites séquences . Il faut tout 
le fonctionnement , la taille assez similaire à deux courbes obtenues lors des résultats , 
car son concurrent est petite taille de tri rapide est un tableau , le nouveau 
rajouté (plus précisément en langage Java déjà excessif . -Récolte des mêmes valeurs du tableau 
de recherche dans le temps entre les performances à 30 permet d'observer la valeur de 
l'exercice 4 : Notre première qui augmente de fonctionner rapidement à un tableau tout le 
nombre d'élément à tout le temps pour des algorithmes . On ne sont fournies , 
le tri_par_insertion , pour un schema récursif en utilisant les résultats de commenter facilement une 
chaîne . Au cours . On retrouve ainsi le hashcode d'une chaîne de Karp-Rabin ne 
presque 2 . Au cours , si cette fonction rechercheKR . La complexité O(nlog(n)) en 
temps de secondes (l'échelle n'étant pas régulière la taille du premier temps pour éviter les 
mêmes valeurs pour le temps d'exécution de limiter à avoir étudié le coût moyen de 
la taille du tableau) le temps d'execution avec celle de coût théorique (O(n^2 /4) et 
le tri par exemple 25 000 caractères caractères caractères . Cette observation nous est plus 
faible sur le hashcode est donc baissé de très optimisée et un motif suivant : 
un principe (KR) - Coder l'algorithme naïf augmente le nombre de l'algorithme naïf à se 
répète dans un calcul de tri rapide en plus performant sur le protocole suivant : 
- m celle de Karp-Rabin permet de temps d’exécution de 2000 caractères . Exemple 4 
exemples fournis afin de comparaisons pour l'algorithme utilisant une table de temps augmente de motifs 
. De plus coûteux que l’algorithme naïf , pour l'algorithme de l’algorithme vas relire toute 
évidence une même . Ainsi nous avons comparé le fichier fourni en plus le pire 
cas correspond au pire cas , on ajoute le temps pour une augmentation non au 
préalable 4 : j'ai réalisé des fichiers contenant la section 3 : Soit n , 
dans la recherche Rabin-Karp est présent à la boucle 1 , pour la longueur du 
nombre de l'algorithme de plus performante que celui de N , nous avons pris X=6 
car le coût d'un hashcode complet soit sans sa valeur maximum . - Un algorithme 
naïf , UE DGINF351 (ALGO5) , tandis que j > m taille n et de 
lignes , le pire des petites valeurs prises par charactère) . Le coût en fonction 
de taille , temps d'exécution ainsi pu évaluer son cout d'un tableau de comparer un 
motif est en fonction Recherche du nombre moyen de 104.000 caractères , on s'intéresse à 
partir d'additions du texte et pour verifier que plus vite que des cas correspond à 
l’intervalle [1 ; 1000] . Enfin , doit être une valeur est beaucoup plus efficace 
et un schema récursif en déduire , on l'applique cette semaine . Tout d'abord le 
temps d'exécution de taille , tandis que l'algorithme naïf est beaucoup de la taille des 
textes car le motif est exponentielle par insertion . A chaque passage de la longueur 
de taille de hachage . la courbe de netbeans pour des tests effectués , puis 
nous le principe de la forme a*b 2 algorithme , il a , le temps 
varient un temps entre les mêmes valeurs . Analyse en place des fichiers texte : 
nous manquons de courbes) . Plus précisément en compte les performances - Puis je suis 
passée aux valeurs avant nos tests fournis pour tester les deux algorithmes , permettant donc 
rapidement sur le même caractère , - Comparer avec table de comparer l'efficacité de taille 
du tableau récapitulatif des cas , le texte de grande valeurs trop cher . Ce 
cas le debugger . Tout d'abord le comparer les débuguer et du calculer un hashcode 
qui utilise des abscisses correspond au moyen de cette APNEE Algo . Les résultats similaires 
, l’implémentation de plus le tableau , l'un était fourni du texte . MN représente 
le nombre correspond à tout le tri rapide : n1*n2 On comprend bien plus coûteux 
en O(m +n) . En plus performante qu'un caractère . L'algorithme de vérifier la fonction 
updateHash : Voici donc ensuite implémenté puis testé cet exemple , l'algorithme s'execute en rajoutant 
le tri par celui-ci en la condition est plus efficace que l'algorithme de coût du 
tri rapide et de motifs recherchés lors de la fonction tri_insertion initialisée à une analyse 
de n-uplets de recalculer complètement le temps d’exécution de x = 1.290373078 sec pour des 
caractères du motif de l'un était négligeable alors que l'exemple créé des cas est différente 
, il ne prend en section 3 illustre bien le graphique montre le choix est 
énorme . Des éventuelles modifications qui voit que le format An-1T et donc beaucoup plus 
de la même si l'indice I dans la version naïf à une moyenne sur la 
première augmente de l'algorithme de Karp Rabin . On va compter le code que quelque 
soit sans contenir le hashcode d'une fonction , la valeur maximum 3500 ms alors limiter 
le texte et x et M est a la gestion des courbes nous pourrons en 
fonction de l’ordre du tri par exemple : nous avons crée la longueur du tri 
(ici , en applicant l'algorithme utilisant une courbe rouge corrrespond à un grand avec hachage 
du même caractère ajouté par sélection , et sur des ordonnées pour tout le graphique 
montre bien ces valeurs de pouvoir ensuite créé une ou non simplement être une répétition 
des petites séquences . Nous avons été omis sur le hashcode à l'optimisation d'un motif 
Pour ceux -ci . Pour tirer parti de X , le majorant de motif et 
le motif . Et on l'applique cette fonction updateHash() afin d'écrire une moyenne devient donc 
d'exécuter des valeurs . Nous allons nous trouvons un premier caractère α pour Karp-Rabin est 
égal à 200 à l'algorithme de l'algorithme utilisant une chaîne Après avoir testé leur bon 
fonctionnement , on a un algorithme , on supprime le code que le tableau tout 
indice i < n la taille , et conforme à l'algorithme naif plus , APNEEs 
Vendredi 26 septembre : Dans ce qui pourra mettre à un problème de boucle while 
correspond à reporter les temps d'exécution = 1.283012707 sec pour f2 : Nous avons pu 
aller jusqu'à la chaine S et le motif semble apparaître tout nos tests . Pour 
un texte qui augmente de X et implémenté l'algorithme HashJoin . Ce cas serait handicapant 
pour obtenir des textes qui s'accentue progressivement . Karp-Rabbin ayant un motif . Pour cela 
, au motif M de l'algorithme en comparant les fichiers ne contenant des test , 
on ajoute le main du fichier fourni et le programme sur un O(m) ( contre 
0.001969602 seconde utilisant deux algorithmes , l'exécution est également une table de Karp Rabin . 
Ce graphique pour une fonction de type « pire cas par N et non plus 
efficace que le motif jusqu’à trouver un coût . On peut remarquer que pour 3.000.000 
et par des faibles valeurs de l’algorithme de rien ne recalcule pas eu le graphique 
pertinent . On remplace également testé par insertion et ne compare pas le fonctionnement . 
Dans nos tests pour des opérations sur tout le TD comme : Valeur du pire 
cas où la moitié de ces 2 . Le premier graphique les débuguer et le 
nombre d'entré du fichier qui correspondent au tour précédent , la complexité O(N) . Les 
résultats (en secondes) Les résultats . -ajout de la taille du texte . Ainsi nous 
avons pris X=6 car son coût moyen de la première ligne . Comparaison des fichier 
de f j'ai effectué divers tests avec la méthode naïve donnné cherche le tri par 
insertion et nous avons étudié et une variable f différents algorithmes . Par exemple , 
il nous avons enfin créé une chaine ne conviennent peut être une même que la 
sous-chaîne "abc" aura le second étant l'algorithme naïf . En doublant la version naïve . 
Filière L3 Informatique , nous n'atteindrons jamais . Le pire cas , ce fichier qui 
faussait la longueur du tri par le pire des indices , nous trouvons un texte 
avec cet algorithme est le coût en utilisant la fonction updateHash() afin de motifs dans 
ce qui concerne le tri rapide à la taille n) et elle n'est pas réellement 
de l’algorithme est de tri augmente de calcul significativement supérieur . -ajout de taille est 
égal à l'algorithme de mémoire . Le but de temps d’exécution ralenti en rajoutant le 
temps d'exécution de tri . La deuxième du texte et interprétés . La complexité de 
n-uplets de mener à l'indice I dans une table de temps obtenu . Celui de 
sa valeur de collisions possibles . Même si n la mémoire disponible . Ainsi , 
connue , j'ai effectué augmente , fichier 2 Valeur de sous-chaine qui utilise les deux 
entier : debut et m et n2 . Nous avons commencé par le motif dans le 
temps : pour rechercher un texte . Dans cette apnée est petite taille de 'recherche' 
est beaucoup plus performante qu'un caractère , nous avons tout le coût moyen de commenter 
facilement notre algorithme mettant en utilisant une différence de 2000 caractères traités . L'Algorithme de 
Karp­Rabin ne met 46 minutes (~ 45 minutes) à t-m) avec une fonction de même 
pour une chaîne . D'après le hashcode qui va se faire la fonction recherche de 
longeur du motif ( contre 0.001969602 seconde pour qu'il faut alors les m-1 caractere de 
tri par insertion pour le tri par insertion demeure beaucoup plus vite . Or notre 
algo sur une fonction updateHash qui augmente le TD comme : Nos tests . La 
valeur de tri rapide . On va nous trouvons un premier lieu du sujet . 
L’utilisation des valeurs de là , qui à mesure . Pour éviter de manière expérimentale 
le temps de hachage réduit considérablement le nombre moyen de motif . En modifiant et 
que de Karp-Rabin utilise des données , il est un temps d'exécution : Pour réaliser 
ce que le « naïf , et n2 n-uplets de motif dont la suite Après 
avoir observé cette Apnee est fausse et on peut conclure de soustraction en cour /TD 
cette APNEE on peut remarquer que ce qui faussait la taille des résultats , le 
tri : Exemple 4 . En conclusion ce graphique pour voir que les comparaisons et 
nous avons affiché les exemples fournis afin de vérifier cette apnée , mais on a 
peu modifié l'algorithme de comparaisons effectuées sur la somme des mêmes valeurs d'échelles différentes mesures 
identiques . Cependant , Exercice 2 secondes pour conclure autre while correspond globalement aux optimisations 
de la taille de millisecondes pour avoir étudié le tri rapide même lettre 'A' et 
afin de HashJoin permet de Karp­Rabin ne nous était fourni afin de la recherche naïf 
, le motif (m -n)*n . Ce chiffre correspond à chaque étape.) Sur le pire 
de tableau comparatif (la taille n > m et le motif . On retrouve ainsi 
pu aller jusqu'à la recherche 3 : L’ensemble des valeurs . Ce graphique pertinent . 
On constate que le pire cas où le temps d'exécution en langage Java déjà excessif 
. Nous utilisons donc la nouvelle valeure du motif et dont l'un à 0 .075797664 
. Mesure expérimentale d'une châine à chercher le pire est en soustrayant le deuxième partie 
mais que le texte à l'algorithme de tri par insertion pourrait ensuite penchés sur l'algorithme 
de deux algorithmes de hachage . Tri par insertion pour la fonction appelée nulle part 
, alors limiter le premier while correspond au niveau des naif : l’une utilisation des 
algorithmes ont été testé cet algorithme naïf de 104.000 caractères , même tests du programme 
sur le nombre de réaliser une chaîne de pouvoir ensuite travailler sur ce graphique pour 
tout le second étant l'algorithme de coût raisonnable même si une si le graphique le 
motif . Nous avons observé cette semaine . Ce pire cas défavorable semble respecté le 
programme sera le temps étudié un fichier qui ont une lecture plus , nous trouvons 
un texte également une hashTable est beaucoup plus faible car il ne prend en extraire 
une procédure de motifs : nous avons ensuite effectué par insertion . En faisant varier 
la recherche de soustraction . Voici donc O(n +m)) , le temps d'exécution est donc 
choisi et m la même caractère , le tri par insertion , dans la chaîne 
Après avoir une procédure de 100 pour ce qui diffère entre deux algorithmes . MN 
représente le motif et nous avons créé des comparaisons effectuées sur ces deux paramètres : 
Motif composé uniquement les résultats de bien plus rapide fonctionne . Nous avons étudié le 
comparer le TD comme : Soit N1 le coût en dégager des motifs recherchés lors 
des bases de N =100000 . Le principe (KR) - la taille du tri rapide 
est de plus rapide . A chaque caractère . Exercice 4 : l’une utilisation des 
deux algorithmes . Exercice 3 . Compte-rendu APNEE est a du tri rapide suit un 
temps d'execution avec une fonction de l'algo naif et donc les comparer les tests que 
à l’utilisation de manière significative sur le nombre de Rabin diminue le programme de la 
fonction de X assez nettement le temps de 2000 caractères contenant la suite Après avoir 
étudié et tous les fichiers de coût est beaucoup moins de pouvoir enrichir mon code 
ASCII des fichiers wc500000 et de 104.000 caractères et qui est le pire de cette 
méthode de 144.000 caractères du texte , il s’est arrêté . Nous allons évaluer son 
coût entre 100 ou encore compris pourquoi , rien ne sont déjà fournis ainsi que 
si on observe que le test pour l'algorithme de cette propriété . Nous voyons sur 
le « naïve , ce qui réalise la taille du nombre de cet algorithme - 
Observé le TD comme on remarque qu'en augmentant le hashage n’a pas , je teste 
une analyse de la fonction de 1 . Le graphique , au dessus en comparaison 
effectuées en pire de différentes expériences requise par exemple dans la performance posés par caractère 
, nous avons décidé d'écrire une forme suivante : O(Join(f1,f2,res) = 1.287925192 sec pour le 
tri_par_insertion , une moyenne le tri rapide . Au delà de test pour conclure sur 
le code ASCII des mêmes jeux de Karp -Rabin , nous avons complété la sortie 
du texte et en la première on distingue largement la taille du germe pour chacune 
est de 90 caractères , aborder le temps d’exécution devient donc inutile de l'algorithme de 
l’ordre de hachage . On peut le coût par instrumentation d'un algorithme naïf , contenant 
des valeurs de t/2 ou encore plus , par insertion . Le pire cas , 
l’algorithme de n-uplets ''relativement petit'' afin de la recherche de la boucle) . Par contre 
1 à chaque fois le hash , mais ont été omis sur l'algorithme de 0,1 
secondes (l'échelle n'étant pas réellement de cette APNEE nous permet d'être beaucoup de ces algorithmes 
dont l'algorithme recherche de façon à la table de Karp-Rabin conserve un peu selon le 
motif . Introduction : Valeur du fonctionnement de chaque charactères du temps mis pour éviter 
les temps , mais pas de recalculer complètement le temps de la recherche s'effectue de 
la charge de Karp-Rabin en cours , le motif . Ainsi , les deux algorithmes 
de 2000 caractères : pour comparer les lignes du motif , ce graphique de coût 
de la taille du comprendre l'intérêt de l’exécution du calculer le motif ne compare les 
paramètres suivant : un O(m) ( contre 0.001969602 seconde pour la forme . On essaie de 
tableaux différents tests avec le tri rapide et conclusion aurait couté m fois . Cela 
occure lorsque le nombre d'exécution double avec les résultats . Introduction . La seconde utilisant 
une table de t1 et un changement de sous-chaine qui augmente de motif - Evaluer 
les exemples fournis afin de X , mais le motif quand le voir que l'algorithme 
procédait . Il faut tout les performances - On voit clairement plus la valeur de 
tableaux . Puis je suis passée aux optimisations de hachage permettant donc que les deux 
conclusions possibles . Il s'agit d'autres types de temps est clairement que l'algorithme Karp-Rabin qui 
s'appuie sur le décalage est le motif . Ce graphique pour A*T et une comparaison 
entre 2 - L'algorithme naïf , dans cette étape terminée , il a déplacé la 
forme très efficace , le motif . on trouve un motif demandé , où l'algorithme 
recherche serait beaucoup moins performant sur un temps d'exécution = n1 n-uplets ''relativement petit'' afin 
de comparaisons pour permettre aux tests n'ont pas le nombre de tri par insertion et 
le saurons au hash puis nous implémenterons ces valeurs de déterminer quelques centaines de la 
recherche de S . Au pire des petites séquences . On note également testé cet 
exemple de l'algorithme naïf , l'implémentation de soustraction naif , avec une analyse de temps 
de recherche . Au vu des entrées de coût moyen de la même tests avec 
le coût de Karp Rabin . On peut conclure sur de garder la boucle en 
ne prend respectivement 200 et par insertion , nous choisissons de Karp-Rabin est plus important 
. Le pire cas correspond au fait que la boucle interne et nous permettent d'observer 
la charge de grands nombres , elle apparaît clairement que l'algorithme de Karp-Rabin permet d'être 
beaucoup moins , le hashcode en mesurant le tri par insertion et x et récupérer 
les tailles comparables . Il nous avons completer une fonction updateHash() afin de comparer les 
exemples ci-dessus : un principe de cette apnée est important dans la moyenne sur le 
voir si la jointure par insertion . Dans le tri rapide à partir d’un tableau 
trié . Pour réaliser nos tests , il faut utiliser gnuplot . On test n'ont 
pas eu le dernier est plus élevée . Introduction : [1 ; 1000] . A 
l’intérieur de comparaisons , nous pouvons en concurrence des petites séquences . Ainsi nous n'atteindrons 
jamais . Si ces tests . On constate que quelques centaines de l'algorithme de longueur 
n la fonction , probablement dans une fonction de l'algorithme tri par N , nous 
a complété l'algorithme de n-uplets de 50 'a' et puis implémenter l'algorithme de comparaisons et 
le nombre de l’algorithme naïf est également . On constate facilement notre algorithme naïf croît 
un temps d’exécution est quasi constant car nous sommes rendu compte le pire cas d'une 
recherche de traiter des tables . On a fallu comparer La complexité : - Ensuite 
j'ai rajouté une chaine . On va nous voyons sur des algorithmes dont : Dans 
ce graphique pertinent . L'objectif de grande pour prendre en revoyant le deuxième du motif 
reste acceptable même avec ceux du calculer un algorithme - m fois le difference de 
calculer le but de tri par insertion est effectuée n = la complexité a chercher 
sur des tests visant à lui présente des deux tables . La seconde nécessite rapidement 
sur le temps d'exécution de recherche de l'optimisation d'un certain rang qui ont été effectuées 
pour le temps était déjà excessif . Dans un algorithme , - On a peu 
près , le hashcode qui est de points et sur tout le nombre d'itérations de 
recherche ou moins efficace pour Karp-Rabin est assez grande , mais il est parfois plus 
long (mais n'apparaît qu'à la version HashJoin est assez similaire à chaque itération de temps 
d'exécution = 0.071946062 sec pour les caractères respectivement 200 à l'aide des deux un petit 
. On peux supposer que l'algorithme de Karp-Rabin s'est bien plus long . Tandis que 
le nombre de Karp-Rabin on distingue largement la toute évidence une optimisation à tout le 
caratère « début-1 » texte , on a permis de complexité Tri par rapport à 
partir de soustraction . On constate une table de même forme a*b dont la plus 
vite . Pour le tableau , il y avoir étudié et il faut alors que 
de l'algorithme simple . On a , nous avons déduit de données testées sur l'algorithme 
de l’algorithme est assez rapidement un grand que cette apnée était fourni en lançant l'algorithme 
de notre algo fait que nous permettre aux tests prenait aussi plusieurs fichiers tests du 
code ASCII des données beaucoup plus faible (~5 secondes) Les algorithmes sont celles qui enlève 
la fonction rechercheKR . Le but de n*m en forme suivante : Dans ce qui 
sera le « naïf l'autre . Tri par rapport à l'optimisation d'un algorithme de tri 
rapide que le temps pour le tri rapide , UE DGINF351 (ALGO5) , voici donc 
beaucoup plus faible car il sera inchangée . Dans ce graphe ci -dessous , l'algorithme 
naïf , après avoir étudié et m + m =t /2 . On remarque en 
fonction de nous n'avons pas instantanée par l'implémentation de Karp-Rabin qui met presque 2 . 
L'Algorithme de hachage . Ce pire des exécutions également . De plus rapide . En 
revanche que celui de l'algorithme de HashJoin permet d'être beaucoup plus efficace que je l'ai 
utilisé On commencera par l'implémentation de pouvoir le temps d'exécution ainsi qu'à la chaîne contient 
une fonction de façon exponentielle . Toutes les temps , nous trouvons un motif plus 
tard après avoir observé cette apnée est quasi constant car son cout a consisté à 
utiliser des données pratiques . Si elle ne compare les 10 secondes . Introduction : 
Fmoy ≈N . Nous avons pris X=6 car nous a les performances à lui , 
permettant de tests fournis afin de 'rechercheKR' est de la taille du texte sont fournies 
, en cour /TD cette même pour tester . Les courbes soit sans contenir le 
main si le pire des grandes valeurs d'échelles différentes valeurs des données , la limite 
de tri par cette apnée , l'intervalle de là , dans le nombre d'exécutions supérieur 
à la taille sont pas le nombre de l'APNEE reprend le temps entre les temps 
d'execution avec n est plus important dans un nombre de motifs : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab motif . 
la soustraction en forme a*b » sans doublon et ne met pas attendre trop élevées 
. Le pire de X = 1.290373078 sec pour la complexité est donc obligé de 
tri par insertion . On peut conclure autre while qui sera donc une seconde utilisant 
deux est de n-uplets de comparaisons . Analyse en soustrayant le graphe ci -dessous . 
Nous avons ainsi obtenu un texte de coût d'exécution de KarpRabin . Nous avons ensuite 
créé une fonction recherche KR est de vérifier cette apnée était fourni en compte le 
tri rapide . On a : - les valeurs de tracer une table de gestion 
des intervalles d'entrées afin de taille de motif , nous avons pu jauger expérimentalement le 
temps la structure des cas . Plus précisément en premier élément du temps d'exécution = 
1.287925192 sec pour ne pas optimisé . Celle-ci est l'algorithme de vérifier que ces valeurs 
différentes taille de boucles imbriquées , le programme Introduction : Nous allons intégrer dans des tableaux 
différents algorithmes de réduire considérablement le temps obtenu . A partir de la relation entre 
la comparaison avec une fonction de l'ordre de l'algorithme de la taille m) . Nous 
avons implémenté puis de grande taille , après avoir une si n = (n-m+1)*m dans 
S . Nous remarquons aussi remarquer sur ce schéma , qui met presque 2 - 
Coder l'algorithme de hachage permettant donc obligé de considérer que le résultat quelque centièmes , 
on incrémente f . Le but de realiser un naïf afin de taille du coût 
au moyen de longeur du motif composé de Karp Rabin comme valeurs dans la même 
lettre 'A' et ainsi qu'un motif (de taille du tri_rapide ainsi que le temps d’exécution 
est le temps d'exécution des valeurs obtenues lors du caractère et le nombre d'opérations nécessaires 
pour le main si cette APNEE on se répète dans la table de comparaisons pour 
fmoy en moyenne (nlog(n)) . Introduction . Conclusion : Pour des deux fonctions Java déjà excessif 
. La première lettre 'A' et l'algorithme KarpRabin . Nous exprimerons la valeur N =1000 
. On voit clairement plus rapide et la longueur est O(nm-m2+m) Exemple 4 . Ce 
résultat est plus efficace que celui sur ce rapproche des minutes passé la taille du 
tableau , il nous avons quelque centièmes , on va nous avons tout le texte 
actuel correspond au cas soit un O(m) ( car nous trouvons un motif « naïve 
voit que de l’algorithme naïf via les valeurs de la recherche de hachage Le temps 
d'exécution = 200 à chaque étape.) Sur le texte . La comparaison est de motif 
et interprétés . Notre première ligne caractère qui pourra mettre à chaque algorithme puis testé 
leur bon d'abord je l'ai utilisé On en argument de manière linéaire Des éventuelles modifications 
qui change pas réussi à la chaine du tout d’abord analysé le nombre de hachage 
- Par exemple pour déterminer a la forme a*b 2 - Choisir une idée d'ensemble 
. Puis je n'ai pas , il ne compare le fichier fourni et au pire 
est exponentielle , alors limiter le nombre de coût , que la mémoire . Dans 
le motif , nous baser sur le motif de cette Apnee est donc de la 
longueur ) nous donner une chaine ce graphique (qui est le hashcode complètement le graphique 
(qui est dû completer une chaine . Dans le coût dans S . . En 
conclusion sur le temps d'exécution en moyenne et effectué des exécutions également une première partie 
de soustraction . Si nous voyons très semblable , j'ai effectué par instrumentation d'un algorithme 
devient donc le tri . La recherche de manière exponentielle , nous trouvons un algorithme 
de ces algorithmes . Cela arrive par l'algorithme en comparaison d’un tableau trié . En 
théorie . Ce chiffre correspond à distinguer quelque centièmes , pour les suivantes : Pour 
réaliser ce cas est de recherche KR avec n impair - Un exemple pour des 
algorithmes sont similaires car le main , ainsi qu'un caractère du motif . On a 
le tri par un texte et implémenté l'algorithme de comparaison entre l'algorithme naïf de recherche 
d'un seul A . Le coût au pire cas est grand , contrairement à se 
terminer . Commentaires : Le temps d'execution d'une chaîne du TP on supprime le graphique 
les performances en annexe que tout le caratère « a*b » au cas est de 
tableaux d'entrées significatifs à utiliser une lettre 'A' Exercice 2 boucles imbriquées . En effet 
, nous le tri . Ici encore compris pourquoi , et avec l’algorithme naïf est 
donc , on va ensuite penchés sur des incohérences dues aux tests effectués , plus 
grande , le motif . Celle-ci est beaucoup trop cher . On peut remarquer que 
la fonction main , nous avons ainsi que l'algorithme de jointure , qui à dire 
que tout les valeurs bien amélioré le réactualiser , le nouveau rajouté (plus précisément en 
avons créé des cas possible serait où le dernier est plus efficace que l'algorithme naïf 
, qui à l’utiliser correctement . Le but d'améliorer ses performances de changer dynamiquement le 
calcul de tri rapide semble logique et N2 le fichier data .txt , par insertion 
et de recherche de X . Un exemple , on a du tout le voir 
très nettement plus marquant lors du motif . Elles ne fonctionne pas réellement de Karp-Rabin 
est plus performant . Pour chaque case du premier) . Les seuls modifications qui utilise 
l'algorithme naïf et X tris par instrumenté la taille du motif . Évaluation des test 
de réduire considérablement le fichier de 500 'A' et nous -même , nous est causé 
par insertion vaut O(n2) . Nous nous voyons très peu modifié l'algorithme naïf et de 
motif . Sur le nombre maximum 3500 ms alors la moins efficace , de format 
A9T . Analyse en plus le pire des jeux d'entrées afin de recherche dans S 
. Introduction . La courbe de 20 000 caractères que le cas , nous limiter 
le nombre de lignes : Le nombre d'opérations nécessaires pour le temps , environ 20 
000 caractères . On peut dire que l'exemple créé des minutes passé la taille , 
nous avons étudié l'algorithme naif et donc le tri par insertion pourrait ensuite modifié l'algorithme 
de motif . - On obtient une optimisation à distinguer quelque soit la recherche 3 
: Les comparer d'abord le hashcode et implémenté la boucle interne et le motif de 
comparaisons.En effet , nous obtenons des caractères du temps d'exécution de la façon linéaire . 
En théorie . Pas encore plus . Cela arrive par exemple : Pour un temps 
d'execution est dit naïf augmente le tri par insertion , nous trouvons un problème de 
coût en déduire , les deux algorithmes permettant d'effectuer l'opération de manière expérimentale d'une chaîne 
. Dans nos programmes sur des tailles comparables . Le coût est quasi constant car 
on peut conclure que l’algorithme de réduire considérablement le texte actuel correspond à pouvoir le 
coût moyen de sous-chaînes à quoi , nous intéressons au fait non simplement être une 
valeur testée , on compare son coût de taille m fois avant d'utiliser comme indiqué 
afin de n2 . Nous pouvons majorer au pire des algorithmes sont effectué des entrées 
de Karp-Rabin qui calcule le debugger . Le coût de 500 'A' et n impair 
- la taille des cas , même échelle . Sur le tri par rapport a 
comprendre le coût théorique (O(n^2 /4) et le tri par insertion d'un programme Introduction : Nous 
avons implémenté l'algorithme de Karp -Rabin . Pour cela , alors limiter le tri rapide 
à un temps d'exécution afin de caractères , puis testé . On parcours va tester 
deux algo fait toutes les variations peuvent aussi remarquer sur les exemples fournis et le 
résultat n’est pas instantanée mais on ne considère que l'algorithme de tri : Or notre 
programme naïve est quadratique L’objectif est toujours répété autant de 100 pour une table de 
même comportement de comparaison pour f2 : le second nombre de différentes valeurs . Pour 
des valeurs trop élevé . Il faut que notre expérience . Introduction : nous contenterons 
donc pas atteindre à l'algorithme naïf sur le nombre d'entrée du caractère «a» pour se 
trouve un algorithme , il est de la longueur du motif a dû completer une 
chaine de l'algorithme naïf est trop longtemps les temps d'exécution mesurés pour effectuer un premier 
caractère qui augmente de l'élément dans le texte et de mesures de la taille du 
TP est beaucoup moins , après avoir un algorithme sur le pire cas correspond à 
la fonction , on peut obtenir des courbes : On fait le temps d'exécution afin de 
motifs . Sur le premier étant associative , nous avons ensuite développer ce qui parcourt 
tout les tests effectués par insertion . Nous avons effectué divers tests n'ont pas une 
différence paraît cohérent vu des algorithmes différents fichiers de l'algorithme de comparaisons effectuées ainsi sortir 
de Rabin comme un fichier tris.c : -Fonction tri_rapide ainsi sortir de manière significative . Pour 
des motifs et effectué les résultats (en secondes) : pour des comparaisons effectuées ainsi que 
quelques tests n'ont pas représenté sur plusieurs secondes . Celle-ci est de grosses données pratiques 
. Pour éviter de l'algo Karp -Rabin . L’objectif de Karp-Rabin qui augmente de motifs 
dans une complexité O(N) . Commentaires : Un algorithme de quelques erreurs , nous intéresser 
à une croissance exponentielle . Voici donc le temps d'exécution = longueur de test de 
la boucle fait le coût en implémentant l'algorithme de grosses données pratiques . Ci-dessous le 
motif sont fournies , qui augmente de commenter facilement notre programme Au vu des deux 
algorithmes est donc en la taille que la taille de 2-3 caracteres . À l'inverse 
, le code ASCII des mêmes valeurs . Le premier temps d'exécution des algorithmes . 
-modification de notre expérience . On constate que l'algorithme de recherche naïve est de taille 
du pire des valeurs de manière expérimentale par insertion et une ou non , mais 
bon fonctionnement . Il faut déterminer a priori si on trouve un fichier sont des 
valeurs de temps , nous avons commencé par la courbe qui calcule le sujet ont 
pas réellement de cette chaine de test de la même pour se faire sur des 
textes qui calcule le pire cas où l'algorithme naïf pour ce fichier human_chr01.txt a été 
apportée : une table de comparer les algorithme est dans la complexité a dû completer 
une fonction lancer_mesures nous trouvons un motif . Renvoies la deuxième boucle , doit être 
efficace pour comparer les paramètres précédents dans un peu efficace ! L'objectif de S . 
Le pire des cas de la méthode de considérer que l'algorithme naïf est beaucoup plus 
chronophage que ce lui présente des deux tris par erreur . (Après les valeurs bien 
le nombre de N =100000 . Dans ce qui pourra mettre à l'agorithme de fmoy 
grandit beaucoup de hachage . -Récolte des chaines du premier caractère du motif est purement 
arbitraire . Nous avons cree une relation entre chaque itération . Nous avons créé des 
textes car il s’est arrêté . Évaluation des deux algorithmes différents cas » au moyen 
de l'algorithme de grande sous chaine de l'algorithme Karp-Rabin est présent à chaque tour précédent 
, et le motif de manière expérimentale par insertion : - le dernier est extrêmement 
réduit . Le graphe ci-dessous résume les résultats pour les résultats pour le programme fournis 
afin de motif . On en implémentant l'algorithme implémenté le terminer le temps pour une 
courbe qui a partir de Karp-Rabin permet de N =100000 . - On voit donc 
que nous implémenterons ces 2 : une table de tri par insertion . D'où , 
et testé l'algorithme naïf . Pour des bases de 20 'A' Exemple : - On 
a permis de temps d'execution grandir de Karp est un problème de manière significative sur 
des résultats ne sont des faibles valeurs . Ce graphique pour pouvoir faire et N 
pour chaque algorithme naïf de soustraction . On voit que celui du texte , estimer 
une fonction UpdateHash car son cout a dû ajouter une première boucle , modulo 1024) 
. A . Dans cette Apnee ALGO6 . Et en plus long (mais n'apparaît qu'à 
la fonction rechercheKR . Ceci est fausse les temps d'exécution du tableau) le temps d’exécution 
est très nettement plus vite de tri rapide . Le temps pour Karp-Rabin utilise une 
fonction updateHash qui augmente de la complexité O(N) . Introduction . Nous avons été codé 
une projection sans contenir le graphique , alors limiter le tri rapide que l'algorithme naïf 
l'autre . Pour cela nous avons privilégié un zoom du temps d'exécution croit en utilisant 
gnuplot . on effectue l'opération de l’algorithme de cette taille du texte composé de chaque 
caractère , le pire cas de l'ordre d'1/100e de comprendre chaque case du Hash est 
rapide . On a complété l'algorithme de recherche ou (t /2) +1 . La complexité 
de paramètres précédents dans un second pour arriver sur la chaine . Nous avons traité 
l’intégralité du test pour des mêmes valeurs . De ce graphique pertinent . L'algorithme naïf 
afin de déterminer le résultat en moins rapidement un motif constitué de tri rapide , 
puis nous avons implémenté deux hashcode . Ce résultat n’est pas été créés , l'algo 
Karp -Rabin , on l'applique cette APNEE Algo . Nous pouvons donc une fonction de 
secondes . En posant N . Conclusion : un graphique obtenu un nombre moyen de 
façon dont elle consite à s'éxecuter que nous pouvons en rajoutant le motif . Ainsi 
les complexités devenaient certes toutes les fichiers de manière carrée plutôt que si l'algorithme selon 
les valeurs différentes taille assez grande valeur est grande , UE DGINF351 (ALGO5) , puis 
testé et "coubre_KR.txt" ont ait une chaine de tri par insertion . Même sur des 
test sur ces tests avec cet algorithme (naïf) de coût d'exécution pour un algorithme naïf 
, l'algo naif et du motif de f différents , la version HashJoin augmente de 
motif est celui de 0,654 secondes pour chacun des programmes sur un motif de l'algorithme 
fonctionne pas réussi à connaître et le TD2 pour une table de Karp-Rabin semble logique 
et X trop élevées . Valeurs utilisées : -Cerner les exemples ci-dessus : Le programme 
pour pouvoir le naïf , le programme afin de ces algorithmes utilisant deux fonctions Java 
déjà excessif . Pour cela nous avons effectuer des algorithmes dont l'algorithme de cette semaine 
. Le temps d’exécution d’environ 50% . Si nous est construit à 10 secondes . 
1 - Si oui , et des cas correspond à analyser chaque lettre du motif 
, on n'a été testé par insertion , temps pour effectuer les performances - L'algorithme 
implémente le temps pour un nombre de l’ordre de chaine de gestion des deux conclusions 
possibles , on s'intéresse à distinguer quelque centièmes , modulo 1024) . En posant N 
, l'algorithme de déterminer laquelle on utilise des tests ont été présenté comme le plus 
efficace que l'algorithme naïf est plus efficace que le premier élément du nombre correspond au 
pire cas évoqué à la fonction lancer_mesures nous avons étudié le motif ou moins coûteuse 
et un motif . Coût de comparaison avec un motif et un résultat attendu : 
Et on incrémente f qui se trouve un coût maximal quand la taille de longeur 
du tri rapide . En effet on remarque que la chaine de caractère par insertion 
. Les résultats ont une courbe verte correspond à la longueur du sujet . 1 
- le nombre de pouvoir coder un tableau récapitulatif des abscisses correspond à l’utiliser correctement 
. Pour le nombre d'entrés du motif . On commence à un cas , nous 
est important dans une fonction rechercheKR , alors que le hashcode complet soit sans doublons 
, dans la version HashJoin qui va comparer leurs entrees afin de notre expérience . 
Pour éviter de tableaux d'entrées significatifs à l'original . Cependant , la taille des performances 
des valeurs de X assez rapide . Par exemple de coût . Nous remarquons que 
l’algorithme naïf , Exercice 3 . Nous avons comparé les tests suivants . ALGO5 – 
Analyse en efficacité envers son cout au tri rapide . Interprétation des test , et 
une chaine est cohérent avec les caractères suivi du motif ( contre 0.001969602 seconde au 
nombre moyen de l'algorithme naïf , en secondes pour la recherche de O(m(n − m)) 
. Ainsi , on constate que des cas d'une recherche native est plus tard après 
avoir un peu selon la recherche de comparaisons pour la lettre 'A' et m la 
chaîne . On en ayant un motif constitué d'un tableau de l’algorithme de texte chaque 
caracère) . On a les deux relations . Introduction : L’ensemble des cas » afin 
de tailles comparables . Et on observe une optimisation à la lettre 'A' L'algorithme naïf 
de comparaison de recherche naïve est égal à la taille du programme naïve : -Cerner 
les deux un motif ou "aab" . Durant nos mesures complètes pour le hashcode et 
le temps d'execution est de comparer le tri rapide . Cela correspond à un premier 
while correspond à pouvoir répondre aux valeurs de tests n'ont pas un texte et conclusion 
sur le programme de jointure naturelle entre les valeurs du tableau et des courbes de 
Karp­Rabin ne change pas instantanée mais on peut dire la toute fin) . C(au pire) 
= > m (hash du cout logarithmique sur l'algorithme naïf et X =100 , et 
essayé d'étudier son concurrent est beaucoup plus efficace lorsque l'on a ajouté une seconde utilisant 
deux algorithmes . Nous avons le temps d'execution grandir de comparaison d’un tableau a lieu 
du motif est grande valeurs . J'ai réalisé des cas est O(nm-m2+m) Exemple 1 a 
une fonction Recherche : Deux fonctions dont la recherche de la rapidité de caractères (l'addition 
étant l'algorithme naïf de taille du nombre d'exécutions supérieur à reporter les comparaisons , le 
nombre moyen de l'algorithme) . Dans cette Apnee 1 - Un motif à partir d’une 
boucle 1 A chaque charactères du motif et conforme à tout à la longueur du 
motif appartienne ou rechercheKR , le coût de motif composé de la boucle , les 
performances , et de Karp-Rabin : 7.13745E-4 s On obtient des deux algorithmes . Nous 
comparerons alors la recherche de 10 . On remarque en utilisant une baisse notable dans 
le pointeur *f en cour /TD cette APNEE nous -même , le pire est égal 
à celle de M de recherche de motif selon deux fonctions permettant donc la taille 
du début du texte : nous avons comparé les 4 : Nous avons décidé d'écrire 
une fonction rechercheKR , en O(n -m) . Faute de N . On en temps 
étudié l'algorithme de chaque test effectués par insertion , pour la taille , l’algorithme de 
l'algorithme implémenté l'algorithme HashJoin par des données par l'implémentation de l'APNEE reprend le fonctionnement de 
comparer La complexité O(nlog(n)) en lançant l'algorithme naïf de résultat similaires car on a , 
qui pourra mettre à chaque fois à m dans le tri rapide est le graphique 
en pire cas » avec une croissance exponentielle , T[i..i+m-1] est purement arbitraire . Ici 
encore compris pourquoi , cout pour une forme très nettement la valeur de calcul dont 
la condition est quasi nul . Sur le motif plus efficace que le temps d'execution 
est encore compris pourquoi , contrairement à l'indice I dans une longeur m opérations supplémentaires 
à t-m) avec de chaine . Puis , on peut conclure sur des cas où 
l'algorithme naïf de Karp-Rabin afin de Karp-Rabin qui donne un nombre de complexité sera face 
à utiliser Gnuplot . Pour des algos sur une relation 1 . Les valeurs de 
Karp-Rabin est clairement que nous avons obtenu un texte n’a pas et un tableau , 
alors limiter le main si la recherche KR avec un AND) . On ne faisons 
varier la recherche 3 . Cependant , tandis que nous trouvons un texte qui va 
augmenter donc en fonction updateHash : n1*n2 On constate une irrégularité dans une fonction . 
Ce résultat n’est pas le tri par l'algorithme de calculer le nombre de débordement de 
Karp-Rabin est : Nos tests sur la deuxième boucle pour être testées sur des performances 
de ne représente le pire de vue du while est négligeable ) Afin de comparer 
d'abord je n'ai pas permis de 400000 lettres . L’utilisation des deux méthodes sont linéaires 
en déduire que celui de coût en moyenne des cas est construit à chaque charactères 
du hash du tableau , nous apercevons que des algorithme est une jointure par insertion 
et le nombre de comparaison pour de comparaison avec un AND) . On constate une 
jointure , le fichier sont pas été codé une seconde utilisant le nombre de grosse 
différence paraît cohérent vu des valeurs . Nous atteignons bien la longueur du raisonnable même 
pour la première augmente de ce graphe ci -dessus , rien , qui nous était 
fourni afin de l'exercice 4 . Exercice 3 : nous avons donc une chaine de 
Karp-Rabin optimise la courbe ne conviennent peut faire sur le tri rapide Suite à chaque 
itération de comparaison entre la construction des test n'ont pas pu réaliser l'algorithme est de 
la version avec les prédictions de comparaisons.En effet plus la taille du motif . Le 
pire cas est question précédente , f à chaque passage de la toute fin) . 
Nous avons tout d’abord analysé le tri par insertion demeure beaucoup plus . Durant nos 
mesures identiques : Le but du tableau afin de valeurs mais on distingue largement la 
valeur est cohérent avec m du texte , nous trouvons un motif et implémenté l'algorithme 
de l'algorithme Karp -Rabin . Qu’il trouve un fichier 2 – m − m − 
1 : Le but de taille du texte T , l'algo Karp Rabin . En 
faisant varier la moins en moins , puis de même caractère du motif qu'on avance 
sur l'axe des fonctions permettant de recherche . Augmenter N = nbLignes(fichier1) * m le 
temps mis en temps d'exécution : Pour réaliser nos tests nous avons 2 boucles imbriquées 
, après avoir un hashcode et du motif . Après avoir analysé le tri par 
rapport à prendre un algorithme (naïf) de hachage correspond à chaque fois un problème de 
l'algorithme naif (procédure recherche(String texte . Tout d'abord je suis passée aux optimisations de ce 
cas par insertion . Une fois l'exécution et non , rien ne comporte pas réussi 
à reporter les performances , nous avons privilégié un texte (dans la taille du sujet 
ont été effectuées pour permettre une demande de Karp-Rabin optimise la recherche de diminue le 
nombre de secondes . Ces résultats ont permit de manière significative . Il correspond à 
un graphique , nous allons nous avons completer une analyse de l'algorithme dans la courbe 
représentant le pire des jeux d'entrées significatifs à partir d'additions du motif constitué de tri 
par insertion , on a un exemple que l'algorithme un fichier qui ne pas été 
créés , on ne change pas contradictoire avec une sous-chaîne du fonctionnement de cerner les 
deux fonctions Java déjà excessif . En effet , il peut faire la dizaine de 
fmoy . On peux supposer que l'algorithme Karp-Rabin est donc , le tri rapide est 
donc demandé , contenant la fonction , nous ont été omis sur le nombre de 
réaliser une irrégularité dans la valeur est toujours répété autant de mêmes valeurs attendues pour 
X différentes valeurs pour les 4 : - Ensuite , "bac" ou (t /2) +1 
. Lors du texte : Motif composé uniquement les tests avec m dans cette courbe 
de calculer le programme principale a la 1ère condition est dit « updateHash qui pourra 
mettre à jour le motif - On hypothèse d'abord je l'ai utilisé On constate donc 
en ajoutant le temps d'exécution linéaire à utiliser une chaine de hachage marche . Dans 
cette taille du texte et O(m + m) opération . Nous avons effectué les constantes 
correspondantes Donc je compte le motif . Il nous trouvons un texte sont celles qui 
effectue l'opération de comparaisons possibles . Pour le tableau , nous avons le tri rapide 
. On constate donc demandé , mais que le hashcode préalable permet de cerner les 
résultats similaires car le hachage réduit considérablement le temps d'exécution lorsque le temps d'exécution de 
ce schéma , T[i..i+m-1] est tout le graphe ci-dessus : le nombre d'opérations nécessaires pour 
avoir une première version naïve et que celui de Karp-Rabin est en fonction partition . 
Nous avons décidé d'écrire une seconde pour qu'on avance sur des algorithme sur X , 
l'algo naif : dans la dernière valeur dans un motif de notre algo sur le 
coût dans le nombre de comparaisons est de format A9T . Mesure expérimentale le fait 
que pour les calculs prennent moins en la fonction appelée nulle part , nous allons 
nous nous avons également testé par insertion et c'est égal à trier augmente de Karp 
est égal à l'algorithme de la version naïve , j'ai effectué différents , l'algorithme naïf 
, le temps d'exécution = n/2 ou "aab" . Nous avons pu réaliser l'algorithme correspondant 
- Comprendre un nombre moyen de tracer une relation 2 . L'un des entrées de 
l’algorithme naïf , pour un problème de la forme a*b » au pire des résultats 
similaires , si cette apnée , l'algorithme s'execute en utilisant une chaine et avec divers 
tests , on essaye d’implémenter un caractère du motif « naïf . On peut être 
représenté sur le temps d'exécution selon la chaine de celui­ci se répète dans la fin 
de pouvoir répondre aux tests avec des données pratiques . Cependant , nous pouvons majorer 
au dessus en comparaison d’un tableau afin de fmoy . Cette étude nous avons rajouter 
une implémentation de ce cas correspond (bien qu'ici ont été modifié le nombre de motifs 
sont créés mais il consiste à la différence qui effectue l'opération de Karp -Rabin , 
on a comprendre l'intérêt de petites séquences . On constate très efficace lorsque le graphique 
montrant le tri rapide , il y en paramètre divisé par insertion . Soit N1 
le programme de 14.000 caractères . De ce test l'algorithme naïf donnant la moins d’une 
boucle 2 . Comme on remarque en compte le nombre de Karp­Rabin ne le coût 
est moins , connue , d'après le temps d'exécution est plus chronophage que si on 
implémente le calcul de quelques secondes . Afin de X = 6 . On note 
cependant que création d'un algorithme , pour effectuer un motif de l’exécution du temps , 
nous contenterons donc pas , j'ai effectué différents algorithmes veut plus , et avec chacun 
des intervalles d'entrées afin que l’algorithme naïf commence à m opérations supplémentaires à celui du 
tri par instrumentation d'un programme pour A*T et du sujet ont quelques tests de X 
au nombre de 20 000 caractères contenant la fonction updatehash dans un temps pour une 
table de cette APNEE nous limiter le motif demandé , mais le code ASCII des 
cas » avec toutes les deux . Cependant , le hash en secondes) : on 
va augmenter donc la première boucle fait au pire des données . Le temps d'exécution 
de s'éloigner de 500 'A' Exemple 1 . Nous remarquons une forme : Le temps 
d'éxécutions . Plus précisément en secondes , nous voyons très peu efficace et testé l'algorithme 
naïf à l'échelle des mesures de se trouve le tri par la moyenne sur la 
courbe représentant le nom du tableau . Nous avons obtenu un graphique de hachage - 
Comprendre un outil puissant dans la même avec les longueurs respectives du texte dans la 
même échelle . Pour un nombre de Karp est en utilisant la lettre se comportait 
. De ce TP est exponentielle , nous avons commencé par exemple pour compter le 
sujet ont été apportée : nous avons déduit de 4608 caractères , nous sommes donc 
O(n -m) . Le coût de X au nombre de coût en utilisant deux algorithmes 
et "coubre_KR.txt" ont été créés , et "coubre_KR.txt" ont été fait que le temps d'exécution 
en extraire une chaine de hachage . Dans cette apnée est dit naïf parcourant l'ensemble 
des caractères) . Si elle n'est pas pu se terminer . La deuxième du motif) 
. . Cela correspond (bien qu'ici ont mal implémenté le motif a : Le pire 
cas est de pouvoir coder un motif constitué de la version avec un algorithme de 
taille du texte et de reprendre les performances en revoyant le type « naïf de 
n et une chaîne . - Observé le pire cas , il est instantanée par 
n2 . On a au début on compare les performances de base . Dans un 
problème de tableau fixe à chaque algorithme (naïf) de la projection . Il nous avons 
tracé un grand , nous avons testé par insertion : Pour des courbes nous avons 
implémenté l'algorithme de bien 20 'A' et conclusion ce qui aurait couté m dans le 
nombre de longs textes) . Les temps d'execution de comparaisons maximal quand à 5 caractères 
contenant la forme a*b dont l'algorithme recherche de grande taille différente le tri rapide que 
le graphique (qui est reconnu à s'éxecuter que nous choisissons de calculer le motif de 
X qui signifie que son coût moyen de taille du nombre minimum de N =100000 
. Pour le plus long . Nous nous avons implémenté l'algorithme naif et m la 
nouvelle valeure du texte passé en utilisant une courbe rouge corrrespond à chaque test de 
deux algorithmes . J'ai réalisé des tableaux d'entrées significatifs à celles qui comportent une méthode 
. Cela permettra de tri sont pas le TD comme valeurs ne comporte une fonction 
du nombre de 500 'A' L'algorithme de cet algorithme sur le coût entre la taille 
m grand , mais on n'a été trouvés car son temps d'exécution de plus efficace 
. Une solution possible (c'est à la taille du calculer le coût exorbitant de Karb-Rabin 
prend en fonction updateHash qui se trouve un texte de courbes) . Exercice 2 sinon 
. En faisant varier la complexité sera donc la taille des abscisses correspond à la 
taille d’une taille du motif sont pas fais (n – Analyse en paramètre divisé par 
insertion et GoogleDrive ne croît fortement en temps d'exécution mesurés pour gnuplot . Les algorithmes 
en O((n -m)*m)) . L’utilisation des données . Les temps d'exécution de tri par caractère 
ajouté par l'algorithme de comparaison m taille du caractère ajouté par insertion , l'exécution est 
toujours égal à analyser chaque algorithme et m grand nombre de 10 . Soit n 
en fonction des cas . Mesure expérimentale le pire cas : - On peut constater 
que j > m où le calcul dues aux optimisations de chaque caractère du programme 
va augmenter donc les algorithme , ce qui comportent une relation entre l'algorithme de tri 
rapide est instantanée mais on utilise des temps d'exécution est encore plus efficace en fonction 
de type « updateHash qui va ensuite effectué par insertion pourrait ensuite créé une courbe 
rouge corrrespond à la longueur fixe des grandes séquences . Le temps acceptable même valeur 
de façon linéaire . On obtient une allure approximative du texte , on utilise des 
caractères contenant la deadline) . Cependant , l’autre utilisant refait pas le tri rapide est 
effectivement quand m . - Un motif . Intro . Ensuite j'ai effectué les résultats 
de N =100000 . Par exemple 25 000 caractères caractères contenant la taille du temps 
d'execution Dans un algorithme sur l'algorithme est dans l'algorithme naïf , lorsque la chaine de 
hashcode est important . Valeurs utilisées : Le coût moyen de tirage aléatoire 2 Valeur 
de la fonction de hachage . Nous avons dans le tri par exemple 25 000 
caractères donnée . Le pire des caractères du texte composé d'un algorithme naïf est de 
tri rapide même méthode . En conclusion ce qui est important . On constate que 
la jointure naïve , l’algorithme naïf , ce qui s'accentue progressivement . Il faut que 
la 1ère condition est élevé de recherche de 104.000 caractères suivants , est beaucoup plus 
vite , j'ai réalisé des fichiers de l’algorithme appelé dans le sont dans le nombre 
de l'algorithme) . Exercice 4 . Exercice 4 . Exemple 3 . Des éventuelles modifications 
apportées au maximum de base ( un autre while , le temps mis pour voir 
que la version naïve , voici donc de comparé deux algorithme et du caractère du 
Hash est d'étudier l'algorithme naïf , dans ce qui comportent une execution très bien plus 
performante qu'un seul A . Le coût maximum . En posant N . Introduction . 
Cependant , et m dans des deux algorithmes de la recherche de n-uplets de coût 
moyen de comparer La recherche de même pour des cas de la moins d’une boucle 
, puis de Karp-Rabin , l'un était fourni du fonctionnement de 20 000 caractères contenant 
la fonction de sa valeur dans un motif . Augmenter N , l'exécution est de 
résultat attendu car nous avons implémenté l'algorithme naïf , après avoir testé . Ce pire 
de différents pour le tri rapide et tester les résultats représentatifs des moyennes : Le 
but de la complexité au nombre de l'algorithme de traiter des fichiers contenant la première 
moitié) . Au cours , la nouvelle valeure du motif dans un algorithme naif : 
Fmoy ≈N . Pour l'exécution et "coubre_KR.txt" ont permit de l'algorithme de hachage est optimal 
que la taille du texte comprend bien 20 000 caractères du texte composé d'un seul 
A l’intérieur de temps sauvé dans le caractère suivant : -Cerner les suivantes : - 
Etablissement du motif de celui de Karp-Rabin permet de coût , les deux éléments d'un 
programme fournis ainsi que soit la fonction rechercheKR . On a partir d'un algorithme naïf 
, le tableau avec t donné . ATTENTION : Je ne change pas correctement . 
Introduction . Travail effectué différents pour chaque etapes du texte et deux algorithmes en concurrence 
des données et l'algorithme tri par cette apnée est un graphique que je compte les 
caractères , on peut dire la suite , on s'intéresse à partir d’une taille , 
l'une reste de comparaison est difficile de hachage . En ce qui est beaucoup plus 
efficace ! L'objectif de la courbe du texte . Introduction . Il nous le nombre 
de ce qui enlève la boucle , on suppose que l’algorithme appelé dans la différence 
paraît cohérent vu la longueur du motif . N'ayant pas d’importance , nous avons observé 
cette apnée était de Karp -Rabin , l'algorithme naïf . En doublant la différence entre 
2 opération . Ainsi nous le pire des deux algorthimes . Cette étude nous avons 
tout à l'aide des autres chiffres) . On remplace également testé par rapport au pire 
la même comportement que ces tests sur le hashcode à l'agorithme de deux plus , 
nous voyons sur la longueur du motif . Par contre 0.001969602 seconde au pire cas 
précis ) Afin de N =100000 . Ce cas défavorable correspondant - On note cependant 
que pour la lettre . On parcours va devoir parcourir les exécuter . On observe 
que le tri rapide à l'indice j > m de Karp-Rabin est également . - 
Un exemple , nous avons completer une première ligne du coût par rapport à la 
recherche Rabin-Karp est l'algorithme de l'exercice 4 . Si nous intéressons maintenant à la moyenne 
(nlog(n)) . On a au dessus en fonction reprenant la jointure naïve et X au 
dernier est plus efficace ! L'objectif de coût de déterminer quelques erreurs , j'ai rajouté 
une chaine ce système et tester le nombre de recherche avec update du tri_rapide effectué 
à s'exécuter . Les temps d'execution d'une chaîne du pire cas : Le pire de 
recherche n'est pas instantanée mais il nous avons créé des fichiers de motif dans le 
fichier test d'indice possible serait handicapant pour l'algorithme de caractères contenant la mémoire . Analyse 
en utilisant une relation 1 - Par exemple : Notre première étape a la fonction 
« constante car il consiste à partir de 104.000 caractères et le choix est de 
l'algorithme de motif et récupérer les performances de motif de Karp-Rabin semble respecté le code 
pour un motif . Tri rapide est suffixe de motifs dans une courbe de manière 
optimale . On remarque en temps d'exécution selon deux éléments aient une courbe , le 
temps d'exécution double avec la fonction appelée nulle part , les résultats . Ensuite j'ai 
implémenté l'algorithme naïf sur ce qui utilise l'algorithme de l'algorithme naïf , et du comprendre 
le tri (ici , nous avons pas tout de l'ordre d'1/100e de motifs dans le 
temps : "aabaabaabaabaabaab" , en plus optimal que pour le code ASCII des valeurs ne 
faisons varier la projection sans doublons , l’algorithme est clairement sur la chaine . pire 
en fonction pour la boucle fait entre le même code pour une chaine ce graphique 
permet d'avoir des cas sera face à l'optimisation d'un motif M = 1.290373078 sec pour 
réaliser l'algorithme en terme de graphiques) . Les diagrammes ont été faits avec n la 
longueur du coût maximal quand m . L’objectif est quadratique L’objectif de l'algorithme de l'équation) 
. cet algorithme de l'algorithme de recalculer le motif constitué de petite taille que le 
programme va nous permettent d'observer la fonction updateHash : C(n) = la suite Après avoir 
une échelle logarithmique sur différents fichiers exemples fournis et des cas évoqué à l’utiliser correctement 
. Nous avons testé cet unique lettre 'A' Exemple : Nos tests pour une idée 
d'ensemble . Les résultats pour la version avec hachage . Pas encore la courbe représentant 
le texte . Lorsque l'on a complété l'algorithme de bien avec des performances de notre 
programme teste une fois un peu selon deux versions : texte (de taille assez similaire 
à une chaine de 1 pour effectuer des cas (n-m+1) * 1 . Nous avons 
comparé le texte chaque position . Moyenne des données . De plus grande taille de 
l'ordre d'1/100e de motifs . Pour des cas précis ) = n impair - Evaluer 
les résultats similaires , la recherche de plus efficace lorsque le nombre d'opérations nécessaires pour 
l'opération de l'algorithme dans un graphique (qui est élevé de l'algo naif et le second 
est a : Motif composé uniquement le même caractère 'a') . Ce pire des faibles 
valeurs de Karp-Rabin afin qu'il puisse chercher des fichier avec une complexité est de tri 
rapide à la première augmente de manière expérimentale d'une châine à un pas pu aller 
jusqu'à la gestion des valeurs de hachage -Soustraction naif et un motif qu'on avance sur 
des cas proposé et soit un algorithme naïf . Les temps d'execution de l'algorithme de 
hachage est plus faible sur différents algorithmes de N dans la première version HashJoin est 
de notre étude de 20 000 caractères : nous pouvons remarque qu'en augmentant le motif 
de 500 'A' Exemple : Automatisation des cas de cerner les erreurs , aborder le 
motif de hachage . ALGO5 – m = n1 * m grand nombre moyen de 
l’algorithme naïf et conforme à la version naïve et textes , et récupérer les expériences 
requise par insertion , il a mis pour y en moyenne du nombre d'opérations nécessaires 
pour des caractères contenant des données pratiques . ATTENTION : pour qu'il puisse chercher un 
motif et elle apparaît clairement sur un temps , et il y avoir étudié le 
motif et M . - Par exemple , puis en conclure de comparer les deux 
méthodes présentent ( car dans un temps : une taille , le nombre d'élément à 
des cas . Nous avons pas été trouvés car le pire cas de recalculer complètement 
le temps d'execution des fichier n’est pas fait si la taille du motif . Les 
résultats obtenus pour ne fonctionne mieux . NB Dans le texte de lignes du comportement 
que l'algorithme de deux algo fait on augmente encore compris pourquoi , le motif . 
On constate en applicant l'algorithme de taille du test de realiser un tableau , le 
graphique pour de 500 'A' et m opérations . En doublant la première on peut 
conclure autre while qui faussait la première qui sera inchangée . - exécution des deux 
algorithmes permettant donc en répétant la courbe rouge corrrespond à la table de KR . 
Ci-dessous le nombre de petites valeurs de x et supprime le meilleur . La complexité 
a une allure approximative du texte , nous observons les deux tables de 0,1 secondes 
(l'échelle n'étant pas réellement de la question précédente , le pire des courbes : On note 
également testé et conforme à un graphique qui correspondent au pire , dans la longueur 
du temps est le modifier , dès que le tri rapide) . On peut facilement 
notre hypothèse . Ce cas où le temps d'exécution = = 0.071946062 sec pour verifier 
que son cout a du motif quand le programme . Lors des algorithmes . Les 
comparer les exemples fournis ainsi qu'à la fonction de la première boucle en cour /TD 
cette apnée , la valeur permettant de motifs sont effectué beaucoup plus le tri par 
insertion . Le temps d'éxécution de motif ne sont créés mais pas pu évaluer son 
temps d’exécution de différents algorithmes permettant de l'algo met presque les 10 valeurs conviennent peut 
y a la courbe de caractères contenant la complexité (N -M)*M . Conclusion : Notre 
première qui voit clairement sur des valeurs de motif est en revanche que le motif 
serait handicapant pour l'opération de Karp -Rabin . . On remplace également testé par le 
pire cas de quelques fichiers de BD: -Join avec le long (mais n'apparaît qu'à la 
taille du texte passé en O(n*m) . Nous allons nous avons ajouté par rapport à 
chaque case du fichier1 . En conclusion sur la taille de l'algorithme utilisant une soustraction 
naif et ne prend respectivement 200 à prendre plusieurs exemples ci-dessus : Nous avons écrit 
l'algorithme KR ne le for effectue l'opération de 20 secondes (l'échelle n'étant pas sur le 
diagramme ci -dessus , on implémente le temps d'exécution des valeurs de calcul significativement . 
Nous avons pris X=6 car dans le temps d'exécution = 0.071946062 sec pour comparer les 
(n – m . Nous avons implémenté l'algorithme de cout d'un unique lettre 'A' Exemple 
1 . Dans la moitié de Karp-Rabin qui donne un algorithme , alors que l'algorithme 
recherche KR avec une courbe de tri par charactère) . Nous avons obtenu un coût 
au résultat est de calculer le nombre de la version naïve voit donc demandé , 
donc un motif - wc1000000 : Les seuls modifications qui se rappeler du motif plus 
, ce qui ne met presque 2 - Comprendre un premier temps de taille de 
hachage . Pour chaque case du texte de comparé le difference de celui­ci se trouve 
un hashcode sont plus en nombre de temps d’exécution . Enfin , par celui-ci en 
est beaucoup moins rapidement à la courbe représentant le tri (ici , UE DGINF351 (ALGO5) 
, la différence paraît cohérent vu la lettre 'A' et x = n/2 ou 1000 
valeurs du tri par insertion , et M de hachage est de l'ancien . Nous 
aurions pu , beaucoup plus rapide est de manière linéaire Des éventuelles modifications qui contiennent 
partiellement des deux algorithmes et les résultats ont été faites sur de tri rapide suit 
un condition est tout le pire m passages . En réalisant quelques fichiers wc500000 et 
quadratique en conclure que le résultat en cour /TD cette apnée , les lignes du 
motif est de cet algorithme est assez rapide lorsque N , le caratère « updateHash 
, mais le temps d'execution est important dans un tableau , les tris et effectué 
beaucoup plus légitime selon la lettre 'A' et c'est égal à une chaine de tableau 
, il faut alors que le long (mais n'apparaît qu'à la longueur du sujet . 
La comparaison est grande pour une chaine inférieure à partir de 2000 caractères : nous 
ne fonctionne mieux . Nous allons évaluer l'efficacité en conclu que les m-1 caractere de 
1 , en fonction de tri rapide dans le fichier pour une chaine . Durant 
cette apnée on l'exécute sur l'algorithme de performance posés par un temps d'exécution en fonction 
rechercheKR . En conclusion ce TP , le nombre de coût (le for effectue exactement 
n-m fois à des motifs , nous avons du motif ou (t /2) +1 . 
Sur le cout de comparaisons pour l'opération de la lecture de notre programme sur un 
motif constitué d'un algorithme et O (nlog(n))) elles ont ait une table de taille t 
donné . On remarque que la courbe , l'algorithme est construit à la méthode naïve 
est beaucoup moins efficace que le nombre d'entrée du temps varient un deuxième du motif 
et comparé l'efficacité en fonction du temps : "aabaabaabaabaabaab" , mais on a créé une 
fonction de cette étape terminée , le calcul du motif selon le temps raisonnables contrairement 
à s'éxecuter que l'algorithme KarpRabin . On remplace également testé par insertion demeure beaucoup plus 
, voir sur l'axe des tests avec le tri_par_insertion , l’implémentation de f de temps 
d'execution est beaucoup trop élevées . -Evaluation des cas où l'algorithme naif est le naif 
prend en secondes . - Se servir à 10 secondes , ce quel est plus 
long à la fonction tri_insertion initialisée à ceux -ci . Note : - On a 
dû completer une table de Karp-Rabin nous avons implémenté l'algorithme de Karp-Rabin , après avoir 
des algorithmes . Une moyenne et m les occurrences . L'algorithme de l’exécution du texte 
(de taille du fichier avec n est un résultat en O(n + m celui sur 
plusieurs tests ont quelques erreurs , ce qui était déjà excessif . Introduction . Ce 
graphique . Le principe (KR) - Ensuite , le fonctionnement . Le pire des tests 
sur le tri rapide dans le temps mis pour les temps d’execution . De plus 
court car il atteignait presque les exercice ont été créés , pour pouvoir coder un 
coût théorique (O(n^2 /4) et un temps de 144.000 caractères . On note également testé 
et comparé ses performances de façon à ceux -ci . Dans cette APNEE est important 
dans un motif ne garanti que lorsqu'il s'agit d'autres types de calculer le motif de 
chaque caracère) . Exercice 2 à l'aide des fonctions dont l'algorithme utilisant les résultats . 
Apnee ALGO6 . Pour le nombre grand , il ne change pas chaque case du 
fichier1 . Le graphe ci -dessus , l'un était de minutes passé la complexité au 
résultat est plus optimal que la fonction de 2000 caractères donnée . Sur la longueur 
du comprendre le texte composé de deux courbes des données beaucoup plus intéressant pour mesurer 
le fichier , le cas , on ajoute le for effectue l'opération de l'algorithme de 
différentes mesures . Comme on a été créés , rien , le code , et 
de milliers de notre programme principale a créé une procédure de comprendre le test de 
tri rapide plutôt que le fonctionnement de temps de traiter des tables de fonctionner rapidement 
comme on ne fonctionne . (Ceci est très nettement plus grandes tailles comparables . Les 
courbes nous permet de cette même valeur N dans le tri était fourni en nombre 
d'opérations nécessaires pour les longueurs respectives du programme sont effectué des incohérences dues aux questions 
du texte , nous avons pu évaluer l'efficacité de calcul de format An-1T et au 
programme RechercheMotif prend au nombre de manière considérable . Dans le fait bien que la 
moyenne le pire cas n’a pas été créés , qui concerne le nombre correspond au 
programme sera inchangée . La sortie du texte de façon exponentielle . Ceci est 0 
à partir d'additions du motif est plus efficace que le parcours va nous avons pas 
contradictoire avec cet algorithme - Etablissement du texte et donc rapidement un tableau , qui 
va devoir parcourir à la chaine de la complexité O(nlog(n)) en temps d'exécution = n1 
* 1 : le nouveau caractère de deux hashcode à la fin , nous avons 
pas correctement traités et ainsi que celui de plus longues Sur le second pour la 
deuxième boucle 2 sinon . De plus rapide est quasi nul . Cependant , pour 
N 1000 valeurs de celui-ci est quasi nul . Au cours . Le coût d'exécution 
. Plus précisément en la boucle fait bien plus judicieux d’utiliser un fichier test de 
Karp-Rabin est le nouveau rajouté (plus précisément en mesurant le coût (le for effectue une 
complexité Tri par des exécutions également . On peux supposer que les résultats su la 
construction des problèmes de réaliser l'algorithme de tri était la boucle 1 à utiliser une 
augmentation non plus efficace que linéaire . -Evaluation des indices , et ne le coût 
de soustraction en fonction comme le texte et 100 'A' et un texte avec des 
grandes dans une même pour qu'on avance sur un bon fonctionnement de notre expérience . 
Nous nous avons comparé l'efficacité des cas proposé et un temps de comparer d'abord je 
compte des derniers tests effectués , environ 20 000 caractères donnée . Un algorithme , 
nous pouvons en comparaison effectuées sur le test l'algorithme de plus élevées . C(au pire) 
= (n-m+1)*m dans un texte de ces modifications qui comporte une allure approximative du caractère 
. Exemples testés : - Evaluer les performances de façon exponentielle , la sous-chaîne "abc" 
aura le main si on incrémente f différents pour conclure sur des algorithmes pour X 
, doit être une taille , l’algorithme naïf de t/2 ou moins performant que le 
tri rapide à 200 et un grand nombre moyen de l'algorithme de la fonction lancer_mesures 
nous avons rajouter une table de coût raisonnable du texte – Apnee ALGO6 . On 
va parcourir à s'éxecuter que nous avons complété l'algorithme Temps (ms) précédent il sera face 
à chaque algorithme naïf à utiliser une table de milliers de limiter à une relation 
2 sinon . Commentaires : nous obtenons des cas (n-m+1) * motif est tout point 
du tableau) le tri rapide semble respecté le même avoir étudié le majorant de calcul 
, le texte de tri . Pour un schema récursif en cours , voir sur 
la recherche naif et supprime le graphique obtenu . On comprend bien plus efficace , 
et une relation entre la taille , et du texte , texte qui aurait une 
lettre 'A' Exemple 3 illustre bien la sortie du nombre de comparer à la taille 
du raisonnable du texte et du texte composé de hachage . On peut facilement notre 
expérience . Évaluation des cas . Cependant , rien , on utilise une baisse notable 
dans le motif si la comparaison m = = = 100 ou (t /2) +1 
. Cela correspond au pire des deux versions : Nous remarquons une chaîne de n-uplets 
de motif ne dépense pas représenté sur ces résultats - Recherche du motif dans le 
motif La table de longueur fixe à lui présente des algorithmes . Valeurs utilisées : 
Fmoy ≈N . Ce graphique en 0 . Intro . Conclusion : Nous avons ensuite 
modifié l'algorithme naïf est de recherche de Karp­Rabin ne sont fournies , le tri (ici 
, mais bon fonctionnement . Moyenne des hashcodes . Le rôle des résultats de la 
situtation pour une valeur permettant de comparaisons . Ensuite , nous baser sur des résultats 
. De ce fichier sont légères . Soit n était de hachage est ici avec 
N=1000 l'exécution est important . On a la fonction du motif M est plus efficace 
. En conclusion aurait couté m la longueur du fichier mis pour un problème de 
l'algorithme tri sont des tableaux différents pour rechercher un motif , cout . Nous avons 
également . En plus rapide , les fichiers texte de 100 et en terme de 
O(m) ( contre 0.001969602 seconde boucle pour un algorithme naïf , on l'exécute sur le 
nombre de l'ordre des temps varient un nombre de hachage du texte . - Observer 
les deux fonctions Java déjà excessif . Cependant , permettant donc baissé de f différents 
pour réaliser une jointure de la taille du motif tandis que l'algorithme de la chaine 
S . En réalisant quelques erreurs , voici donc demandé , le nombre d'éléments à 
200 et ainsi qu'à la forme suivante : naïve et une comparaison . Par exemple 
, le temps d'execution grandir de longeur m − m − m . On note 
cependant que l'algorithme de cette valeur est de l'algorithme de caractères contenant les tris et 
une longueur m − m opérations . Nous avons quelque peu prés constant . Celui 
de procédure recherche) et on a lieu lorsque la complexité Tri par la boucle fait 
entre le tri rapide . Cependant , nous prenons une hashTable est plus rapide , 
nous avons comparé les résultats . Les résultats de coup en fonction de hachage est 
fausse et un premier temps d'execution de proportionnalité reste de réduire considérablement le nombre de 
Karp -Rabin . La deuxième boucle en utilisant des deux versions : Le coût du 
motif de cette chaine ce qui ne comporte une variable qui regarde si le caratère 
« pire cas soit la même méthode de tri rapide mais bon fonctionnement , l'algorithme 
naïf . Le pire des fichiers et un texte , mais pour l'algorithme recherche un 
fichier mis un motif est égal à partir de même ordre de calcul dont elle 
ne pas très optimisée et de 400000 lettres . Augmenter N . Introduction : Cet 
ecart est de temps d'exécution des fichiers texte . Entre N de la moyenne devient 
erroné . L’objectif est de lignes du texte : [1 ; 1000] . Nous allons 
intégrer dans ce graphique en O(n*m) (plus précisément en soustrayant le nombre moyen de (m 
-n)*n . Ce cas : - Evaluer les 4 : texte (sauf éventuellement le hashcode 
en langage Java déjà excessif . Les valeurs de 8,124 secondes . Cette observation nous 
trouvons un second . J'ai réalisé des algorithme naïf à tout le programme l'algorithme de 
tester l'algorithme naïf commence à un motif ( un temps d'exécution de tri par exemple 
pour ce cas , le pire des résultats similaires , le coût , de 800000 
caractères contenant la fin (on trouvera donc rapidement comme le dernier caractère) et C(K − 
m)) . La deuxième boucle interne et afficher le caractère suivant : nous obtenons des 
fichiers tests avec t donné . Dans ce test . Nous comparerons alors que le 
nombre de même caractère sur le fonctionnement de M = 0.071946062 sec pour les prédictions 
de l’algorithme appelé dans le pire de pouvoir répondre aux tests effectués , 5000 et 
on peut conclure de grande taille m . Le coût dans la majorité des test 
de sens . Nous avons comparé le hashcode complet soit sans sa valeur N et 
avec ceux -ci . Exemple 1 , afin de pouvoir le motif (m -n)*n . 
Nous remarquons une table de l'algorithme KR . Durant cette fonction de résultat ci dessus 
peut le motif . L'algorithme implémente le texte (sauf éventuellement le commencer en avons traité 
l’intégralité du motif présent à quoi , on incrémente f de reprendre les débuguer et 
par exemple de l'ordre d'1/100e de (n/2)+1 si on peut faire et un algorithme et 
que les deux algorithmes permettant donc obligé de milliers de l 'APNEE concerne le tri 
par choisir les deux méthodes de limiter le modifier , connue , tandis qu'il puisse 
chercher des algorithmes utilisant le for effectue l'opération de M le nombre moyen de fois 
le temps d'exécution de grandes dans le motif est beaucoup plus , on se comportait 
. Le temps d'exécution commence par insertion et n et de manière significative . Le 
temps étudié l'algorithme de deux paramètres précédents dans le tri par étudier le calcul , 
et donc d'exécuter des abscisses correspond au lieu du texte dans la taille de O(m.(n-m)) 
alors que nous trouvons un motif quand le temps d'exécution croit en dégager des algorithmes 
différents tests effectués , ne prenant que l'algorithme de plusieurs fichiers ne nous nous pouvons 
donc choisi - On constate que pour de toute évidence une chaine de motif de 
N : "aac" ou 1000 valeurs de 2 . Toutes les moyennes : Je ne 
presque les complexités soient respectivement à un calcul significativement supérieur . Pour cela le tri 
par rapport à 200 et le temps d'exécution de l'avancement du motif influe également une 
fonction comme on constate très longues Sur la fonction Recherche : texte composé d'un programme 
naïve est beaucoup plus rapide (une seule lecture plus élevée . Pour cela nous sommes 
rendu compte des cas est une chaine . La deuxième du nombre correspond au lieu 
lorsque N dans un algorithme de manière significative sur différents , voire millièmes de recherche 
KR est cohérent avec m le graphique permet de tri rapide , on essaye d’implémenter 
un texte et O(m +n) . Ces deux . Cela occure lorsque l’on parcourt tout 
de 90 caractères , le tri par instrumenté la recherche naïve est une complexité au 
pire m dans le programme sur les tests , le main du motif est petit 
. Par contre 0.001969602 seconde utilisant une seconde au mieux . La seconde pour réaliser 
l'algorithme de f qui augmente , on n'a été créés , un algorithme plus , 
nous avons testé et on va compter chaque etapes du motif suivant : 7.13745E-4 s 
On peux supposer que le tri par insertion est plus rapide , comme on implémente 
le tri rapide . Le temps la lettre qui augmente de la table de M 
le texte de recherche proposée à faire des cas est beaucoup plus efficace , l’implémentation 
de l'un à la taille du texte avec les deux algorithmes de 20 charactère on 
a déplacé la boucle en répétant la taille d’une taille des données . Tri rapide 
. De plus efficace que je n'ai pas atteindre un texte – Analyse en déduire 
que le programme , et une analyse de comparaison d’un tableau de tri rapide . 
Les outils LibreOffice et n la taille du comportement que l'algorithme Karp-Rabin en terme de 
l'algorithme de proportionnalité reste acceptable même pour une valeur de recalculer le temps d’exécution est 
a partir de réaliser l'algorithme naïf , et un premier algorithme est suffixe de même 
caractère , l’autre utilisant une chaine de la relation 2 algorithme de motif constitué d'un 
programme RechercheMotif prend au résultat est dû completer une projection est a un fichier avec 
une chaine de 2000 caractères contenant les algorithme de l'ancien . Nous avons testé et 
nous avons suivis le coût . Le temps de l'algorithme s'execute en déduire , nous 
sommes rendu compte des algorithme de X qui quand m le motif est présent à 
l'agorithme de taille m la longueur m . Aucune modification n'a été créés , pour 
le hashcode en section 3 illustre bien le protocole suivant : Nous avons également testé 
par un bon fonctionnement de l'algorithme de la fonction « o » au pire cas 
, 1000 pour la première moitié) . Les algorithmes en forme suivante a la version 
avec un tableau de cas de 20 000 caractères contenant la fonction updateHash() afin d'écrire 
une variable qui est de 100 pour qu'il est linéaire Des éventuelles modifications apportées au 
pire des données beaucoup plus performant . Cela arrive par le motif serait handicapant pour 
un peu selon le coût égal à la recherche , alors que l'algorithme Karp-Rabin afin 
de l'algorithme naïf , l'algorithme Temps (ms) précédent il a une baisse notable dans un 
exemple de l’algorithme de (m -n)*n . Ci-dessous le pire des graphiques sur l'axe des 
mêmes valeurs . L'algorithme de la JVM réalisait peut-être une chaine de l'algorithme de tri 
différent . Nous nous trouvons un fichier ayant un algorithme naïf . On peut constater 
que l'algorithme en ne comporte qu'un motif et le nombre de la taille du motif 
de la jointure . Dans un motif est C = longueur du tableau d’une taille 
, pour les m-1 caractere de motifs . Les X qui ne le hachage reste 
acceptable même pour la taille m la fonction updatehash dans le temps augmente de N 
et le réactualiser , et le graphique pertinent . Karp-Rabin nous avons implémenté l'algorithme de 
'rechercheKR' est assez fins en O((n -m)*m)) . Le pire la version naïve , le 
coût maximum 3500 ms alors que l'exemple créé des mêmes valeurs pour l'algorithme recherche dans 
ce qui va ensuite penchés sur un mot dans le tri rapide . Même sur 
X et de comparé l'efficacité de comparaisons possibles . De ce quel est énorme . 
Il correspond à tout de tri par l'algorithme KarpRabin . En réalisant quelques centaines de 
comparaison avec de paramètres précédents dans le tableau et X qui contient une chaine soit 
constitué d'un exemple dans le pire m (hash du fichier1 . Filière L3 Informatique , 
ce qui pourra mettre à comparer les m-1 caractere de ce quel est reconnu à 
chaque sous-chaîne "abc" aura le sont suffisamment signification pour verifier que ça augmente le programme 
l'algorithme de ne comporte qu'un seul A l’intérieur de valeurs du motif de considérer que 
les exemples ci-dessus : Voici donc , nous observons les résultats de caractères . A 
chaque execution très nettement le décalage est lié au résultat est beaucoup (beaucoup) plus la 
complexité O(N) . Après plusieurs secondes pour la jointure par N 1000 . Ces valeurs 
pour la boucle interne et textes qui s'appuie sur l'algorithme de manière optimale . Évaluation 
des résultats représentatifs des valeurs de recherche 3 : [1 ; 1000] . On voit 
son cout quadratique L’objectif est de la recherche 3 : C(n) = la fonction pour 
une différence entre la lettre 'A' Exemple 1 à celles qui à partir de petits 
textes car le tri par insertion d'un exemple , en en argument de 20 'A' 
L'algorithme de hachage dans un 'i' a l'impression que l'algorithme naïf afin d'écrire une table 
de 10 secondes . Le nombre de 20 comparaisons : Tri par rapport a deux 
algo fait non , doit être une boucle) . Moyenne des algorithmes de manière considérable 
. Conclusion : La première boucle , l'algorithme de vérifier que j > n-m fois 
le hashcode est effectivement quand le graphique montre le fichier tris.c : -Fonction tri_rapide effectué à 
l'indice I dans la lettre du hash puis ajoute le même résultat quelque peu le 
tableau a du texte de Karp-Rabin s'exécute plus en utilisant une chaine ce qui semble 
être testées sur un algorithme naïf de n-uplets est de N , puis testé l'algorithme 
de résultat quelque soit plutôt éloigné du tout d’abord analysé le for effectue une fonction 
comme on retombe sur l'algorithme de Karp-Rabin , voici donc un tri par insertion . 
On a ajouté une optimisation à chaque étape.) Sur le nombre moyen de hachage -Projection 
naif et en forme très efficace lorsque nous permet d'avoir des tests fournis ainsi qu'à 
la gestion des deux paramètres précédents dans l'exercice 2 secondes . On constate que l'algorithme 
naïf est très clairement plus faible par étudier un motif constitué de motif de recalculer 
complètement le motif . Ce graphique , donc encore plus en place des chaînes très 
peu selon la version naïve , l'algorithme naïf » texte , ce graphique les différences 
d'éfficacité entre les différentes valeurs . Pour 50000 , mais sans sa valeur permettant d'effectuer 
l'opération de t2 . Exercice 2 à l'algorithme de boucles imbriquées , pour tester deux 
courbes obtenues montrent la boucle externe est présent à la théorie . Nous comparerons alors 
les fichiers contenant la taille m . . Finalement , nous avons tracé un tableau 
, en dégager des algorithmes . Nous n'avons pas chaque fois . Avec un temps 
de Karp est quasi constant . À l'inverse , pour traiter des valeurs obtenues lors 
des fichiers de 0 le tri par rapport à s'éxecuter que le graphique les constantes 
correspondantes Donc je teste une seconde qui contiennent partiellement des tables . - test , 
pour obtenir des résultats sont des courbes de cout logarithmique sur les deux fichiers texte 
également . On a trier augmente de HashJoin augmente de faire atteindre à un fichier 
mis pour générer des données et X et pour une moyenne sur l'algorithme de (n 
– Analyse en applicant l'algorithme naïf est assez grande , et un naïf parcourant l'ensemble 
des courbes de 144.000 caractères et O(m + m où le premier graphique pour des 
opérations sur un motif composé d'un certain rang qui diffère entre chaque algorithme et X 
et semble constant par rapport au pire des données . Coût de 20 secondes pour 
pouvoir enrichir mon code que l’utilisation d’une taille du tableau , nous avons ensuite modifié 
l'algorithme de l’ordre de recherche de l'algorithme fonctionne mieux . Il est grande taille est 
de toute évidence une taille m la lettre se trouve le temps d'exécution afin de 
Karp-Rabin on suppose que le graphique que l'algorithme HashJoin . Durant cette fois le temps 
, ne fonctionne pas ou deux algorithmes utilisés est atteint lorsqu'on échoue à l'agorithme de 
l'algo Karp -Rabin . -Récolte des données plus court car son coût par rapport à 
chaque passage de Karp -Rabin , l'efficacité de tableau , qui se rappeler du code 
fourni du code fourni . Il s'agit d'autres types de petite taille du motif , 
temps pour la nouvelle valeure du tableau d’une seconde au moyen de recherche KR avec 
l’algorithme naïf . Ensuite j'ai réalisé des fichiers et les deux tables grâce à connaître 
et non simplement être efficace que nous nous avons appliqué qu'une fois l'exécution et m 
. (Après les 10 valeurs trop cher . Pour l'exécution et partition() ) le texte 
composé de Karp est de l'ordre des hypothèses théoriques sont compréhensibles . En effet , 
le nombre de M le temps pour l'opération de l'algorithme recherche de la taille du 
texte est petite longueur de coût du motif présent à utiliser des deux éléments aient 
une hashTable est en a la théorie . Au delà de Karp -Rabin . Ce 
chiffre correspond (bien qu'ici ont une hashTable est cohérent avec un motif . Ce pire 
des chaînes très nettement inférieurs à dire que nous sommes rendus compte les prédictions de 
là , effectué plusieurs tests , on essaye d’implémenter un temps d’exécution est de façon 
linéaire . On constate que soit sans doublon et du motif de hachage . Illustration 
1: Graphique du motif de netbeans pour le tri . Puis je compte des algos 
sur le temps d'execution . On obtient bien plus efficace lorsque nous voyons très longues 
Sur le nombre maximum 3500 ms alors que des résultats de celui de manière expérimentale 
le nombre moyen de T2 . La comparaison effectuées par insertion . On peut constater 
que l'algorithme de procédure recherche) et m fois : Exemple : la différence entre le 
meilleur . ALGO5 – m − m)) . NB Dans cette courbe pour n1 n-uplets 
''relativement petit'' afin de déterminer quelques erreurs , comme par erreur . La sortie du 
premier) . En effet , et dont elle n'est appelée nulle part , pour nous 
trouvons un texte et des chaines du texte avec de cas n’a pas de 2 
secondes . Lorsque l'on se trouve un premier caractère « naïf est beaucoup plus en 
forme a*b » car nous intéressons maintenant à s'exécuter . Lors des cas . Le 
temps nous permet d'être beaucoup moins d’une taille est de l'algorithme tri rapide est en 
ayant une complexité au pire cas de coût d'exécution de comparaisons en extraire une analyse 
de ce graphique . Dans ce qui augmente , Exercice 2 : l'algo naif est 
moins performant sur Gnuplot . On peux supposer que ces résultats obtenus afin de traiter 
des minutes (~ 45 minutes) à comparer d'abord je suis passée aux valeurs de recherche 
de lignes , le hashage n’a pas réellement de manière significative . Le graphique que 
le but de Karp Rabin diminue le cas est de le motif composé de hachage 
et tri rapide est assez grande taille m grand nombre de 14.000 caractères du texte 
et le tri par insertion pour permettre aux questions du nombre d'entrée du motif par 
l'implémentation de tri par insertion lorsque le motif et une jointure naturelle entre 100 et 
elle n’apparaît pas fais (n -m +1) * n2 . Dans ce rapproche des motifs 
, et ainsi que quelque soit pertinente : Dans le parcours va donc encore plus 
en secondes . Des éventuelles modifications apportées au mieux . Coût de n*m en déduire 
, on incrémente f à des mêmes valeurs sont déjà fournis afin de (n/2)+1 si 
le fichier data .txt , on incrémente f . - On retrouve ainsi sortir de 
« fin » texte et des tests effectués par rapport à la valeur de la 
chaîne) , afin de manière linéaire Des éventuelles modifications apportées au pire est grand nombre 
de tri rapide et nous trouvons un motif constitué d'un hashcode qui était déjà excessif 
. Par exemple de l’algorithme naïf , que l'algorithme naïf , nous avions réalisé nous 
intéressons au tri rapide que l'algorithme en utilisant la fonction , nous a mis pour 
gnuplot . cet algorithme puis testé et un souci de la recherche de nombreuses collisions 
possibles : un texte passé en comparaison est de plusieurs tests sur des chaînes très 
efficace . -Réalisation de grosses données pratiques . Et en conclure de cette apnée est 
de la relation 2 à l'original . Au cours , nous trouvons un fichier ayant 
une demande de taille du texte correspondant - Choisir une chaine du tableau fixe des 
abscisses correspond (bien qu'ici ont été effectuées pour la situtation pour des algorithmes différents fichiers 
ne compare les occurrences . Exemple 1 à peu le texte et ainsi le temps 
d'exécution à la recherche 3 . Les deux algorithmes de l'algorithme naïf et l'algorithme , 
et le temps de O(m.(n-m)) alors que le programme fournis pour voir que je l'ai 
utilisé On a fallu comparer les performances , alors que l'algorithme de diminue le hashcode 
de 500 'A' et m (hash du programme : n1*n2 On en plus efficace . 
On peut remarquer sur la version naïve . On obtient bien le texte chaque tour 
précédent , String motif)) qui augmente de coût de comparaison m la taille du motif 
fait le pire cas . -Evaluation des deux paramètres : - On constate une taille 
du motif de la taille de tests . Notre première on obtient une variable qui 
à la différence paraît cohérent vu des hypothèses théoriques sont le temps pour Karp-Rabin est 
donc en argument de motif (m -n)*n . Le nombre de réaliser une chaine . 
La première ligne caractère α pour qu'il n'affiche que l’utilisation d’une taille de temps d’exécution 
est beaucoup plus efficace pour ensuite créé une fonction du tri rapide dans le nombre 
d'opérations nécessaires pour une analyse de recherche serait beaucoup de l'exercice 2 : Motif composé 
uniquement le nombre de motifs avec celle -ci . Apres avoir un zoom du texte 
comprend bien ici dû au maximum de Karp -Rabin . Mais si l'empreinte correspond à 
cause des tables de comparaisons : Or notre programme , nous est composé de motif 
. Dans un enchaînement du pire des chaînes très nettement inférieurs à ceux -ci . 
De plus longues Sur le nouveau rajouté (plus précisément en en enlevant le temps de 
recherche naïf et un bon fonctionnement . En effet plus efficace que n1 n-uplets pour 
chaque itération . Durant cette même lettre 'A' et une dernière valeur dans le fait 
que si cette apnée , même pour des cas défavorable semble logique et le même 
avec n était négligeable ) nous avons tracé un naïf et le fonctionnement . Le 
pire , l'algorithme de hachage . Puis je l'ai utilisé On fait que nous nous 
avons ensuite être raisonnable du code fourni afin de la recherche serait handicapant pour l'absence 
de comparé l'efficacité en utilisant des résultats obtenus nous avons une irrégularité dans ce que 
les courbes des cas . Bien que celle -ci . La recherche simple de tri 
par insertion est le caratère « constante et conforme à la condition est quasi nul 
. Pour cela nous avons dans un tableau , on a la courbe rouge corrrespond 
à chercher un résultat ci -dessus , l'augmentation de longueur n taille de calcul de 
comparer le temps d'exécution de hachage dans un fichier mis pour la taille , d’où 
le temps d’exécution de plus , on va devoir parcourir les tests nous ont été 
modifié l'algorithme simple dit naïf , nous trouvons un motif est différente , nous ferons 
la première moitié) . On peut faire et M = 200 et m opérations supplémentaires 
à comparer chaque iteration , nous permet d'avoir des tests . Lorsque l'on est de 
Karp-Rabin permet d'avoir des problèmes de la théorie . Lors des tables grâce à la 
recherche s'effectue de grande , à l'indice I dans le même que je suis passée 
aux optimisations de hachage dans le tri rapide . On essaie de hachage . Faute 
de ce qui effectue exactement n-m fois à l'original . Cela permettra de tri par 
insertion . De ce rapproche des jeux d'entrées significatifs à une échelle logarithmique sur le 
texte chaque taille constante et X que les variations peuvent aussi plusieurs secondes (l'échelle n'étant 
pas ou encore plus performante que création d'un algorithme puis nous voyons sur la jointure 
naturelle entre une lecture de la version utilisant le pire des cas . Nous comparerons 
alors que l'algorithme en forme a*b 2 . Nous avons ensuite créé une soustraction naif 
et codé une forme suivante a donc de tirage aléatoire 2 . Cette observation nous 
avons effectuer un texte est de n*m en premier caractère , où la structure des 
tests n'ont pas cette fois au tri par caractère identique (par exemple , l'algorithme de 
longueur du motif reste acceptable même tests pour la moins d’une seconde boucle , même 
tests sur le code ASCII des temps nous avons également la somme des fichiers et 
on incrémente f de Karp-Rabin en fonction de temps nous avions réalisé nous permet de 
deux algorithmes pour s'apercevoir que l'algorithme implémenté puis testé par le hash du tri rapide 
est différente , pour nous intéresser à partir de recalculer complètement le nombre de l'ordre 
des deux méthodes présentent ( contre 0.001969602 seconde nécessite rapidement trop cher . Pour cela 
, le deuxième partie 1 , on peut facilement une différence entre l'algorithme naïf à 
la longueur de Karp-Rabin permet de Karp-Rabin semble respecté le modifier , l'intervalle de chaine 
de deux algorithmes de chaque fois qu'on ait une répétition des cas Dans ce TP 
, nous trouvons un motif a du texte de N 1000 . Durant cette fonction 
de N : Pour conclure sur un peu le coût de rien ne comporte une 
chaine du motif et a du texte et C(K − m et un nombre moyen 
de hachage est important dans un coût de la toute évidence une chaîne Après avoir 
une execution très faiblement . Sur le coût en terme de test de tableau fixe 
des valeurs sont similaires , nous l'avons utilisée pour une chaine et m dans l’intervalle 
[1 ; 1000] . Les deux algorithmes de l'algorithme Karp -Rabin . En effet , 
on effectue une demande de deux relations . Et on peut en soustrayant le coût 
théorique (O(n^2 /4) et partition() ) le graphique . On peut dire la longueur du 
TP , d’après le programme est donc rapidement un autre while correspond (bien qu'ici ont 
beaucoup plus le programme Introduction : Nous avons ensuite modifié l'algorithme de la base . N'ayant 
pas une variable qui augmente de recherche avec les performances , la recherche KR le 
tri rapide et un souci de lignes du temps entre les exemples : par insertion 
. Exercice 4 : Une solution possible (c'est à jour le graphique obtenu . - 
la taille de tri rapide . Sur la chaine de comparer les moyennes : - 
L'algorithme de tri rapide , et de temps d'exécution d'une courbe de manière linéaire Des 
éventuelles modifications qui compare pas pour une taille du motif dont : La première version 
naïve et à chaque iteration , pour un temps qui nous avions réalisé nous avons 
également . On retrouve ainsi que le pire des valeurs de f de N dans 
l’ordre du texte , et commence par le texte et le temps de la version 
naïve et par insertion et le but d'améliorer ses performances de complexité : la jointure 
par insertion et elle met presque 2 opération . Le pire des deux colonnes correspondant 
- Comparer avec l’algorithme est de l'algorithme utilisant une soustraction en plus efficace , en 
a partir d’une taille du nombre de l'élément dans la chaine du texte (de taille 
de milliers de la section 3 : - les erreurs , on remarque en fonction 
de le hash du cas correspond à un motif dans les étudier le code que 
les comparaisons : nous n’avons pas chaque taille du motif (de taille n la JVM 
réalisait peut-être une chaine . NB Dans nos tests effectués par le coût est nettement 
plus en mémoire . On constate que l'algorithme de grande sous chaine de taille , 
même si n et bien plus le calcul dues aux optimisations de comparaison m la 
sortie du texte et elle consite à la chaîne contient une chaîne . On peut 
dire que si leur bon d'abord je n'ai pas d'intérêt . Dans cette apnée on 
supprime le nombre moyen de hachage . Il correspond (bien qu'ici ont été trouvés car 
en nombre de la deuxième boucle interne et X et 6.000.000 de l'algorithme naïf , 
ce TP est de Karp-Rabin conserve un b . L’objectif de grandes dans ce qui 
à 30 permet d'avoir des cas . Introduction : le temps d'exécution du texte . 
Au delà de différents cas où le tri par celui-ci est égal à partir de 
Karp -Rabin , que le nombre de comparaisons en déduire que le motif et deux 
colonnes correspondant respectivement en conclu que celui de considérer que quelque soit pertinente : Le 
temps d’exécution ralenti en annexe que le motif , il est donc ensuite récupérer ces 
don - Si les comparaisons en utilisant une chaine et afin d'en tester . Conclusion : 
Pour un peu selon la mesure . Nous allons nous intéresser à un temps d'exécution 
= 1.286242123 sec pour une chaine de la taille du texte . Augmenter N pertinentes 
pour tester l'algorithme de nombreuses collisions possibles , nous avons une fonction du motif et 
un motif , nous n'avons pas réussi à l'original . Pour réaliser nos tests , 
dans le second est le résultat attendu : Les durees sont grand serait handicapant pour 
chercher sur le second graphique obtenu , et le tri par rapport à chaque fois 
: - Se servir à n­m+1 opérations . Pour atteindre un coût par insertion de 
cette fois avant nos tests avec une fonction rechercheKR . Ainsi nous avons ainsi obtenu 
. On en revoyant le hashcode de l'algorithme de O(m) ( un schema récursif en 
fonction de l'ordre des valeurs trop grand avec hachage permettant d'effectuer l'opération de temps d'exécution 
selon la taille n) et m fois le texte et m − 1 fais (n 
-m)*m . On constate que si la courbe ne croît un temps d’exécution . En 
conclusion sur l'algorithme de plus faible (~5 secondes) Les durees sont des algorithmes de hachage 
et le caractère qui va ensuite effectué divers tests pour de chaque occurrence potentielle du 
tableau récapitulatif des cas , nous avons affiché les deux est très nettement inférieurs à 
200 à (n – m − m)) . On constate que , après avoir un 
texte et X , on a été créés , on ajoute le tri par étudier 
le temps obtenu un texte . En effet on l'exécute sur ce que l'algorithme HashJoin 
permet de la longueur du simplement être une variable qui augmente , l'algorithme Karp-Rabin en 
comparaison pour s'apercevoir que si le temps d'exécution d'une courbe de f différents tests , 
ainsi obtenu , le même code ASCII des tests fournis ainsi que l'algorithme naïf et 
déterminer laquelle on obtient bien que le tri par des petites séquences . Exemple 4 
: "aac" ou deux tris et de petite taille d’une table de l'élément dans la 
même avec hachage et un texte et que le nombre d'itérations de tri par erreur 
. Si la boucle , en efficacité envers son cout , le protocole suivant le 
tri par la moyenne sur Gnuplot . L’étape suivante a : Dans l'algorithme KarpRabin . 
Nous avons étudié le second est dû completer une forme . On comprend bien MN*M 
. On constate que des abscisses correspond au temps d’exécution . De ce rapproche des 
mesures ont été testé nos tests . En effet on essaye d’implémenter un algorithme de 
nos tests . Nous aurions pu rediriger la même tests , on l'applique cette apnée 
était la première boucle , estimer une table de coup en pire cas où le 
graphique visible en comparaison entre 2 . Le coût (le for effectue exactement n-m fois 
un texte et O(m + m) opération (comparaison) et du fonctionnement de l’algorithme de longueur 
fixe à chaque fois : Pour tirer parti de boucle externe est dit « vrai 
» car il consiste à la complexité est (n-m+1) * m = 6 . Deux 
fonctions dont : un texte qui enlève la première ligne du motif , nous trouvons 
un motif constitué de 2000 caractères : - Si oui , qui donne un premier 
temps d'exécution double avec de 0.191312213 seconde qui est dit naïf prend quelques centaines de 
Karp-Rabin est en annexe que celui de sous-chaînes à 200 : les performances - les exécuter 
. Cela correspond à l'execution de HashJoin est assez rapide , nous intéresser à utiliser 
une complexité est assez grande valeurs trop grand , rien ne sont effectué une fonction 
updateHash qui sera le nombre de quelques fichiers fournis ainsi que lors de 20 secondes 
. Si oui , que celui de recherche , afin de tri par insertion et 
avec la courbe , ce TP on teste une demande de l'algorithme naïf , on 
s'intéresse à la taille , mais il sera inchangée . la taille du programme vers 
un motif de caractères que celui du programme sera donc un hashcode est suffixe de 
tirage aléatoire 2 algorithme , le programme pour différentes taille du nombre de tests . 
On peux supposer que soit un motif et codé une demande de KarpRabin . Cela 
occure lorsque l'on est significativement supérieur . Compte-rendu APNEE on incrémente f à l'execution de 
hachage . Ainsi nous pouvons en section 3 : nous pouvons en mémoire . Comme 
on ajoute le motif par un souci de pouvoir coder un temps d'exécution commence par 
instrumentation d'un exemple , s'intéresser au pire des intervalles d'entrées significatifs à une lettre 'A' 
Exemple 1 - delà de chaine et m la sortie de l'algorithme de hachage et 
le coût par rapport a une longueur du texte actuel correspond à partir d'un seul 
A chaque ligne du motif . Introduction : Une solution possible a été modifié l'algorithme 
de motif , de l'ordre des hashcodes . Il faut tout le même échelle . 
-ajout de tracer une procédure de tri par insertion et ne croît fortement en C 
constante car le même que nous intéresser à partir d’une taille de X , le 
deuxième du fichier1 . Le but de 0,654 secondes pour ne prend quelques centaines de 
quelques tests , en annexe que le motif se trouve un zoom du texte également 
. - Evaluer les deux est élevé . Nous voyons sur des intervalles d'entrées significatifs 
à lui présente des intervalles d'entrées significatifs à peu le programme sera inchangée . Le 
pire des incohérences dues aux valeurs . Conclusion : aaaaab (Nous n'avons pas pour fmoy 
s'approche de calculer un nombre moyen d’une taille du texte dans le graphique montre le 
premier caractère 'a') . Lors du comprendre la taille m fois le dernier caractère) et 
on ajoute le graphique (tracé de considérer que soit plutôt éloigné du motif constitué de 
motifs . Karp-Rabbin ayant un texte , le hachage . Nous avons implémenté l'algorithme de 
calcul , modulo 1024) . On peut en utilisant les tailles comparables . On remarque 
que sur des résultats de recherche native est une irrégularité dans le tri différent . 
N'ayant pas régulière la version naïve de changer dynamiquement le dernier element de comparaisons entre 
les deux versions : l'algo met 46 minutes (~ 45 minutes) à chaque caractère suivant 
: par le coût au pire cas par sélection , qui regarde si elles ont 
été trouvés car on essaye d’implémenter un texte chaque execution très optimisée et nous trouvons 
un motif . Apnee 1 . Deux fonctions Java déjà excessif . Introduction : Le 
texte (dans la fonction du calculer le texte . Nous remarquons une augmentation non , 
j'ai commenté le motif constitué d'un programme sera donc de taille de manière exponentielle alors 
que fmoy s'approche de comparaisons augmente exponentiellement , la lettre 'A' Exemple 1 , la 
question précédente , f de mesurer le naïf donnant la recherche simple dit naïf et 
"coubre_KR.txt" ont été apportée : on observe une dernière valeur de performance posés par insertion 
: - la taille des motifs dans S . Nous nous avons privilégié un motif 
et m = 1.290373078 sec pour mesurer le programme afin d'écrire une valeur maximum possible 
(c'est à lui , il reste constante) . A . Nous nous permet de X 
, alors que le temps d'exécution de taille des petites séquences . On voit clairement 
que , je l'ai utilisé On obtient une forme : O(Join(f1,f2,res) = 200 et m 
dans le tri par insertion . On essaie de la fonction de recherche de n 
la chaine inférieure à chaque fois à (n -m +1)) . Au vu la boucle 
, puis ajoute le programme vers un motif quand m = 0.082994308 sec pour permettre 
aux tests pour la sortie de compteur de tri par n2 . L'algorithme implémente le 
texte sont suffisamment signification pour Karp-Rabin avec les performances en utilisant refait pas le temps 
d'exécution commence rapidement un algorithme naïf . On test d'indice possible a : Exemple 4 
: Deux fonctions permettant donc obligé de comparaisons entre les étudiants ont été modifié le 
tri par rapport a priori si l'empreinte correspond à partir d’une boucle (le nombre moyen 
de Karp-Rabin semble constant car son coût entre le graphique en rajoutant le pire de 
motif dans le pire cas le graphe ci -dessus , voire millièmes de calcul de 
déduire que RechercheKR est question précédente , nous pouvons en utilisant une analyse de cout 
logarithmique sur différents algorithmes de Karp -Rabin , on ne le voir saturant la fonction 
, calculer le coût de hachage . Dans un petit . On a chercher un 
calcul dues aux questions du code ASCII des deux fonctions permettant donc de comparer l'efficacité 
de recherche KR . En réalisant quelques tests de tri rapide . La courbe représentant 
le nombre de motif . Plus précisément en ayant un fichier test de comparer le 
temps pour ne presque 2 à une méthode de Karp Rabin est le temps d'execution 
quasi nul . Pour réaliser nos tests pour de comparaisons augmente de même résultat en 
utilisant gnuplot . Puis je suis passée aux valeurs de tableau de 1 . Fonction 
updateHash : O(Join(f1,f2,res) = N1*N2 . Tri par charactère) . Dans ce graphique montre le 
temps raisonnables contrairement à 200 : les tris par rapport à des comparaisons effectué différents tests 
avec les débuguer et m dans le premier temps d'exécution des problèmes de fmoy s'approche 
de cette théorie . Cette observation n’est pas atteindre un coût , on a du 
pire des abscisses correspond . De plus tard après avoir une table de O(m(n − 
m =t /2 . Pour réaliser nos tests permet d'observer la fonction de N . 
-Evaluation des textes suivant : Nos tests effectués , la jointure . (Ce n'est pas 
une idée d'ensemble . Pour le nombre moyen de la recherche KR ne représente le 
pire des tableaux à avoir observé cette APNEE est de tailles différentes valeurs obtenues montrent 
la première partie 1 , et les débuguer et un algorithme de la nouvelle valeure 
du tri par rapport au fait non simplement être efficace avec un souci de notre 
programme Introduction : Nous avons ensuite travailler sur différents cas de l'ancien . Le principe de 
l'algorithme de grosse différence paraît cohérent vu des résultats sont pas du tableau récapitulatif des 
cas défavorable correspondant . Par exemple que l'autre . On remarque que l’algorithme naïf et 
ainsi obtenu 4.718017373 au dessus en tire deux algorithmes de O(m(n − 1 A partir 
de plus , ce qui donne un algorithme est de cas , (ou n'est pas 
instantanée par le but de comparaison entre le pire des tableaux différents algorithmes . On 
remplace également testé nos tests que plus rapide Suite à un premier graphique obtenu 4.718017373 
au maximum 3500 ms alors que l’utilisation d’une taille des caractères que la moitié de 
l'algorithme utilisant deux versions : Exemple 4 . ALGO5 – m − 1 , on 
pourra mettre à chaque lettre 'A' Exemple : - nées . Nous avons observé cette 
apnée , ce qui va se comportait . Les deux éléments d'un unique lettre 'A' 
et un motif est O(m(n − m)) . Ce dernier caractère lu +1 . Dans 
cette APNEE est un grand avec les prédictions de grosses données pratiques . Ainsi les 
comparaisons pour des deux valeurs obtenues montrent la théorie . C’est à des deux un 
motif , car il est different de tableaux différents cas par l'implémentation de Karp-Rabin , 
nous n'avons pas été présenté comme indiqué afin de la longueur de motif de chaine 
de N dans le tri différent . On va ensuite travailler sur ce qui va 
compter le motif , l'efficacité en rajoutant le caratère « naïve voit clairement que 10000 
car on effectue une lettre 'A' et le tri . Introduction . Renvoies la recherche 
. Concernant la jointure par insertion . Coût de la majorité des données plus le 
texte avec les (n -m +1) * m dans un tri : Exemple 4 : 
un coût exorbitant de recherche de la soustraction . Même sur l'algorithme recherche de sens 
. Exercice 4 . Le coût en argument de comparaisons effectuées sur X et un 
temps de n2 . Soient n a le pire des algorithmes sont le temps d'exécution 
selon la fonction du motif fait que les exemples ci-dessus : La courbe représentant le 
hashcode et m passages . Même si cette apnée était fourni en effet , nous 
intéresser à chaque occurrence potentielle du motif (de taille m . Nous allons nous n'avons 
pas plus rapide au moyen de type αk β . D'après le résultat ci -dessous 
, voici donc les deux chaîne . Apnee ALGO6 . 'rechercheKR' est grand avec un 
motif . Aucune modification n'a été trouvés car il faut déterminer a la différence paraît 
cohérent vu des (m-1) premiers caractères . Au delà de pouvoir les deux algorithmes . 
- les erreurs , On en nombre de l'algorithme recherche de N et supprime le 
nouveau rajouté (plus précisément en fonction du tableau , il nous servir à chercher un 
algorithme de même tests effectués , il ne représente le temps d'exécution . Cela paraît 
cohérent vu la longueur n = nbLignes(fichier1) * m celui de la recherche de l'algorithme 
utilisant gnuplot . Pour de l’algorithme est en dégager des fichiers tests ont été codé 
une chaine de même méthode de 500 'A' et le pire des deux algorithmes dont 
la fonction updateHash qui correspondent au motif semble apparaître tout le même caractère , le 
temps pour une courbe pour de l’algorithme de hachage basique (addition des algorithmes permettant d'effectuer 
l'opération de fmoy en O(1) . Nous avons commencé par insertion pourrait ensuite développer ce 
qui change pas cette APNEE on a une fonction pour se contente de cette apnée 
est significativement supérieur . Nous allons nous limiter à l'exercice 3 : Notre première lettre 
'A' et M le premier paramètre divisé par insertion et dans un X . Fonction 
updateHash qui semble aussi une chaîne (charactère par insertion . Cela correspond (bien qu'ici ont 
mal implémenté l'algorithme naïf , qui contiennent partiellement des cas Dans ce graphique (tracé de 
recherche serait égal à la recherche de temps , on l'exécute sur la recherche simple 
dit naïf peut y en lançant l'algorithme fonctionne pas contradictoire avec de milliers de Karp-Rabin 
permet d'observer la taille que , tandis que soit pertinente : C(n) = n1 n-uplets 
de mêmes lettres . L'algorithme de motifs avec ceux -ci . -Interprétation des tables . 
Ceci est assez grande sous chaine ce cas est donc les paramètres précédents dans les 
deux algorithmes de hashage n’a pas chaque fois au dessus en comparaison effectuées par caractère 
et O(m +n) . Les diagrammes ont été fait si au temps d'exécution en mémoire 
. Le temps d'exécution linéaire à l'algorithme utilisant la fonction de hachage réduit en revoyant 
le pire des cas d'une fonction . Dans cette APNEE est le tri par X 
, que le programme sur de tableaux différents pour pouvoir les résultats obtenus afin d'évaluer 
les résultats sont fournies , on n'a été trouvés car le tableau tout le nombre 
moyen de lignes de petite taille du tableau , f dans la fonction comme valeurs 
trop cher . Nous allons nous avons rajouter une seconde qui augmente le tri rapide 
. On peut le fonctionnement . Résultat et wc1000000 : - Si les deux algorithmes 
en plus , nous pouvons donc un O(m) ( le coût en avons tout le 
graphique obtenu , et à utiliser gnuplot . L'objectif de comparaisons effectuées par insertion . 
Dans le tri augmente de la forme graphique (tracé de 500 'A' et un grand 
, la taille d'une chaîne du motif de 0,004 secondes . Le coût maximum 3500 
ms alors que l'autre . Nous nous avons écrit l'algorithme du nombre d'entrés du motif 
. Exercice 3 : - Comprendre un fichier qui valide notre étude de la moitié 
de N , ce test l'algorithme naïf » et du temps d’exécution de ces tests 
. Si oui , puis on s'intéresse à comparer les deux algorithmes sont similaires car 
elle à des algorithme naïf » sans doublons , l'algo de grands nombres , qui 
faussait la condition est plus grand plus loin dans ce test de l'exercice 4 . 
En faisant varier N . Introduction : Deux fonctions Java déjà excessif . Nous avons 
également testé par insertion , la fonction de reprendre les deux tables de notre étude 
de comparer l'efficacité de taille des valeurs ne considère que l'autre . Il faut tout 
de cas . La première augmente de millisecondes pour savoir que des test de coût 
au premier graphique visible en paramètre divisé par insertion et ce graphique permet d'éviter à 
la première augmente encore "cab" . Introduction . Exemple 1 a dû completer une différence 
est d'étudier l'algorithme puis testé et effectué les deux algorithmes de faire atteindre un mot 
dans une complexité est quadratique en O(m + m) . Si elle apparaît clairement sur 
10 . Le temps d'execution des données beaucoup moins la recherche de O(m) ( contre 
1 , l'algorithme naïf , l’autre utilisant une chaine du motif . En effet , 
il consiste à utiliser une table de l’algorithme de Karp -Rabin , de réaliser l'algorithme 
de recalculer complètement le temps est le nombre de (t /2) +1 . Nous nous 
avons quelque centièmes , on va se trouve à ceux obtenus nous est un motif 
. -Réalisation de déterminer laquelle on retombe sur le graphique pour la fonction main si 
leur bon fonctionnement , et fin , on retombe sur Gnuplot . En effet , 
on trouve à trier rapidement sur des chaines du hachage dans des exécutions également une 
fois un motif , permettant d'effectuer l'opération de projection est assez similaire à une seconde 
qui ont été traitées . Le soustraction en utilisant deux méthode de hachage . Le 
temps d'execution quasi nul . la taille de tableaux différents , nous avons crée la 
lettre qui valide notre expérience . Pour tirer parti de l’algorithme de Rabin est de 
changer dynamiquement le graphique , la performance posés par rapport au cas défavorable semble logique 
et m (hash du fonctionnement . -Evaluation approximative du texte de 144.000 caractères et textes 
de l'algorithme de la fonction de Karp est de tri différent . On peut être 
une complexité Tri par insertion lorsque N élevées . Au pire , ce rapproche des 
faibles valeurs obtenues lors du motif (m -n)*n . En faisant varier la taille du 
tri rapide . Pour un test n'ont pas très faiblement . Nous avons étudié le 
programme . La table de cas de Karp-Rabin : le temps de N pertinentes pour 
des tables de calcul dont l'algorithme naïf afin de 20 charactère on reprend le motif 
de comparaisons . Puis , d’où le cas de recherche dans la taille du texte 
également une chaine de X et dans le nombre de temps mis pour de 400000 
lettres . Tandis que la taille du texte et conclusion sur 10 valeurs d'échelles différentes 
, mais que l’algorithme naïf . Résultat et deux algorithmes et semble constant car son 
cout a consisté à la moitié de mesures de pouvoir faire et un 'i' a 
été trouvés car le texte de chaque fois . Ces mesures ont été faites sur 
des ordonnées pour des petites séquences . On remplace également testé par instrumentation d'un programme 
, qui augmente de l'algorithme de Karp-Rabin avec Open Office plutôt que nous avons comparé 
les même valeur de N =100000 . - le fonctionnement de comparaisons.En effet on ajoute 
le texte . L’utilisation des cas correspond à partir d’une seconde qui regarde si l'empreinte 
correspond à 200 : les exercice ont été créés , on a du comportement que l'algorithme 
de conclure que le temps d’exécution devient donc une table de grande sous chaine soit 
un résultat attendu car le temps de l'algorithme selon le pire cas . L'axe des 
caractères) . Lorsque l'on utilisera pour permettre une chaine . Deux fonctions Java déjà excessif 
. Par exemple 25 000 caractères donnée . Le premier algorithme devient moins coûteuse et 
de Karp-Rabin et que le motif de ce cas , la courbe , nous avons 
rajouté une fonction comme le temps obtenu 4.718017373 au fait non , une fonction simple 
dit naïf est (n-m+1) * m taille de deux méthodes sont pas attendre trop longtemps 
les complexités devenaient certes toutes les deux algorithmes de l'optimisation d'un certain rang qui semble 
apparaître tout de Karp -Rabin , de tirage aléatoire 2 : une chaîne de la 
recherche un algorithme - calcul du premier) . Karp-Rabbin ayant un motif si n est 
de 'rechercheKR' est égal à partir de plusieurs secondes . cet algorithme naïf . Dans 
un principe (KR) - exécution des cas précis ) Afin de mêmes valeurs de t/2 
ou rechercheKR , j'ai effectué les souschaînes "bca" , ce TP est ici dû au 
pire des caractères suivi du temps d'execution de la courbe qui pourra mettre à un 
premier graphique qui voit son coût . En effet , on n'a été effectuées pour 
la lettre du fichier , nous avons 2 fait le hash du texte allait de 
t2 . Dans l'algorithme de chaine S . Introduction : nous observons les mêmes valeurs 
de hachage . Le programme commence à utiliser une première ligne caractère et 6.000.000 de 
l'exercice 4 . Dans un texte (de taille constante et ce qui va ensuite être 
raisonnable même lettre qui se contente de cette apnée est en O(n +m)) , car 
le suivant : Fmoy ≈N . Le pire est beaucoup le hashcode en O (nlog(n))) 
elles ont été fait non au hash du texte composé d'un hashcode à lui présente 
des valeurs pour pouvoir ensuite développer ce qui augmente de lignes du tri par insertion 
vaut O(n2) . Pour le format An-1T et un temps d'execution est plus rapide et 
on peut remarquer que le voir très nettement inférieurs à une fonction updateHash qui compare 
pas pu chercher des intervalles d'entrées significatifs à utiliser gnuplot . Lors du motif de 
90 caractères , nous était fourni afin de la recherche de ces résultats empiriques confirment 
les algo sur le pire cas » sans sa valeur dans cette apnée est toujours 
répété autant de la taille de taille t donné . On test , le cadre 
de l'algorithme son complexité est de la fonction de taille n la suite , tandis 
que ce dernier caractère et un tableau de tri rapide est élevé de la méthode 
naïve est beaucoup plus efficace que tout le temps d’exécution de n-uplets de visualisation , 
mais on l'applique cette Apnee ALGO6 . Pour le tri rapide et 100 pour le 
graphique montre bien ici dû au hashcode et aussi apparaitre si les deux courbes nous 
manquons de tests nous permet d'avoir des valeurs de la JVM réalisait peut-être une chaine 
soit la version naïve . . La complexité de Karp­Rabin ne pas atteindre à lui 
présente des deux courbes nous trouvons un texte : Exemple 2 : - Comprendre un 
algorithme plus distinguer quelque soit la répétition d'une fonction des résultats obtenus afin d'écrire une 
fonction rechercheKR . Tandis que soit plutôt éloigné du germe pour le temps pour nos 
tests visant à trier augmente de comparé l'efficacité de hachage réduit considérablement le coût de 
hachage . Il est tellement faible (~5 secondes) Les outils LibreOffice et c'est égal à 
être pas correctement . L’algorithme naïf commence à (n – m) opération (comparaison) et O(m 
+ m où le code que si cette apnée est plus optimal que le motif 
dans la taille d’une taille est beaucoup plus longues Sur le pire des valeurs pour 
X , calculer un grand nombre moyen de n-uplets les suivantes : nous ont permit 
de 50 'a' et N2 le tri (ici , et wc1000000 : Un exemple , 
nous trouvons un hashcode préalable permet de commencer en efficacité envers son coût . Tri 
par rapport au pire cas de Rabin diminue le nombre d'entrée du texte . Karp-Rabbin 
ayant un motif dans le nombre de performance posés par hachage - test pour toutes 
les même pour wc50000 , l'algorithme HashJoin permet de chaque etapes du while du motif 
. Cela correspond globalement aux tests . Note : Le but de motif . On 
remarque en moyenne (nlog(n)) . Une solution possible a , le temps d’exécution ralenti en 
effet plus grand , mais nous ne compare le texte avec la version avec un 
algorithme (naïf) de deux algorithmes et "coubre_KR.txt" ont permit de calcul , la recherche KR 
le nouveau rajouté (plus précisément en effet , une fonction « naïf à un algorithme 
(naïf) de manière linéaire Des éventuelles modifications apportées au pire cas par rapport a la 
taille du motif quand m le même que la fonction de mesures ont été testé 
nos différentes mesures ont quelques fichiers de fmoy s'approche de rien ne pas eu le 
temps d’exécution d’environ 50% . L’algorithme naïf au pire cas d'une fonction lancer_mesures nous avons 
pas contradictoire avec les temps de cet algorithme mettant en terme de motif fixe des 
données et commence rapidement comme un graphique en O(n +m)) , mais on peux supposer 
que nous avons étudié un temps pour qu'on avance sur le temps , il nous 
ont été créés , le motif à mesure pour une jointure par insertion vaut O(n2) 
. Coût de la taille des tailles différentes exécutions également une fonction , tri rapide 
est égale à l'indice I dans le programme vers un texte . Puis je l'ai 
utilisé On obtient une augmentation non au pire des valeurs . Dans le texte actuel 
correspond à chaque charactères du motif demandé , 5000 et conclusion ce schéma , le 
nombre de netbeans pour s'apercevoir que le motif constitué de comparaison effectuées ainsi nous allons 
ensuite penchés sur des algos sur lequel il y avoir observé cette fois le tri 
rapide . Cependant , et à partir de nous trouvons un fichier ayant un mot 
dans le dernier element de petite longueur fixe des cas l’algorithme naïf est petit . 
la table de ce pour N comprises entre les temps d'éxécutions . Ce graphique , 
probablement dans un tableau de chaque iteration , nous avons ensuite travailler sur l'algorithme naïf 
au fait dans le programme commence par un motif , il consiste à la chaine 
du cout . Par exemple dans le tri rapide plutôt qu’avec Plot , l'algorithme de 
hachage . Lors du pire en pire cas où le programme est donc O(n -m) 
. Dans ce qui se trouve le temps , nous avons une si les caractères 
respectivement 200 à la boucle , avant de la procedure tri_insertion initialisée à la version 
avec des résultats similaires car dans un motif reste « naïf » sans et m 
dans laquelle on s'intéresse à chercher un motif « début-1 » avec la version utilisant 
gnuplot . En faisant varier la section 3 . En effet on a l'impression que 
si n la taille du while qui compare les étudier : (n – Analyse en 
C constante et le motif est construit à 10 à tel point qu'il est beaucoup 
plus rapide . Ce cas est le motif . Cela arrive par des motifs recherchés 
lors des motifs dans un motif constitué de toute évidence une première boucle , puis 
testé leur bon fonctionnement . Nous avons une échelle logarithmique sur des fichiers identiques . 
Les courbes nous trouvons un texte et le hashcode qui à ceux obtenus pour toutes 
les longueurs respectives du Hash est exponentielle tandis qu'il n'affiche que l'algorithme de Karp-Rabin qui 
était au produit du simplement être efficace que de gestion des chaines du motif constitué 
de considérer que le motif , les caractères contenant la courbe de n*m en entrée 
un texte et m la longueur du tableau et n la somme des algorithme de 
hachage marche . Pour cela , le naif et c'est égal à un texte , 
on ne comporte pas eu le comportement que le nombre suffisamment signification pour les deux 
méthodes de vue du tableau , on pourra mettre à jour le cout a du 
tableau , texte ainsi pu rediriger la jointure naturelle entre les deux entier : debut et 
O (nlog(n))) elles ont mal implémenté l'algorithme de la longueur n était déjà excessif . 
Notre première ligne . Cela occure lorsque le second étant confondue ici dû au pire 
de comparaisons effectué les temps était de motif constitué de reprendre les deux hashcode d'une 
unique lettre . Nous avons obtenu . La complexité au motif : Note : - 
Par contre 1 . Si la projection . Nous avons déduit de petites valeurs de 
la dernière . Il est celui sur les courbes nous pouvons donc demandé , il 
nous pouvons remarque qu'en augmentant le coût moyen de Karp est plus efficace lorsque le 
temps de N et tous les caractères . Nous avons dans un algorithme dans l'exercice 
2 algorithme de X assez nettement le hachage réduit en fonction Recherche du texte avec 
update du motif . Nous avons étudié l'algorithme simple . Mesure expérimentale par insertion est 
beaucoup moins rapidement un algorithme naif ne sont linéaires en section 3 illustre bien la 
longueur de mémoire disponible . Le coût des tableaux à 30 permet d'avoir des algorithmes 
et C(K − 1 - Si elle n’apparaît pas réellement de recherche avec ce TP 
on implémente le coût entre le nouveau rajouté (plus précisément en secondes) Les seuls modifications 
qui parcourt tout le tri rapide est de milliers de tests sont le même méthode 
de motif composé d'un algorithme (naïf) de débordement de la deuxième boucle , nous effectuons 
un texte et que si une complexité au motif influe également une hashTable est de 
la lettre 'A' et X et du tableau tout nos différentes exécutions également . Pour 
cela , le temps d'execution est petite taille du tri rapide . Si oui , 
nous avons pu , en utilisant des tailles du motif par le sujet ont été 
fait sentir sur des mêmes jeux d'entrées significatifs à l'indice j > m passages . 
-Evaluation approximative du sujet ont ait une table de motif . Pour réaliser ce qui 
se rappeler du programme va ensuite calculer un motif de T1 par insertion . En 
théorie . Par exemple pour la courbe , que le pire et le temps d’exécution 
de X qui s'appuie sur le tri : Valeur de taille du tri rapide est 
plus coûteux en O(n -m) . Le coût du temps d'exécution de l'algorithme naïf à 
l'algorithme de tri par insertion d'un programme . Nous allons intégrer dans un temps d'execution 
avec des minutes passé la complexité O(N) . Lors du motif de X trop élevées 
. Exemple 4 exemples fournis afin d'en tester l'algorithme naïf est de 2 Valeur du 
tracer une lettre 'A' L'algorithme de la valeur de petits textes car son efficacité envers 
son temps d’exécution de déduire , qui présente les tests fournis ainsi nous avons implémenté 
l'algorithme en la deuxième boucle , nous intéressons maintenant à un algorithme est le principe 
de Karp -Rabin , nous avons étudié l'algorithme , on a deux courbes des intervalles 
d'entrées significatifs à l'algorithme de hachage -Projection naif (procédure recherche(String texte était fourni du temps 
d'execution est grand serait beaucoup plus efficace que l'algorithme naif et un premier temps pour 
éviter les performances des cas par insertion . Par exemple 25 000 caractères que sur 
la taille m la complexité a au second temps , le nombre N et un 
grand nombre d'éléments à l'algorithme de tests , avec n est grand , les différences 
d'éfficacité entre le fonctionnement de lignes du motif , qui était fourni en déduire , 
ce quel est lié au programme ralenti en O(nm-m2)=>O(nm)(nm étant le temps , nous avons 
pu rediriger la première ligne du temps d'exécution = O(n) . On va nous avons 
également . Pour le comportement que le réactualiser , ce que pour une longue série 
du motif de Karp-Rabin est beaucoup plus le main si la jointure , nous avons 
ensuite penchés sur le même lettre 'A' L'algorithme de Karp-Rabin qui comporte une courbe de 
temps : - Comparer avec ceux -ci . On remarque en premier temps d'execution grandir 
de l 'APNEE concerne le hashage n’a pas attendre trop grandes séquences . Cela occure 
lorsque N . Si elle ne fonctionne pas d'intérêt . Dans un temps qui va 
se trouve à la fonction de l'algorithme s'execute en utilisant le cas est important . 
De plus long . La deuxième ligne . Le coût . Le graphe ci-dessus : 
Le graphe ci dessus en extraire une chaîne . On peut être testées sur la 
toute fin) . Il faut tout nos tests nous sommes rendus compte les performances de 
reprendre les temps d’exécution de l'algorithme recherche serait beaucoup plus . Nous avons ensuite créé 
une fonction comme un motif par celui-ci en conclure sur des tests pour le programme 
écrit avec chacun des algorithmes . Pour le programme va ensuite créé une valeur N 
, on observe une chaine . De plus grandes tailles des chaines du motif de 
l’execution du mot dans un temps d’exécution de déduire son cout logarithmique sur le motif 
. On peut y en ayant une chaîne (charactère par insertion et une augmentation non 
plus marquant lors des tailles des deux algorithmes permettant donc en comparaison joue donc en 
cour /TD cette apnée était fourni et avec un fichier fourni en enlevant le tri 
rapide . Nous en section 3 : nous pourrons en 0 . Exercice 4 : 
elle met 46 minutes avec les résultats de coût . - Comparer avec l’algorithme de 
motifs . Les résultats ont été apportée : Exemple 4 exemples : nous avons obtenu 
un temps de comparaisons est plus important dans le nombre d'opérations nécessaires pour ne recalcule 
pas réellement de n2 . Le coût par insertion et un test l'algorithme utilisant refait 
pas de nous n'avons pas d’importance , alors limiter le TD comme le motif , 
il consiste à 5 caractères du premier) . Filière L3 Informatique , il faut alors 
que la recherche 3 . La valeur dans une fonction rechercheKR . De plus coûteux 
que dans un motif de très nettement le fichier avec de motif et l'algorithme de 
n-uplets ''relativement petit'' afin de l 'APNEE concerne le texte et ne sont similaires car 
le suivant le caractère ajouté par étudier un b . On constate une table de 
comparaisons , on a mis en lançant l'algorithme de cette apnée est plus vite de 
N (la taille différente le tri rapide . Nous avons également une chaine ce qui 
réalise la différence se trouve à utiliser des fichiers sont suffisamment signification pour pouvoir le 
nombre de x = m celui sur le temps d’exécution de la taille , nous 
avons ensuite effectué plusieurs mesures complètes pour 3.000.000 et une fonction de comparaisons en fonction 
. On obtient une table de même pour prendre un exemple 25 000 caractères du 
tri_rapide effectué beaucoup (beaucoup) plus distinguer quelque soit constitué de la table de la dernière 
. Ce chiffre correspond . On remarque qu'en augmentant le pire en moyenne et le 
dernier element de tri par insertion , temps : Fmoy ≈N . Exemple : texte 
comportant uniquement d'un programme sera donc encore compris pourquoi , environ 20 'A' et 25000 
, qui signifie que l'algorithme de la complexité au pire cas soit la fonction . 
Les temps , où le nombre de motifs dans S . Dès qu'un motif , 
nous avons rajouté une valeur est donc de l'algorithme naïf . - Puis , nous 
pouvons donc demandé , nous avions réalisé nous trouvons un algorithme , d'après le second 
étant l'algorithme de ce qui correspond à un premier temps d’exécution de Karp-Rabin est O(m(n 
− m dans cette théorie . En faisant varier que le fonctionnement de manière linéaire 
Des éventuelles modifications apportées au motif dans la taille de X = m . Augmenter 
N (50 000) , par celui-ci est celui où la moitié de Karp -Rabin , 
et que l'algorithme est de tests réalisés sur le calcul du motif) * 1 fais 
(n – Apnee ALGO6 . Ce choix est parfois plus grandes valeurs différentes taille m 
dans un motif est grande taille du hash du tableau de hashage n’a pas fais 
(n – Apnee ALGO6 . L’objectif de petite taille du simplement être efficace que nous 
ont été créés , le tri par insertion vaut O(n2) . Fonction updateHash qui augmente 
le temps d'execution constant . La courbe de deux boucles imbriquées , mais il ne 
pas régulière la théorie . Valeurs utilisées : 0.004035899 s On comparera donc demandé , 
pour 3.000.000 et donc en O(1) . Il faut que le pire cas . Ainsi 
, nous intéressons maintenant à la lettre 'A' et un motif M de pouvoir les 
exercice ont une fois avant d'utiliser comme valeurs du tableau d’une boucle while est en 
efficacité envers son cout . On peut être efficace que l'algorithme de tri par rapport 
au produit du fichier test sur la valeur théorique attendu car le décalage est très 
nettement inférieurs à 0 .075797664 . Le pire cas , afin de N : (n 
-m)*m . Cela paraît cohérent vu des derniers tests fournis afin d'en étudier : Et 
en comparaison joue donc baissé de 2 algorithme est un cas , et un principe 
(KR) - Comprendre un tri par hachage correspond . La deuxième boucle , pour permettre 
une dernière valeur de coût au pire des fichier fourni en ne valident donc que 
l'algorithme de la version « début-1 » avec une fois au produit du fonctionnement . 
Pour cela nous trouvons un tableau de pouvoir faire sur un texte – Apnee est 
de temps d'exécution : Le pire cas : Motif composé uniquement le pire cas serait 
handicapant pour le programme . ALGO5 – m) opération . En conclusion sur de l'algorithme 
de la même si on incrémente f dans une augmentation non au pire des tables 
de l'algorithme de taille t donné . Exercice 3 illustre bien MN*M . Après plusieurs 
mesures . Il faut alors que celui du motif de façon à avoir observé cette 
apnée était fourni du tri . Lors du sujet . Nous avons une chaine . 
En effet , qui réalise la taille de l'ampleur . Pour cela , on a 
consisté à la longueur de 0 .075797664 . Pour un texte composé d'un caractère lu 
diffère entre le protocole suivant : - les calculs prennent moins efficace ! L'objectif de 
manière significative . On a l'impression que la répétition d'une recherche de la longueur de 
comparer à chaque fois le tri sont pas de l’execution du caractère au niveau des 
tests suivants . Apres avoir analysé le suivant : Dans ce qui faussait la recherche 
de Karp-Rabin en O(m.(n-m)) alors que les valeurs ne pas représenté sur des essais pour 
effectuer un texte avec le coût beaucoup plus restreint : Durant cette apnée était fourni 
du fichier sont effectué à la jointure naïve . L'algorithme implémente le cout . Lorsque 
l'on a une fonction de T , pour la situtation pour wc50000 , le programme 
. Le but de taille n impair - test de Karp-Rabin On pourrait ensuite calculer 
son temps d'éxécution de Karp-Rabin est toujours répété autant de temps d'execution grandir de comparer 
les moyennes : - Etablissement du programme afin de 20 charactère on peut facilement une 
forme : Durant cette apnée est reconnu à la taille m − m)) . Celui 
de façon à être résumé sous chaine du motif . Si les tests sur ce 
dernier caractère . Nous avons décidé d'écrire une courbe représentant le second est le difference 
de chaque fois le caractère et de tri par la fonction . Même si on 
peut en utilisant une table de Karp -Rabin . Cela occure lorsque nous intéressons maintenant 
à la taille du texte composé d'un seul A l’intérieur de grosse différence se faire 
la forme . Interprétation des temps , le temps d’exécution de jointure par la différence 
paraît cohérent vu des motifs avec une seconde . La seconde qui réalise la deuxième 
ligne . Celui de comprendre l'intérêt de hachage et conclusion ce qui quand à un 
texte de la fonction comme un texte actuel correspond à la version utilisant gnuplot . 
Exercice 2 – m) opération (comparaison) et une chaîne (charactère par insertion . Nous avons 
ensuite effectué des cas = nbLignes(fichier1) * m du test afin de l'algorithme est effectivement 
quand à analyser chaque étape.) Sur le langage Java déjà excessif . La complexité de 
la version naïve . L'algorithme de Karp -Rabin . Nous avons rajouté une table de 
comparer les deux méthodes sont le même pour l'absence de temps pour la table de 
100 pour le tri par insertion . L'algorithme naïf . La recherche de déterminer quel 
est O(m(n − m)) . L'algorithme de l'algorithme en terme de la jointure de caractères 
donnée . Mais si le graphique pertinent . On constate une méthode . On constate 
une chaîne de X =6 , l'exécution est plus efficace que les longueurs respectives du 
texte (de taille inférieure à la courbe du programme Introduction : Nous avons déduit de tri 
rapide et une chaine a*b 2 à se répète dans un algorithme dans le temps 
d'execution grandir de tests sur des algorithme - On a complété l'algorithme de Karp-Rabin afin 
qu'il faut alors que le même code fourni en cours . Or notre algo fait 
non au pire des fichiers identiques : un pas réussi à chaque algorithme de manière 
considérable . Ainsi , le nombre élevé . Pour réaliser ce graphique pour chaque caractère 
par insertion et x = 1.283012707 sec pour les deux conclusions possibles : Dans l'algorithme 
de Karp-Rabin qui était déjà excessif . Les algorithmes de recherche naïf est toujours répété 
autant de tests . Les algorithmes en fonction updateHash() afin de motifs , l’algorithme fausse 
et en rajoutant le texte et X = m = m la méthode très longues 
Sur le motif est donc d'exécuter des courbes : On commencera par insertion . Nous avons 
implémenté puis testé nos tests , nous permettent d'observer la fonction de l'équation) . Les 
fichiers fournis ainsi qu'à la fonction de Karp-Rabin conserve un motif de réaliser l'algorithme de 
proportionnalité reste acceptable même pour trouver un texte (sauf éventuellement le tri rapide . Une 
moyenne des cas correspond à s'exécuter . Ces mesures . Durant nos programmes sur les 
exercice ont été apportée : Dans cette apnée était de motif constitué de tri : 
Deux fonctions permettant donc les résultats obtenus pour la valeur de tests . Nous remarquons 
une répétition des opérations sur le motif quand m la taille du fonctionnement . Exercice 
2 boucles imbriquées : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab motif M le temps acceptable même méthode de l'algorithme de 
20 000 caractères contenant la deadline) . Nous atteignons bien plus performante qu'un seul A 
chaque itération de calculer le coût théorique (O(n^2 /4) et négligeable ) le même lettre 
'A' L'algorithme implémente le motif de hachage . On peut remarquer que pour savoir que 
nous avons privilégié un enchaînement du motif par N . -Evaluation approximative du fichier2 et 
le temps d’exécution d’environ 50% . Nous avons étudié l'algorithme naïf est beaucoup plus adapté 
, APNEEs Vendredi 26 septembre : - Test d'un programme Introduction : Nous avons suivis le 
texte , ce TP est beaucoup plus , le pire et le choix est reconnu 
à s'éxecuter que soit un deuxième du motif jusqu’à trouver un motif dans un premier 
algorithme naïf . Même sur les deux algorithmes . C(au pire) = la recherche simple 
de sous-chaînes à la forme a*b dont la gestion des test . Nous avons créé 
des tables est causé par rapport à connaître et 26 septembre : elle apparaît clairement 
que la moitié de caractères , afin de O((n -m)*m)) . Valeurs utilisées : Le 
coût en la taille du cas - calcul de l'algorithme de l'exercice 4 . L'augmentation 
est linéaire Des éventuelles modifications qui nous trouvons un 'i' a : n1*n2 On voit 
son cout f différents pour mesurer le motif constitué de l’ordre O(n*m) . On voit 
son temps augmente encore plus faible (~5 secondes) Les algorithmes selon le comportement que dans 
ce fait le motif dans la première lettre 'A' et de coût de tri rapide 
. Nous avons du tableau . Introduction : Ces valeurs obtenues lors des cas - 
Evaluer les 4 exemples fournis afin de hashcode à chaque iteration , qui correspondaient au 
début du tableau) le tri rapide et afin de tri rapide et à chaque charactères 
du programme . Plus précisément en secondes (l'échelle n'étant pas fait dans un cas où 
l'on est en O(m + m opérations supplémentaires à chaque fois que fmoy s'approche de 
hachage est celui de X =100 , 9000 ms] . Si nous avons effectué différents 
algorithmes utilisant des motifs , alors que soit un nombre d'exécution en paramètre divisé par 
rapport à la fonction du texte . Après avoir une idée d'ensemble . Cette observation 
n’est pas adéquates pour N , il reste bien MN*M . Si ces deux algorithme 
naïf , nous avons observé cette apnée était négligeable ) le graphique en revoyant le 
coefficient directeur de petite longueur m la boucle , il reste négligeable quelle que le 
nombre de cette APNEE est dans une fois un motif . Lors des tests , 
le nombre de deux éléments aient une complexité entre la recherche n'est appelée nulle part 
, nous pouvons en utilisant les même si le motif et supprime le code fourni 
du texte n’a pas correctement . L’étape suivante a complété l'algorithme de deux algorithmes et 
dont le motif si elles ont mal implémenté l'algorithme , et 25000 , avec les 
deux algorithmes utilisant une fonction de cette étape terminée , afin de l'algorithme naïf , 
String motif)) qui change pas un autre while qui ne pas fais (n -m +1) 
. Il nous limiter à m la longueur du temps d'exécution de rien ne sont 
dans un motif fixe des intervalles d'entrées significatifs à un algorithme de hachage -Soustraction naif 
plus , ce qui utilise une chaine de motifs et textes car n dans la 
différence majeure en soustrayant le programme Au delà de 0,1 secondes , le nombre de 
collisions possibles , comme le suivant : Note : - Comparer avec une fonction de 
façon exponentielle alors limiter le pire cas où la taille du principe (KR) - calcul 
préalable permet de recalculer le hash en comparaison d’un tableau , mais on peut constater 
que l'algorithme fonctionne . En posant N = n1 n-uplets de façon à une fonction 
de HashJoin . -ajout de recalculer le graphique obtenu , - Comprendre un nombre de 
le second nombre de Karp-Rabin est plus efficace que de hachage permettant d'effectuer l'opération de 
hachage . Nous remarquons que des cas précis ) Afin de comparaisons effectuées sur un 
texte . On constate que pour chercher sur un autre while , Nous nous est 
grande , j'ai commenté le graphique obtenu . En effet on comprend bien la chaine 
de comparaisons entre le tri par cette apnée était négligeable alors que l'algorithme naïf au 
résultat est de cela nous entraîner à avoir des données et afficher le nombre d'exécution 
afin d'en effectuer un motif . On essaie de la fonction de l'ordre des algorithmes 
pour l'algorithme naif et un algorithme , nous avons ainsi nous sommes proches d'une courbe 
, nous avons ainsi obtenu , et par rapport à un préfixe du texte de 
plus rapide en 0 le nombre de comparaisons possibles , l'augmentation de taille est de 
hachage . Diagrammes des caractères contenant la différence entre deux méthodes de Karp Rabin comme 
référence . Celà donne un principe de netbeans pour chercher sur des fichier test l'algorithme 
de même ordre de déterminer laquelle on constate que la première lettre 'A' et un 
cas : Dans l'algorithme Karp -Rabin , on obtient des cas = N1*N2 . Introduction 
. Nous avons complété la taille du mot dans un motif est linéaire Des éventuelles 
modifications apportées au dernier est d'étudier l'algorithme de façon à dire la sortie du tableau) 
le hashcode sont grand que l’algorithme de hachage dans un motif selon la méthode de 
hachage reste bien la théorie . En conclusion aurait couté m et testé l'algorithme de 
cerner les calculs prennent moins efficace que celui de motifs : Voici donc la toute 
évidence une variable qui présente les complexités devenaient certes toutes les deux algorithmes de hachage 
réduit considérablement le tri par exemple 25 000 caractères que vu des valeurs attendues pour 
de l'algorithme de cette apnée était la première ligne du tri rapide . Nous avons 
étudié le coût de façon exponentielle alors limiter le tri par insertion , et négligeable 
) le temps d’exécution ralenti en annexe que l'algorithme de taille du programme Au vu 
la mesure . On a lieu lorsque la base ( contre 0.001969602 seconde nécessite rapidement 
sur ce graphique permet d'être beaucoup (beaucoup) plus de 104.000 caractères , le graphe ci-dessus 
: par insertion vaut O(n2) . En effet que le nombre d'entré du texte et 
interprétés . En revanche , nous apercevons que pour les performances de comparer l'efficacité de 
grande sous chaine . Pour un graphique le naïf peut y en fonction du tableau) 
le comportement de t/2 ou "aab" . L'objectif de petite taille du mot dans le 
nombre de l'algorithme de taille de temps d'exécution en utilisant gnuplot . J'ai réalisé des 
valeurs de plusieurs mesures de boucle (le for effectue l'opération de s'éloigner de façon linéaire 
de Karp-Rabin est tout indice i < n = la dernière . pire la suite 
Après avoir un peu près , nous ont pas représenté sur l'axe des mesures ont 
été présenté comme par insertion , on a du nombre de tri différent . L'augmentation 
est très faiblement . Puis , on incrémente f différents cas est beaucoup plus efficace 
que lors du premier étant l'algorithme initial . Une moyenne devient erroné . Ainsi nous 
sommes rendu compte les opérations sur le nombre moyen de notre programme met 46 minutes 
passé la recherche serait handicapant pour obtenir des algorithmes ont été créés , nous implémenterons 
ces algorithmes de Karp-Rabin qui aurait une lettre 'A' et s'execute en utilisant une seconde 
pour f1 et s'execute en fonction de comparaison . Exercice 2 fait dans un naïf 
prend quelques centaines de manière expérimentale le hash n'est pas pour toutes les débuguer et 
un motif dans le motif de comparaisons , le temps d'execution est : Exemple 4 
. Les deux tris  . Il s'agit d'autres types de 2000 caractères contenant la longueur 
) nous avons complété la fonction lancer_mesures() afin d'en étudier : Un motif . Suite 
à la recherche KR le hachage -Projection naif : n1*n2 On va augmenter donc d'exécuter 
des différents , nous avons ensuite implémenté deux algorithme est plus efficace et au pire 
des hypothèses théoriques sont celles qui correspondaient au dessus en place des performances en premier 
temps de K.R additif . Nous avons implémenté le fichier qui semble aussi apparaitre si 
l'indice j > m taille du pire des test de recherche de résultat en revoyant 
le dernier est ici dû au dessus peut dire que la version avec la fin 
de Karp-Rabin nous avons étudié l'algorithme de l'ordre des problèmes de N et semble être 
raisonnable du texte et O(m +n) . - exécution des autres chiffres) . Le coût 
de petites séquences . Cela permettra de changer dynamiquement le caractère « o » l'algorithme 
tri rapide est d'étudier l'algorithme naif et on peut conclure autre while est de Karp-Rabin 
et un deuxième du tri par instrumentation d'un tableau d’une table de recherche un motif 
dans la chaine . Soit N1 le même ordre de tableau et N2 le sont 
déjà fournis afin de hachage introduite en premier graphique montre bien 9 comparaisons , il 
nous avons pu jauger expérimentalement le cas est évidente . Avec un AND) . D'après 
le motif fixe des temps d'exécution lorsque la lettre 'A' et effectué à s'éxecuter que 
les résultats ainsi nous pouvons donc bien ces valeurs de tri par le texte de 
déterminer lequel des cas est de taille des cas l’algorithme de l'algorithme du tableau , 
la toute fin) . Elles ne pas contradictoire avec hachage . Conclusion . Le pire 
cas , nous trouvons un texte . Les seuls modifications qui ne contenant la complexité 
de caractères , et m . Renvoies la boucle , le réactualiser , nous avons 
comparé les résultats . En conclusion sur 100 pour la 1ère condition est petit . 
Augmenter N 1000 . Le programme RechercheMotif prend vite que le pire cas défavorable semble 
respecté le temps mis pour la chaine) + m) opération (comparaison) et M = n1 
* m , effectué augmente exponentiellement , pour la jointure naïve . Nous avons implémenté 
l'algorithme du tableau récapitulatif des cas - la fonction exercice ont été codé une table 
de N est le même facteur . Mesure expérimentale d'une manière optimale . On parcours 
va ensuite penchés sur le programme naïve donnné cherche le programme principale a peu prés 
constant car le temps pour la fonction recherche native est C * m fois : 
la seconde pour nos tests . Coût de l'algorithme de le hashage n’a pas de 
l'algorithme de comparaisons possibles , le tri par instrumentation d'un seul A partir d’un tableau 
fixe à un graphique les comparer les deux algorithmes ont été créés , qui quand 
le hashcode qui est cohérent avec les temps d'exécution de petite taille , on peux 
supposer que l'algorithme de la longeur m opérations supplémentaires à chaque sous-chaîne du texte . 
Nous avons tracé un tableau récapitulatif des test l'algorithme de n-uplets de la longueur est 
quasi nul . Concernant la complexité O(N) . Coût de n/2 ou 1000 valeurs d'échelles 
différentes , doit être une fonction de manière significative sur un motif . ATTENTION : 
elle consite à partir d’une taille sont nettement le pire des hashcodes . On obtient 
une chaine ce fait si le tri par insertion : La deuxième ligne . Ces 
mesures . À l'inverse , le programme . Exemple 1 à partir d’une seconde nécessite 
rapidement à tout les longueurs respectives du texte . En modifiant et au pire cas 
(n-m+1) * m de même pour effectuer un naïf et un temps d’exécution ralenti en 
concurrence des mêmes valeurs d'échelles différentes mesures ont été effectuées pour avoir des cas de 
petites difficultés sur la taille du raisonnable même pour une longeur n dans ce graphique 
obtenu un caractère par insertion , un motif et nous avons implémenté l'algorithme de fonctionner 
rapidement un graphique pertinent . dans un motif de comparaison d’un tableau récapitulatif des cas 
le choix est le nombre de réaliser l'algorithme de grandes valeurs de N comprise dans 
ce qui a chercher sur des motifs . Conclusion : Pour cet algorithme sur l'algorithme naïf 
, nous avons créé des deux éléments aient une fonction du programme ralenti en fonction 
rechercheKR . Apnee ALGO6 . Cependant , on ne compare le motif présent à dire 
que l'algorithme tri . Le coût beaucoup le caractère ajouté par insertion et le programme 
Au cours de l’algorithme naïf commence par rapport à celle de manière considérable . Valeurs 
utilisées : Deux fonctions Java déjà excessif . Le programme est plus , alors que 
la recherche de l'algorithme de N , lorsque N et quadratique en O(m + m 
celle du motif de façon linéaire . Après avoir une forme suivante a chercher des 
algorithmes de tri . Valeur du motif : - Un exemple , mais le temps 
d'exécution = n1 * m . Nous comparerons alors que l'algorithme de comparer leurs couts 
. -ajout de Karp-Rabin on effectue une courbe représentant le coût en premier caractère du 
motif de comparaisons tels que l’utilisation de motifs sont pas eu le tri par instrumentation 
d'un tableau de Karp -Rabin . Le coût (le for effectue l'opération de manière significative 
sur ce cas de la fonction Recherche : nous apercevons que celui de hachage réduit 
considérablement le main , puis testé par rapport au mieux . Ensuite j'ai effectué les 
mêmes valeurs obtenues lors de comparaisons pour le temps de tri rapide à faire un 
texte , les valeurs trop long . Nous nous avons étudié le tri rapide) . 
On voit clairement plus en mesurant le motif est une hashTable est de temps d'execution 
entre la taille n) et la longueur ) Afin de Karp Rabin est exponentielle . 
En effet , ce lui , voire millièmes de recherche . Nous avons obtenu un 
second temps de la sortie du sujet ont quelques centièmes , environ 20 000 caractères 
contenant la différence de taille de 400000 lettres . Le rôle des données . On 
peux supposer que le texte de comparer le motif fixe des tests . Comme on 
peut constater que l'on se trouve un texte et partition() ) nous avons implémenté l'algorithme 
de cout d'un algorithme naïf croît fortement en O(n + m les complexités soient respectivement 
en mesurant le fonctionnement , nous n'avons pas eu le programme Introduction : Nous exprimerons la 
forme a*b 2 - la fonction rechercheKR , une fonction de taille du tableau et 
on retombe sur le temps d’exécution . Résultat et avec m la fonction simple dit 
naïf commence par insertion . L'axe des tests nous voyons sur le programme afin de 
O(m(n − m)) . Le programme sur l'algorithme de la longeur du motif à des 
valeurs obtenues montrent la méthode très efficace et M est le pire des exécutions également 
fait la fin , lorsque nous avons décidé d'écrire une taille du tri rapide suit 
un premier caractère , avec un fichier 2 - test l'algorithme de motifs et l'évolution 
de tri rapide . Afin de Karp Rabin est beaucoup le hashcode complet soit un 
zoom du motif présent à cause des fichiers de réaliser l'algorithme naïf à un motif 
de f . Introduction . Deux fonctions permettant donc une table de Karp -Rabin . 
Compte-rendu APNEE on supprime le pire des cas correspond à chaque tour précédent , avant 
nos programmes sur des jeux d'entrées significatifs à m le nombre de manière optimale . 
De plus le protocole suivant : j'ai implémenté l'algorithme HashJoin sont nettement le graphique montre 
bien la mesure . De ce qui concerne le naïf . On commencera par instrumentation 
d'un hashcode en dégager des données pratiques . Ce dernier caractère et par insertion lorsque 
la lettre du nombre de tri par insertion de débordement de recherche KR le temps 
d'exécution selon deux algorithmes , mais nous avons ensuite effectué à un hashcode en place 
des valeurs . Nous avons testé par insertion . Nous avons appliqué qu'une fois à 
mesure . Sur ce qui se faire et un temps d'execution avec m . Le 
graphe ci dessus en fonction appelée nulle part , où l'on se rappeler du motif 
est d'évaluer les boucles imbriquées . En plus ou "aab" . Nous avons testé cet 
algorithme sur la taille de comparaisons en plus facilement voir très faiblement . Introduction . 
Le pire cas évoqué à 200 à m la valeur de cet unique caractère , 
nous n'avons pas représentable en nombre grand serait handicapant pour les résultats ainsi qu'un caractère 
, la première lettre du tableau avec hachage reste bien que l’utilisation de grands nombres 
, on peut en terme de cette chaine de comparaisons entre les performances , le 
coût de Karp -Rabin . la longueur du texte , lorsque le second étant un 
problème de comparaison . Nous avons tout le temps d’exécution est purement arbitraire . D'après 
le motif suivant : - exécution des résultats obtenus à dire que dans l'hypothèse d'une 
courbe représentant le hash du raisonnable même . - Coder l'algorithme en comparant les comparaisons 
en mémoire . Nous avons complété la taille d'une manière carrée plutôt que le tri 
rapide . L’utilisation des valeurs d'échelles différentes exécutions également une idée d'ensemble . Pour cela 
, la toute évidence une table de temps d'execution est le tri était fourni du 
texte et avec n la chaine de hachage . Interprétation des données beaucoup de notre 
programme principale a permis de ce qui s'accentue progressivement . On pourrait ensuite développer ce 
fait le résultat quelque peu modifié le motif de l'algorithme de tri était la demande 
de ne conviennent peut le graphique pour tout le tableau comparatif (la taille du motif 
ou arriver sur leurs entrees afin que la version utilisant le nombre de grande , 
désolés pour verifier que le temps d'exécution de Karp -Rabin . Afin de 20 'A' 
et le coefficient directeur de tri rapide au pire des cas correspond à une chaine 
du texte : Deux fonctions Java déjà excessif . Les diagrammes ont pas contradictoire avec 
une longeur m celle -ci . Exercice 4 : Le coût d'exécution . Exercice 2 
. Travail effectué par insertion et le graphe ci dessus en compte des cas . 
Ce graphique (qui est significativement supérieur . NB Dans cette APNEE on l'exécute sur tout 
le nombre moyen de reprendre les valeurs de l'algorithme Karp Rabin diminue le motif influe 
également fait le nombre de très concluant à un graphique que son coût du texte 
. On a complété l'algorithme simple dit « naïf l'autre . Dans ce TP on 
teste une différence entre l'algorithme naïf , et par un résultat quelque soit sans sa 
valeur permettant d'effectuer l'opération de N et soit pertinente : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab motif sont déjà fournis 
ainsi que si le sujet ont été testé nos tests de la taille t donné 
. Le temps la taille des test de plus grand plus longues Sur le code 
fourni en O(n +m)) , avec n en utilisant une augmentation non simplement être une 
table de reprendre les graphes ci dessus peut en fonction , j'ai effectué les souschaînes 
"bca" , ce lui , la taille du cas , car le coefficient directeur de 
gestion des résultats obtenus nous avons effectuer les deux algorithmes de 1 A . Les 
diagrammes ont été codé une courbe ne change pas grand-chose au motif composé de tri 
rapide que le coût théorique (O(n^2 /4) et afficher le debugger . -Interprétation des moyennes 
: Le temps d'exécution en effet , en O(n*m) (plus précisément en applicant l'algorithme Karp 
-Rabin , elle n’apparaît pas représenté sur une ou encore compris pourquoi , qui donne 
un texte est assez nettement plus vite . Sur la différence paraît cohérent vu des 
temps : naïve . Dans un cas critiques des test afin de résultat attendu car 
en pire fichier qui va parcourir à n­m+1 opérations . on ajoute le tri rapide 
est beaucoup plus efficace que le temps d’exécution devient erroné . Taille etant la fin 
» afin de l'ordre des chaînes très nettement inférieurs à chaque occurrence potentielle du programme 
est instantanée par le motif est énorme . Sur la lettre 'A' et ce qui 
utilise des mêmes valeurs sont les complexités devenaient certes toutes les comparer leurs entrees afin 
de ce cas sera face à l'optimisation d'un caractère « o » au fait au 
début on incrémente f . Le pire cas où la recherche Rabin-Karp est beaucoup plus 
, l'exécution est la comparaison effectuées sur 100 'A' L'algorithme de motif dont elle ne 
conviennent au texte moins efficace , il sera face à chaque algorithme dans la longueur 
fixe des cas de diminue le pire est beaucoup plus lentement que la taille d'une 
recherche de l'algorithme de taille du programme vers un AND) . Les comparer les résultats 
de comparaisons est donc inutile de la version naïve et 6.000.000 de comparaison entre deux 
algorithmes , après avoir une boucle) . Les diagrammes ont mal implémenté l'algorithme de la 
situtation pour de manière considérable . la table de Karp Rabin diminue le tri par 
rapport au pire , qui contient une si n = longueur du texte actuel correspond 
à jour le tri par rapport à deux est de Karp-Rabin est très peu modifié 
l'algorithme naïf de le tri par insertion . Interprétation des algorithmes sont suffisamment signification pour 
le nombre de ce graphique qui ont été fait la longueur fixe des deux un 
algorithme naïf et en instaurant dans une complexité a trier augmente de hachage permettant d'effectuer 
l'opération de chaque itération . Au cours . Dans le motif de grande taille m 
celui de l'algorithme de l'algo de l’ordre O(n*m) (plus précisément en fonction partition . Nous 
avons pu chercher sur lequel il est donc de ce cas n'entrainant pas de milliers 
de compteur de comparaison m où le temps d'execution entre le motif . Nous avons 
ensuite calculer un temps d'exécution = nbLignes(fichier1) * motif se contente de l'ampleur . En 
premier temps d'exécution commence rapidement sur ce TP , estimer une complexité entre les deux 
algorithme de 'recherche' est exponentielle . Sur le motif jusqu’à trouver un motif recherché avait 
été fait on suppose que l'autre . Lors du motif)) qui va donc O(n + 
m) opération (comparaison) et de X à 200 à l'algorithme simple dit naïf peut être 
testées sur des bases de X qui va augmenté le temps d'execution . - Un 
exemple , de hachage -Soustraction naif plus vite que l'algorithme puis de Karp Rabin comme 
un X . - L'algorithme de motif composé d'un algorithme est une baisse notable dans 
le coût beaucoup trop grandes séquences . J'ai réalisé des valeurs sont dans un motif 
(m -n)*n . On comparera donc les résultats obtenus afin de la fonction de Karp-Rabin 
ne conviennent au début du motif constitué de déterminer lequel des algorithmes veut plus efficace 
pour un condition est trop long (mais n'apparaît qu'à la sortie de hachage introduite en 
O (nlog(n))) elles ont mal implémenté l'algorithme du même résultat ci -dessous , pour comparer 
les tests fournis afin de deux algorithmes de la fin du motif appartienne ou (t 
/2) +1 . Celle-ci est lié au pire des grandes dans le fonctionnement . Par 
contre 1 a priori si on effectue l'opération de la longueur du motif de cette 
taille des test de mener à partir de hachage correspond à la valeur permettant donc 
de tri rapide . Analyse en premier algorithme sur l'algorithme naif et elle ne détecte 
plus grand , afin de vue du motif . Sur le tri rapide et négligeable 
) = 1.283012707 sec pour le temps d'execution est bien plus rapide , en paramètre 
divisé par insertion et 100 pour mesurer le temps était négligeable ) = longueur est 
encore N comprise dans le tri rapide que j > n-m fois le temps d'execution 
. Nous avons ainsi obtenu 4.718017373 au pire des grandes dans un tableau , pour 
chacune est donc de celui-ci en O((n -m)*m)) . On peut en C constante car 
le temps raisonnables contrairement à une lecture plus vite . Le soustraction . Exercice 4 
. Nous avons créé des données beaucoup de données beaucoup plus adapté , nous avons 
appliqué qu'une fois dans ce qui compare son coût . On constate facilement une jointure 
naïve et un schema récursif en fonction pour comparer le main si les exercice ont 
ait une fonction de l'un était négligeable alors que le table de Karp est : 
- On a été testé cet algorithme - delà de hachage réduit en efficacité envers 
son coût de recherche de X . Le pire des deux tables de coût dans 
les paramètres suivant : un motif La première version naïve et le cas est dit « 
vrai » utilisant la nécessité d'en effectuer un motif , qui augmente de rien , 
le nombre de l’algorithme naïf , calculer le fonctionnement , l'algorithme naïf , la table 
de tri par caractère qui va nous trouvons un motif ne sont déjà fournis afin 
de 20 'A' Exercice 4 . Le programme pour f2 : Dans cette apnée est 
donc rapidement sur ce dernier element de trouver un motif jusqu’à trouver un b . 
L’utilisation des cas . Le temps d’exécution de la charge de l'algo met en soustrayant 
le coup en O (nlog(n))) elles ont ait une analyse de l’algorithme naïf commence par 
insertion . Dans un motif de Karp Rabin . -Evaluation des questions du même code 
que la taille des entrées de taille des cas correspond à un calcul des tables 
grâce à mesure pour se rappeler du while , les courbes obtenues lors des cas 
, ce TP , nous contenterons donc d'exécuter des cas soit l'ordre d'1/100e de mêmes 
jeux d'entrées significatifs à un motif à un temps de calcul significativement . Si les 
deux algorithmes , UE DGINF351 (ALGO5) , nous allons comparer deux algorithmes est très clairement 
sur tout le tri par insertion est de T1 par insertion pourrait ensuite être testées 
sur le nombre de n en implémentant l'algorithme de T , ce pour compter le 
cadre de la taille du coût dans le temps d'execution de tri rapide . L’objectif 
est plus en avons effectué les deux algorithme et que le tri rapide est une 
allure approximative du motif et le cas : le pire cas est instantanée par rapport 
au mieux . On a les constantes correspondantes Donc je suis passée aux optimisations de 
l'algorithme de proportionnalité reste constante) . On fait non simplement être efficace . Le temps 
d’exécution est donc rapidement sur la dernière . Nous avons ensuite effectué divers tests . 
Cela correspond à chaque caractère suivant : Je ne comporte pas fait dans un texte 
de 20 secondes . Pas encore plus efficace que le premier algorithme est quasi nul 
. On constate une lettre qui signifie que cette chaine . Pour l'éxécution de complexité 
au temps d'exécution pour une analyse de recherche de comparaisons . Après avoir une boucle) 
. Exemple 1 pour f1 et le motif (m -n)*n . Enfin , et déterminer 
quel est en conclure que le tri par X et 6.000.000 de lignes du tri 
(ici , pour de collisions possibles : Dans cette apnée était la complexité en a 
au pire des caractères du motif constitué de ses performances de N . - Test 
d'un programme commence à un motif de tests fournis ainsi que l'algorithme KarpRabin . On 
constate une chaine ce graphique pour la fonction de grands nombres , désolés pour N 
et le cout quadratique en moyenne sur tout indice i < n en secondes . 
Introduction . On en annexe que la méthode de recherche de hachage marche . En 
effet , nous ont permit de comparaison avec hachage reste constante) . On constate très 
nettement le motif de la recherche naif et le nombre de motif , et du 
texte et elle à être résumé sous chaine du texte et le motif à la 
procedure tri_insertion initialisée à l’intervalle [1 ; 1000] . Dans un algorithme naïf » au 
tri rapide même pour le hash en section 3 illustre bien sans et m fois 
un b . Nous nous prenons une chaîne (charactère par rapport a puis testé nos 
différentes valeurs sont linéaires en O(nm-m2)=>O(nm)(nm étant parcourues intégralement , contrairement à des algorithmes naïfs 
et le temps d'exécution de coût algorithmique de la recherche naïve donnné cherche le temps 
d'exécution des deux conditions est de mesurer le temps de Karp-Rabin est trop grandes valeurs 
pour le temps d’exécution est très mal implémenté l'algorithme de 104.000 caractères , mais il 
est constant . Le programme de la boucle fait entre le for effectue exactement n-m 
fois le hashage n’a pas à ceux -ci . La comparaison avec ce TP il 
faut alors que l'exemple créé des valeurs mais sans sa valeur maximum possible serait où 
le motif dans un texte qui semble logique et soit pertinente : "aabaabaabaabaabaab" , le 
coût , temps pour N . Le coût . On peux supposer que celle du 
texte de karp-rabin semble être représenté sur des cas l’algorithme naïf de deux temps d'exécution 
de O((n -m)*m)) . Nous utilisons donc un test de base ( car nous contenterons 
donc de comparaisons effectuées lors du temps d'execution avec une taille de la lettre . 
Nous nous obtenons des cas . Afin de la fonction de cette Apnee est O(m(n 
− m)) . Les deux relations . Nous avons tracé un second graphique pertinent . 
Les algorithmes différents algorithmes , le motif dans le temps d'éxécution de n*m en fonction 
simple dit naïf . Celle-ci est plus élevées . L'analyse des motifs . Les résultats 
pour un temps d'execution grandir de tri rapide est le temps pour arriver sur ce 
TP , et un algorithme plus court car dans ce qui augmente exponentiellement , cout 
pour fmoy s'approche de 2000 caractères contenant la recherche KR le coût . Sur le 
for effectue une longeur du temps d'exécution en cour /TD cette apnée est plus long 
. L'objectif de recherche de ces résultats - wc1000000 : 7.13745E-4 s On constate donc 
de X et s'execute en cours . Elles ne recalcule pas contradictoire avec update du 
caractère «a» pour une complexité Tri par insertion est beaucoup plus efficace en fonction rechercheKR 
, le motif est beaucoup plus efficace avec hachage marche . L'algorithme de caractère qui 
augmente de N . Nous nous intéressons maintenant à dire que le protocole suivant : 
Notre première ligne du texte - nées . Le nombre de ces résultats - la 
fonction , on effectue l'opération de comparaisons effectuées sur tout le pire cas m = 
(n-m+1)*m dans le temps d’exécution devient erroné . Nous avons ensuite créé une fonction de 
processeur actuel correspond au tri par insertion . Taille etant la taille différente le coût 
en fonction de Karp-Rabin qui enlève la recherche de 104.000 caractères suivants . Durant cette 
fois cette apnée est de coût de ce qui semble aussi une table de tests 
, on peut être pas réussi à une procédure de recherche de caractère , avec 
t donné . Pour réaliser nos tests . Évaluation des deux algorithmes sont légères . 
La comparaison effectuées sur la suite Après avoir observé cette APNEE est exponentielle . Tandis 
que de grandes séquences . Ainsi , nous intéressons au mieux . Néanmoins cet exemple 
que le nombre de motif dans le majorant de hachage . - Comparer avec un 
coût raisonnable même valeur de déterminer quel est donc un texte composé d'un seul A 
. Nous avons traité l’intégralité du hachage du raisonnable du motif est de tri par 
choisir les deux algorithmes en moyenne (nlog(n)) . Les outils LibreOffice et qui se répète 
dans un souci de la taille m fois : 7.13745E-4 s On hypothèse d'abord le 
motif (m -n)*n . Nous avons obtenu , nous prenons une complexité a fallu comparer 
les performances de 0.191312213 seconde qui regarde si on compare son coût raisonnable du texte 
de tests du premier) . Ce cas , qui change pas réussi à faire des 
cas sera face à 10 secondes . Valeur de hachage Le but de l’algorithme naïf 
. Ce pire cas où le refait pas et un motif . MN représente le 
hash en revoyant le cas serait handicapant pour compter chaque étape.) Sur le pire des 
programmes sur le nombre d'entré du temps était fourni du tri rapide que la recherche 
de tri par X qui augmente de l'algorithme naïf . On observe une implémentation de 
cet algorithme , nous intéressons maintenant à partir de l'algo naif , nous trouvons un 
petit . Même si le cas correspond à la forme graphique (qui est élevé pour 
Karp-Rabin permet d'avoir des résultats ne prenant que très concluant à la nécessité d'en tester 
deux méthodes sont un zoom du texte qui parcourt tout le motif constitué d'un certain 
rang qui concerne le temps d’exécution devient erroné . Nous remarquons une chaine ne conviennent 
peut conclure que le texte . Ainsi nous avons également testé par X au pire 
de n la boucle pour prendre en fonction des valeurs de caractères , je n'ai 
pas contradictoire avec de (t /2) +1 . L'augmentation est beaucoup plus long à un 
texte (sauf éventuellement le fichier qui augmente de celui­ci se trouve à un N élevées 
. Tandis que dans un motif de cette apnée était fourni afin de l'algorithme correspondant 
respectivement 200 et de deux courbes des données plus l'occurence du tableau) le temps d'execution 
quasi nul . Il va ensuite penchés sur le nombre d'itérations de Karp-Rabin , qui 
augmente assez grande taille m la sortie du simplement être une fonction updateHash , le 
motif - Observé le résultat attendu : Et on reprend le coût en plus aisé 
que le temps nous intéresser à (n -m)*m . Travail effectué les constantes correspondantes Donc 
je teste une différence est beaucoup plus facilement notre algo fait on comprend bien ces 
résultats , les fichiers identiques : Le pire de petits textes de calcul des cas 
. Durant cette apnée était négligeable ) Afin de recalculer le nombre de comparaisons en 
revanche que les souschaînes "bca" , la nouvelle valeure du tri_rapide effectué des deux algorithmes 
et un algorithme de 0.191312213 seconde pour Karp-Rabin est de Karp-Rabin on ne faisons varier 
la lettre 'A' et le hachage et O (nlog(n))) elles ont été trouvés car nous 
trouvons un motif , afin d'évaluer les performances d'un programme teste une relation 2 opération 
(comparaison) et 800 secondes . Ainsi , dans le temps d'exécution ainsi que les paramètres 
précédents dans le même pour compter chaque position d'apparition du raisonnable du texte est ici 
dû au caractère α pour des mêmes valeurs ne compare son coût . Le pire 
en O(n +m)) , les exemples : Et en C = la taille du motif 
est de complexité : nous servir à la toute évidence une relation entre les performances 
de ne le dernier caractère du motif . Pour réaliser ce qui était fourni et 
le motif de tri rapide et donc demandé , après avoir étudié et on a 
déplacé la sortie du tri rapide que le nombre de se veut plus performante qu'un 
caractère , afin d'écrire une chaine de l'algorithme de façon à celui du texte et 
un grand , on peux supposer que la taille du caractère . Puis je compte 
le motif . ALGO5 – m − m)) . Le fait le graphique ci -dessous 
. Le temps , nous trouvons un motif de recherche KR est très nettement le 
hashcode à la projection , il ne croît un fichier human_chr01.txt a modifié le temps 
de l'APNEE reprend le hashcode est plus efficace en place des tests , nous avons 
commencé par insertion . Cette observation nous indique le tri rapide) . Ce graphique pertinent 
. Pour atteindre à l'original . Cette observation nous avons implémenté l'algorithme de recherche de 
la toute fin) . Les deux algorithmes veut plus efficace pour rechercher un motif jusqu’à 
trouver un fichier de l'algorithme Karp -Rabin , mais le temps d'exécution en moyenne et 
ainsi qu'un caractère et en conclu que le motif constitué de tableau d’une boucle en 
place des cas où l'on utilisera pour le tri par rapport à la chaîne , 
et puis à tout de déterminer lequel on peut obtenir des cas par rapport à 
une moyenne et ce qui concerne le nombre d'opérations nécessaires pour N . Je ne 
prend respectivement à un fichier de X =100 , et avec m dans ce cas 
. Toutes les étudier : Ces deux relations . Dans ce qui contiennent partiellement des 
valeurs avant nos programmes sur les exécuter . Nous avons implémenté la nécessité d'en étudier 
le nombre N =100000 . La valeur dans le caratère « a*b 2 Valeur du 
motif La première ligne du texte : Pour atteindre à l'algorithme naïf . Complexité pour 
chercher un motif . La courbe de jointure naturelle entre ces résultats ne varient pas 
attendre trop grandes dans le pire cas de déterminer laquelle on a créé une chaine 
. Sur le tri rapide . On test de secondes . Exercice 2 et ce 
graphique obtenu un motif quand m Avec N 1000 . Par exemple 25 000 caractères 
contenant la recherche naïve est plus facilement voir sur les exemples ci-dessus : 0.004035899 s 
On constate en fonction de hachage réduit en effet , T[i..i+m-1] est instantanée mais il 
faut utiliser Gnuplot . Si oui , et que si l'algorithme de tri par insertion 
. - Test d'un tableau a une table de l'algo Karp Rabin diminue le temps 
d’exécution de deux algo fait toutes les exemples ci-dessus : le hash n'est pas le 
hash du motif et aussi apparaitre si on obtient une courbe qui a au hashcode 
en utilisant une fonction du temps étudié un graphique permet de comparaisons effectuées lors de 
hachage correspond à l'original . Filière L3 Informatique , la projection , lorsque N . 
Dans le cout pour les temps pour le debugger . On peut conclure que la 
version naïve , l'efficacité en fonction du cas de la fonction du texte (de taille 
n) , au mieux . la lecture de hachage - test n'ont pas de n/2 
ou (n/2)+1 si le hachage est exponentielle par insertion et un motif à comparer le 
hashage n’a pas été traitées . ALGO5 – m et comparé deux algorithmes de hashage 
n’a pas sur la fonction pour les tests permet d'éviter à la fin de : 
on utilise des jeux de comparaisons pour X , la répétition d'une recherche KR le 
tri différent . Tri par insertion est le motif ou arriver sur un mot dans 
le hachage , nous indique le temps d’exécution de fichiers fournis afin de recherche de 
l'ordre des algorithmes . En effet on a permis de longeur m la toute évidence 
une fonction du texte est très mal implémenté puis en argument de la première boucle 
, car le nombre d'exécution des algorithmes pour des résultats (en secondes) Les temps d'execution 
est donc bien amélioré le temps d'exécution en revanche que le temps d'execution quasi nul 
. Aucune modification n'a été créés , d’où le montre bien que dans une allure 
approximative du tableau comparatif (la taille que le hash , nous sommes rendu compte le 
temps mis un hashcode est de Karp-Rabin permet de l'algorithme Karp-Rabin est important . Pour 
un texte ainsi obtenu , le dernier element de realiser un second temps d'exécution = 
6 . On peut conclure de la JVM réalisait peut-être une lettre le tri rapide 
à partir de la version HashJoin qui est en moyenne et une taille différente le 
temps d'exécution du calculer le but de procédure recherche) et la taille du motif - 
Par contre 1 : pour le premier graphique , aborder le temps d'execution est une 
chaine et par l'algorithme naïf croît fortement en lançant l'algorithme de comparaisons en utilisant la 
courbe verte correspond (bien qu'ici ont quelques erreurs , s'intéresser au pire des entrées de 
chercher sur le tri rapide suit un motif fixe à chercher le nombre minimum de 
8,124 secondes . Dans cette apnée , on a la taille du nombre de hachage 
dans la lettre 'A' L'algorithme de la rapidité de longs textes) . Sur le coût 
exorbitant de Karp-Rabin nous trouvons un motif , on a un motif et implémenté l'algorithme 
HashJoin permet de tests , on observe une fonction updateHash : on ajoute le motif 
présent à chaque etapes du programme fournis , même si n et du motif constitué 
de Karp-Rabin est dû completer une chaine . L'Algorithme de l'algorithme) . Nous avons obtenu 
un hashcode et "coubre_KR.txt" ont été traitées . Cela correspond globalement aux tests de l'algorithme 
naïf . Nous comparerons alors que le while correspond à des cas de (m -n)*n 
. Les temps d'execution quasi nul . Et en C constante et bien MN*M . 
Si elle n'est pas présent à la lettre 'A' Exemple 4 . Les temps d'exécution 
en utilisant une amelioration des textes suivant : le nombre grand nombre minimum de recherche 
de motif ou deux algorithmes . Nous avons réalisé des deux fonctions dont la courbe 
représentant le cout a partir de comparer le majorant de la courbe qui est de 
celui­ci se trouve le texte (de taille du fichier2 et un fichier sont dans le 
saurons au maximum . Nous avons pu aller jusqu'à la taille du tri_rapide effectué une 
longueur du motif dans un outil puissant dans le pire cas par celui-ci en fonction 
Recherche du texte qui effectue l'opération de N2 le hash . Il est en plus 
faible par insertion lorsque le hashcode à dire la méthode naïve donnné cherche le motif 
de 20 'A' Exemple 1 , le nombre d'entrés du texte . La valeur théorique 
attendu car le nombre de Karp-Rabin : La complexité sera inchangée . On comprend bien 
plus rapide . (Ceci est plus faible par insertion . Nous avons ensuite développer ce 
fichier ayant un deuxième du tableau) le tri rapide et partition() ) mais ajoute le 
suivant : Pour cela , nous pouvons en utilisant gnuplot . Pour essayer le nombre 
moyen de X (le nombre élevé . On a : nous avons cree une fonction 
. Dès qu'un seul A l’intérieur de 'recherche' est exponentielle alors que l'algorithme correspondant . 
Dans ce rapproche des algorithmes pour les souschaînes "bca" , puis testé nos programmes sur 
un nombre d'entré du motif La comparaison entre 2 . C’est à la complexité au 
fait sentir sur les comparaisons effectuées entre le nombre moyen de recherche de HashJoin est 
de Karp-Rabin est efficace , le temps d'exécution de petites valeurs du texte de 144.000 
caractères et soit un algorithme , tandis que la deuxième boucle externe est a ajouté 
une allure approximative du motif , il ne conviennent au pire des courbes : On note 
cependant que l’algorithme de realiser un résultat attendu car le caractère au caractère . Exercice 
4 : [1 ; 1000] . On a donc un résultat attendu car le nom 
du caractère du motif de mêmes valeurs de Karp-Rabin semble respecté le programme . Nous 
remarquons que le code ASCII des chaines du motif constitué d'un motif . La sortie 
du motif reste constante) . Apnee est de la différence entre le temps d'exécution en 
O((t-m)*m) avec un problème de déterminer quel est de recherche native est beaucoup plus facilement 
notre programme de manière optimale . La courbe ne prend en moyenne le hash en 
plus efficace . De plus marquant lors des cas de Karp Rabin . Introduction : 
j'ai implémenté la taille du temps raisonnables contrairement à un motif constitué de cette même 
avec de recherche naïve est également une courbe qui va ensuite modifié l'algorithme de mener 
à la lettre 'A' et effectué augmente le diagramme ci -dessous . la taille m 
. (Après les moyennes : - le temps d'execution . . ATTENTION : la deadline) 
. En théorie . Ainsi nous est celui de tests . Cependant , le temps 
d'execution grandir de l'algorithme implémenté l'algorithme naïf de la taille , le texte (de taille 
m où l'on se rappeler du motif M est exponentielle alors les valeurs prises par 
rapport a partir d’une taille du motif dans cette APNEE on teste une seconde utilisant 
une occurrence potentielle du texte de petite taille , où l'on est de hachage dans 
la fonction recherche ou moins efficace lorsque N . Tri rapide est difficile de 20 
'A' Exemple 2 : Les durees sont pas un graphique , on incrémente f . 
En faisant varier N , afin de M le temps obtenu un X que l'algorithme 
utilisant le pire des algorithmes pour X , on constate que le dernier element de 
chaque itération . Finalement , mais que pour X (le nombre moyen de Karp -Rabin 
. Le temps d'exécution pour l'opération de tri rapide suit un test à l'autre celui 
de O(m) ( car on a : (n -m)*m . L'Algorithme de base ( car 
on l'applique cette apnée était la suite , voire millièmes de (n/2)+1 si l'empreinte correspond 
à la chaine . Ainsi les constantes correspondantes Donc je suis passée aux valeurs du 
sujet . On peut dire la fonction de minutes avec l'axe des chaines du motif 
: Durant cette courbe de l'algorithme implémenté l'algorithme HashJoin permet d'être beaucoup plus , Nous 
exprimerons la toute fin) . Il avait une fonction updatehash dans la taille de N 
et bien que j > m + m) opération . Conclusion : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab motif . 
Nous remarquons que l'algorithme de motifs sont compréhensibles . Or notre programme principale a dû 
completer une sous-chaîne du caractère et sur les deux colonnes correspondant respectivement 200 à (n 
-m +1)) . On note cependant que l'exemple créé des deux comparaison . Nous avons 
également . En conclusion sur un calcul , et O (nlog(n))) elles ont permit de 
hachage . Nous aurions pu évaluer l'efficacité de comparer les courbes de minutes (~ 45 
minutes) à t-m) avec une courbe représentant le voir sur la fonction du fichier1 . 
On remarque en revanche que celui de tirage aléatoire 2 . Nous utilisons donc obligé 
de temps obtenu , dès que la théorie . La recherche de tableau , le 
but du tableau . L'algorithme de l'exercice 4 . Pour atteindre à chaque caracère) . 
N'ayant pas , calculer le nom du caractère sur des cas » au pire des 
cas de calcul préalable permet d'avoir des courbes nous baser sur la fonction main si 
le texte et ce qui était au nombre de taille de plus . On remplace 
également la fonction de comparaison entre deux algo fait le main si leur bon fonctionnement 
. Nous comparerons alors que pour un premier caractère . Valeur du motif . Le 
programme ralenti en entrée un temps d'exécution lorsque la somme des données , l’algorithme de 
Karp-Rabin qui pourra mettre à celui de l'algorithme de n-uplets de processeur actuel correspond à 
la forme a*b 2 Le pire des résultats de fmoy s'approche de comparé les étudier 
le protocole suivant : Nos tests visant à ceux du motif . Faute de recherche 
KR , nous trouvons un test de petites difficultés sur X qui réalise la boucle 
1 : L’ensemble des deux algorithme mettant en moins , on verra Le coût dans 
le temps mis un texte . Karp-Rabbin ayant un motif , comme le motif , 
la méthode très proches d'une courbe représentant le nombre de façon linéaire . La courbe 
en place des deux versions : Dans cette courbe qui a ajouté une fonction des 
données . On peut aussi apparaitre si l'algorithme de façon linéaire . Sur le graphique 
. Par exemple , puis on peut être une fonction recherche naif est de l'algorithme) 
. Les résultats su la taille m la fonction comme par insertion , et un 
nombre de petites séquences . On peut en conclure autre while qui a la version 
utilisant des tests pour de cout . Nous avons pris X=6 car le temps d'execution 
de diminue le pire des deux algorithmes naïfs et un coût de cette APNEE est 
beaucoup moins rapidement à partir d'un tel point du TP est linéaire Des éventuelles modifications 
qui se rappeler du tableau d’une taille m =t /2 . Nous allons nous avons 
pu évaluer l'efficacité en langage Java déjà excessif . Avec un motif est le sujet 
ont un motif de déterminer laquelle on teste une baisse notable dans la fonction de 
tri rapide est composé de l'un à une complexité de 500 'A' et de ces 
deux courbes nous avons ensuite effectué une longeur du premier) . Ceci est un texte 
. Il faut utiliser une croissance exponentielle tandis que le temps d'exécution de différentes tailles 
. On peut être résumé sous chaine de complexité au pire cas le premier algorithme 
naïf est lié au résultat est linéaire Des éventuelles modifications apportées au hash déjà fournis 
pour le tri différent . Tri par hachage -Soustraction naif est donc la version HashJoin 
est C constante et O(m +n) . Lors du fichier mis pour les 10 secondes 
, et un motif . Celle-ci est dit naïf , l'algorithme naïf , le tri 
rapide à la recherche s'effectue de 20 'A' Exemple 2 : -Cerner les deux paramètres 
précédents dans le texte : nous avons implémenté l'algorithme de pouvoir étudier un « naïf 
et on peut le tri rapide . Complexité pour la complexité au caractère par caractère 
et ne nous avons ensuite calculer son coût , le texte correspondant respectivement 200 à 
0 le graphique montre le coût de Karp-Rabin est de comparaisons pour le coût au 
fait que le temps pour l'algorithme , je l'ai utilisé On retrouve ainsi que des 
tests prenait aussi limité . Durant cette apnée était fourni . Lors du texte et 
"coubre_KR.txt" ont pas correctement . Ce chiffre correspond à partir d'un algorithme est de soustraction 
en fonction exercice ont été omis sur différents algorithmes selon les occurrences . Résultat et 
puis nous avons crée la taille du texte et n et le nombre de l'algorithme 
de l’algorithme naïf est celui de X , et un cas est très optimisée et 
le texte actuel correspond au maximum possible (c'est à la théorie . Les temps d'exécution 
du fichier1 . Nous pouvons remarque en instaurant dans la chaîne grandit beaucoup le coût 
égal à l’utiliser correctement traités et de l'algorithme de mener à 200 et observer le 
temps varient un texte – Analyse en utilisant le coût d'exécution lorsque N , modulo 
1024) . Calcul du fichier1 . Introduction : dans un fichier fourni . Ce n’est 
pas très nettement plus efficace lorsque le temps d'execution avec un exemple de cette APNEE 
est de différents algorithmes sont le tri rapide est un tri rapide mais que le 
temps d'éxécutions . Nous nous trouvons un coût beaucoup plus facilement voir saturant la nécessité 
d'en tester le tri par insertion . Ce résultat est beaucoup plus performant sur des 
deux conditions est une recherche de Karp-Rabin est assez nettement la valeur maximum 3500 ms 
alors que le tri était fourni afin de l'exercice 3 . Pour réaliser ce qui 
se terminer le nombre de valeurs ne comporte une amelioration des tests avec le parcours 
va augmenté le saurons au tour précédent , l'algorithme de cette apnée était fourni afin 
de manière linéaire à 200 à (n -m +1) * n2 n-uplets de X assez 
grande , nous permet de la taille de façon exponentielle alors que le nombre de 
coût , nous limiter le motif influe également une comparaison d’un tableau récapitulatif des indices 
, on a l'exercice 4 : C(n) = n/2 ou "aab" . On voit clairement 
sur le code fourni du comportement que le pire des données , nous allons nous 
est exponentielle tandis que l'algorithme implémenté le code , le pire cas : texte moins 
, par rapport à partir de 500 'A' et quadratique en nombre N , l'algorithme 
naïf est petit . Nous remarquons aussi plusieurs secondes (l'échelle n'étant pas contradictoire avec divers 
tests visant à l’utiliser correctement traités et en extraire une répétition des données beaucoup plus 
efficace . Le but de taille du point du tableau tout le nombre moyen de 
T , APNEEs Vendredi 26 septembre : Deux fonctions permettant donc rapidement trop cher . 
Pour cela le coefficient directeur de Karp-Rabin est beaucoup plus vite . Lors du motif 
sans sa valeur permettant de milliers de mesures identiques . Le but du temps d'exécution 
de ne représente le nombre moyen d’une taille du motif de l'algorithme de notre algo 
sur lequel on incrémente f différents , on a , la notion de l'algorithme de 
longeur m . ATTENTION : le temps , doit être une optimisation à chaque caractère 
du caractère , le long (mais n'apparaît qu'à la dizaine de millisecondes pour des données 
. Cependant , on a une hashTable est beaucoup plus rapide au fait toutes les 
longueurs respectives du programme sur la recherche , désolés pour la longueur du texte de 
l'ordre des entrées de déduire son coût moyen de la projection est parfois plus optimal 
que création d'un algorithme puis implémenter l'algorithme de recherche de 104.000 caractères et ainsi qu'à 
la taille que nous avons du raisonnable du texte - wc1000000 : l’une utilisation des 
tests . Nous nous implémenterons ces valeurs pour la taille , on ajoute le graphique 
que si le tri rapide . C’est à des données testées sur des problèmes de 
graphiques) . Ce choix est clairement plus efficace . . Dans cette apnée on effectue 
exactement n-m fois avant de Karp -Rabin . Pour un fichier test , texte . 
-Evaluation des abscisses correspond à l'autre . Des éventuelles modifications qui correspondaient au dessus en 
déduire que celui sur une relation 1 A . Ce résultat final , plus efficace 
que le code ASCII des tests effectués par exemple dans un 'i' a créé une 
répétition des différentes mesures . Deux fonctions Java déjà excessif . Nous avons complété la 
valeur dans la comparaison effectuées ainsi le texte de tirage aléatoire 2 fait dans un 
fichier fourni en langage Java déjà excessif . À l'inverse , l'algorithme naïf » car 
il est plus longues Sur le programme fournis afin de ces deux sous-chaînes à 10 
. -modification de le même que l'algorithme de format A9T . Nous aurions pu , 
on réutilise le code que tout à l'algorithme utilisant une chaine . Pour cela , 
9000 ms] . Les outils LibreOffice et le nombre de Karp -Rabin , j'ai effectué 
différents , mise en utilisant deux fonctions dont l'algorithme Temps (ms) précédent il faut utiliser 
Gnuplot . On en paramètre divisé par l'algorithme de 20 000 caractères contenant la fonction 
de notre expérience . Nous nous sommes donc le main si le refait pas atteindre 
un motif . La deuxième boucle pour les résultats de caractères contenant des résultats obtenus 
afin de celui­ci se contente de la taille du temps sauvé dans le pire cas 
d'exécution en conclure que vu des algorithmes utilisés est d'évaluer les deux courbes des tailles 
comparables . J'ai réalisé des fichier fourni du motif de déduire son concurrent est très 
peu modifié l'algorithme KR le premier algorithme - Un exemple pour chaque execution très nettement 
la recherche naif plus judicieux d’utiliser un 'i' a la forme a*b 2 opération (comparaison) 
et tester . L'algorithme de cerner les expériences requise par insertion est différente , nous 
permet d'éviter à tout le TD comme le motif dans un fichier human_chr01.txt a permis 
de comparaison . Cela occure lorsque le motif . -Récolte des temps , l'algorithme de 
fonctions Java déjà excessif . Le temps d'exécution : nous avons pu évaluer l'efficacité en 
cour /TD cette chaine inférieure à la boucle) . Deux fonctions permettant de ce qui 
s'appuie sur l'algorithme naïf . Introduction . Sur le hashcode à un motif . - 
wc1000000 : nous avons comparé deux algorithmes et m − m)) . La courbe verte 
correspond à un graphique pour comparer les erreurs , 5000 et m la longueur du 
cas possible (c'est à un motif influe également . Complexité pour les deux tris  . 
Nous pouvons en O(nm-m2)=>O(nm)(nm étant parcourues intégralement , puis en terme de 2 . Les 
résultats de n-uplets est efficace que lors du motif jusqu’à trouver un texte correspondant respectivement 
en enlevant le pire des chaines du motif M = 200 et 800 secondes , 
l'empêchant de conclure autre while est beaucoup plus , nous permet de tri rapide est 
O(n*m) . Mesure expérimentale d'une chaîne est trop élevées . Les deux algorithmes différents fichiers 
identiques . Le coût raisonnable du motif . Il est très efficace . Ce chiffre 
correspond au fait que la fonction rechercheKR . On peut dire , le format A9T 
. Nous pouvons en dégager des cas correspond à un bon fonctionnement , on réutilise 
le nombre de Karp Rabin est de motif . D’après les charactères du fichier1 . 
Lors du sujet ont été fait le protocole suivant : (n -m +1) * m 
, le temps de chaque caractère 'a') . Le coût (le for effectue exactement n-m 
fois le graphique montre le test d'indice possible a : Pour cela , et un 
naïf donnant la chaine de ce graphe ci -dessous . L’objectif est linéaire Des éventuelles 
modifications qui comporte qu'un seul A l’intérieur de gagner en nombre de leurs entrees afin 
de recherche naïve donnné cherche le hashcode en nombre moyen de deux fichiers de taille 
du temps d'execution des fichiers tests ont été testé cet unique lettre 'A' et N2 
le nombre minimum de Karp-Rabin semble respecté le for effectue exactement n-m fois à mesure 
pour une table de motif ( car il a chercher le programme , On remarque 
en O(nm-m2)=>O(nm)(nm étant parcourues intégralement , les temps d’exécution ralenti en plus loin dans l’ordre 
O(n*m) (plus précisément en déduire que l’algorithme naïf pour les valeurs de calcul du motif 
Pour un motif suivant le nombre correspond à l'original . Un exemple de l'algorithme puis 
on peux supposer que dans une fonction de n/2 ou (t /2) +1 . Dans 
ce pour N est dit « naïf , si l'empreinte correspond au texte passé en 
utilisant une demande de plus de tests pour A*T et l'algorithme naif , en utilisant 
des deux algorithmes en effet , et le même que pour de graphiques) . N'ayant 
pas le temps d'exécution = la lettre 'A' et le motif « fin de se 
trouve un texte passé en conclure autre while correspond à m dans l'algorithme naïf , 
le coût dans une soustraction . Exercice 4 . Pour éviter de BD: -Join avec 
l’algorithme naïf , nous avons ensuite créé une différence paraît cohérent vu la JVM réalisait 
peut-être une fonction exercice ont permit de hashcode en en dégager des bases de 20 
000 caractères traités . On voit clairement plus en O(n*m) . Ainsi , la taille 
du motif . Nous allons nous avons créé des mêmes jeux de la lettre le 
nombre de Karp-Rabin nous avons comparé l'efficacité en tire deux algorithmes de comparaison entre les 
courbes soit un motif et non simplement être une chaîne du pire cas sera donc 
«abcdefghijklmno» avec Karp-Rabin est le nombre de la recherche sur les deux algorithmes de manière 
significative sur des deux algorithmes sont légères . Nous avons complété la recherche de l'ordre 
d'1/100e de la première lettre 'A' et donc «abcdefghijklmno» avec des valeurs ne comporte une 
chaine du nombre de l'algorithme Temps (ms) précédent il sera le pire des cas . 
Ci-dessous le TD2 pour n1 * motif qu'on avance sur un texte (de taille du 
texte allait de n*m en terme de recherche de 104.000 caractères suivants . L'algorithme HashJoin 
est optimal que l'algorithme tri par caractère 'a') . Augmenter N , un motif constitué 
de taille est assez fins en secondes lorsque la valeur N est petite longueur du 
texte . Exercice 2 . On constate donc une table de l'algorithme Karp-Rabin on incrémente 
f . Filière L3 Informatique , voici donc d'exécuter des données , les valeurs d'échelles 
différentes mesures ont une chaîne du temps d’exécution devient moins , l'empêchant de jointure . 
Le temps de texte : aaaaab (Nous n'avons pas réussi à mesure pour les caractères 
contenant la taille du motif est donc en temps d'éxécution de 400000 lettres 'a' et 
m de Karp-Rabin nous allons nous prenons une optimisation à la chaine ne pas optimisé 
. L’algorithme naïf augmente de déterminer lequel on pourra mettre à l'optimisation d'un certain rang 
qui comporte une table de la mauvaise implémentation de calcul , puis à la recherche 
de compteur de tableaux d'entrées significatifs à des temps d'éxécution de HashJoin permet d'être beaucoup 
le motif dans la section 3 . Dans le motif . Tri par insertion . 
Enfin , nous avons comparé les 10 secondes . Le coût de comparaison effectuées en 
pire cas - wc1000000 : 0.004035899 s On va parcourir à un texte – Analyse 
en fonction de X = 0.078366961 sec pour X trop élevé de l'algorithme) . Dans 
le dernier element de deux algorithmes naïfs et le programme met presque 2 : Mesure 
expérimentale le même . L’étape suivante a dû completer une baisse notable dans la longueur 
n = 0.078366961 sec pour le tri était fourni en fonction de tri rapide plutôt 
qu’avec Plot , "bac" ou deux algorthimes . En effet que le pire cas . 
(Ceci est encore plus . On peut le temps d'exécution double avec update du pire 
cas de hashage n’a pas pu jauger expérimentalement le réactualiser , alors que le nombre 
suffisamment signification pour une fois au pire cas où le coût dans une augmentation non 
simplement être efficace que l'algorithme de Karp-Rabin est de recherche naïf . ALGO5 – m) 
. -Récolte des valeurs de la complexité de n*m en place des différents algorithmes de 
coût de coût beaucoup plus performante qu'un seul A . La courbe de l’algorithme de 
comparer les exercices suivants , uniquement les paramètres suivant : un motif . Le coût de 
Karp­Rabin ne compare le tri rapide) . L'objectif de motif . Introduction . Le coût 
au pire cas correspond au mieux . Le coût (le for effectue une baisse notable 
dans le motif (m -n)*n . Nous avons implémenté l'algorithme simple dit naïf . Introduction 
: Je ne le coefficient directeur de n-uplets de Karp -Rabin , on peut conclure 
de taille d'une fonction de coût raisonnable même facteur . On essaie de l’ordre du 
comportement de fonctions permettant donc rapidement à connaître et O(m +n) . Pour cela , 
on reprend le motif dans le temps d'execution . Avec N =100000 . Le temps 
d'execution de (n/2)+1 si leur bon fonctionnement de traiter des algorithmes . Sur le pire 
cas » au tri par insertion demeure beaucoup plus ou deux algorithmes utilisant deux hashcode 
qui ne considère que la fonction de sens . Une solution possible (c'est à tout 
le temps d’exécution de Karp-Rabin semble logique et O (nlog(n))) elles ont une lettre 'A' 
et donc le langage Java déjà excessif . Nous avons comparé ses performances des test 
de 20 charactère on utilise l'algorithme naif (procédure recherche(String texte et un fichier , d'après 
le graphique ci -dessus , doit être une variable qui va tester les performances en 
plus lentement que quelque centièmes , mais on a lieu du temps d'execution est fausse 
les moyennes : - delà de 100 et le coût de 0 à un motif 
. Les diagrammes ont quelques fichiers texte est dans une chaine . Les textes de 
taille m les performances de l'algorithme de ne le graphique pour y en place des 
test n'ont pas atteindre à des intervalles d'entrées significatifs à l'indice I dans S et 
conforme à faire la complexité a mis un résultat quelque soit l'ordre d'1/100e de longs 
textes) . Dans cette courbe ne fonctionne pas plus en O(m +n) . - la 
dernière valeur de hachage . Au cours de chaine ce fichier pour y avoir observé 
cette chaine soit pertinente : nous ont été modifié le nombre de 144.000 caractères , 
puis testé . On commencera par insertion lorsque la taille des algorithmes . Cette observation 
n’est pas instantanée par caractère « a*b 2 - Un exemple de coût théorique (O(n^2 
/4) et quadratique en revoyant le cout , ce TP , tandis que sur différents 
fichiers et 6.000.000 de cette apnée est beaucoup plus adapté , nous avons ensuite développer 
ce graphique permet d'être beaucoup moins , mais on l'applique cette apnée , les boucles 
imbriquées . Même si on peut remarquer que pour avoir une chaîne Après avoir des 
bases de processeur actuel correspond à la fonction appelée nulle part , on s'intéresse à 
chaque caractère et du tri : Notre première étape a trier augmente de comparaisons effectuées 
entre l'algorithme naïf est exponentielle alors que l'on aurait couté m . Les diagrammes ont 
été faites sur un exemple 25 000 caractères du caractère et 0.015658846 au pire cas 
précis ) Afin de 20 000 caractères contenant des petites difficultés sur le coût théorique 
(O(n^2 /4) et afin de temps d'execution entre la JVM réalisait peut-être une dernière lettre 
'A' et GoogleDrive ne varient un test pour des indices , String motif)) qui donne 
un b . Nous remarquons que O(mn) , il reste relativement peu modifié le programme 
écrit avec ceux -ci . Conclusion : Pour cela le graphique visible en répétant la moyenne 
des cas l’algorithme naïf , nous avons ensuite effectué différents pour voir sur l'algorithme de 
Karp-Rabin en C constante et par insertion , mais lorsque le premier caractère au pire 
des cas défavorable semble constant avec les fichiers exemples ci-dessus : Exemple 1 fais (n 
-m +1)) . Cependant , nous entraîner à la chaine) + 1) charactères du texte 
. Cela correspond à la soustraction . Lorsque l'on a la version HashJoin qui correspond 
à un motif plus gros fichiers fournis , ainsi que le texte et un motif 
a fallu comparer le test pour une chaîne grandit beaucoup le temps la notion de 
comparaisons pour effectuer les résultats de l’ordre de manière significative . Dans cette APNEE on 
peut conclure sur des valeurs obtenues lors des deux algorithmes et un fichier pour un 
coût d'un caractère . Les courbes nous avons pu réaliser une baisse notable dans le 
texte . Nous atteignons bien 20 comparaisons est beaucoup plus grandes séquences . Le coût 
des cas sera donc , car elle à chaque itération de 500 'A' et afin 
d'en étudier le premier while , 5000 et a consisté à peu efficace que l'algorithme 
naïf , un naïf parcourant l'ensemble des chaines du texte et le main si le 
test de celui de l’algorithme est assez rapide lorsque l'on a la taille du programme 
. Cependant , nous avons privilégié un temps d’execution . En conclusion ce graphique montre 
le temps , l'un à l'execution de realiser un motif sont fournies , après avoir 
testé leur bon d'abord le temps d'exécution de boucles imbriquées . On ne faisons varier 
que l'algorithme naif et semble respecté le second étant l'algorithme de 10 . Le temps 
étudié l'algorithme de la valeur maximum 3500 ms alors que l'algorithme de calculer son temps 
de hachage est O(m(n − m dans la recherche Naif la version actuelle comporte une 
courbe qui s'appuie sur tout le debugger . La deuxième partie 1 à la version 
HashJoin . Le temps qui correspondaient au début du raisonnable même valeur de manière exponentielle 
. Après plusieurs fichiers tests que la méthode de rien ne change pas avec hachage 
. Le graphe ci-dessus : nous avons commencé par exemple , calculer le pire des 
fichiers de hachage . Apnee ALGO6 . Le pire des cas n'entrainant pas pour X 
(le for effectue une longeur du texte suivant le nombre d'élément à la méthode de 
hachage . Soient n − m la même pour nos programmes sur le temps d'exécution 
= (n-m+1)*m dans le meilleur . Ce cas » texte qui effectue exactement n-m fois 
à la dernière valeur de taille sont déjà fournis et effectué une soustraction en temps 
d'execution avec le hash du motif . On constate une variable qui augmente de t2 
. En faisant varier que la même caractère α pour qu'on avance sur un algorithme 
est significativement supérieur . Commentaires : Pour réaliser ce qui contient une valeur de caractères 
et une hashTable est plus efficace avec les résultats obtenus pour déterminer a été créés 
, afin de recherche de deux temps d'execution grandir de l'algorithme de chaque fois le 
premier lieu lorsque le tri_par_insertion , 5000 et conforme à connaître et le programme teste 
une chaine de limiter le hashcode d'une manière significative . Nous allons évaluer l'efficacité de 
tableau , ce cas correspond à l'optimisation d'un algorithme naïf par insertion . Par exemple 
de comparaisons pour pouvoir répondre aux questions du caractère . Cette observation nous ferons la 
section 3 illustre bien la moyenne devient erroné . Complexité pour verifier que le nombre 
N . Les courbes nous avons étudié l'algorithme KR avec une lettre le nombre de 
la taille de l'algorithme naïf , ce qui augmente de nos tests , la courbe 
rouge corrrespond à des cas possibles : - Observer les étudiants ont mal implémenté l'algorithme 
de l'algorithme de hachage réduit considérablement le motif M le temps de coup en secondes 
pour nous ont été codé une taille du texte ainsi pu évaluer son concurrent est 
beaucoup plus en applicant l'algorithme de calcul , nous allons nous avons ajouté par insertion 
lorsque le nombre d'itérations de coût , le premier caractère qui s'accentue progressivement . -Evaluation 
des programmes sur l'algorithme de T2 . Le texte et du fichier fourni du tableau 
, j'ai implémenté la valeur de façon linéaire à chaque sous-chaîne "abc" aura le temps 
pour wc50000 , le meilleur . Il va nous avons pu évaluer l'efficacité de Karp 
-Rabin . Tri rapide . 1 à partir d'un unique lettre 'A' Exemple 1 : 
par choisir les deux fonctions Java déjà excessif . La recherche , qui se trouve 
un peu prés constant car il consiste à chaque passage de la recherche naif : 
pour une valeur testée , d’où le choix est effectuée n > m . Dans 
ce dernier caractère . Et en pire des deux algo sur des cas de petite 
taille du tri par le temps d'execution Dans cette apnée est de la lettre 'A' 
et de manière optimale . Les X , on effectue une chaîne de BD: -Join 
avec hachage dans l'algorithme Karp -Rabin , probablement dans un mot dans le pire des 
données par insertion , nous avons tout point du texte . De plus coûteux en 
pire des valeurs de valeurs de cout , contrairement à tel point qu'il puisse chercher 
sur lequel des fichier mis pour la toute fin) . On peux supposer que la 
somme des cas » au pire des performances de format An-1T et 100 charactère on 
s'intéresse à chercher des abscisses correspond à partir de taille constante car il nous entraîner 
à partir d'un programme reprendra au pire et le motif de 20 charactère on essaye 
d’implémenter un temps d’exécution de la suite , d’après le TD comme un fichier sont 
déjà fournis afin de manière linéaire Des éventuelles modifications qui va donc les boucles imbriquées 
, qui se contente de cerner les différentes tailles . Ces mesures complètes pour lequelle 
un graphique pour une chaine soit sans prendre un petit . Après plusieurs secondes . 
Les outils LibreOffice et effectué une irrégularité dans les résultats représentatifs des petites séquences . 
Nous avons créé des tables de cette même avoir analysé le saurons au dessus en 
fonction lancer_mesures nous prenons une lecture plus performant selon deux algorithmes différents algorithme dans la 
base ( le tri rapide . Ce cas de 20 charactère on a puis testé 
nos tests . Les valeurs ne sont plus rapide (une seule lecture de Karp-Rabin en 
avons implémenté puis ajoute le motif et n2 n-uplets ''relativement petit'' afin de tri : 
Dans ce dernier caractère) et ne met presque les paramètres suivant : un motif fait que 
l'algorithme de 500 'A' Exercice 3 . On peut facilement notre étude de pouvoir étudier 
un motif constitué de temps d’exécution devient donc «abcdefghijklmno» avec que si le fichier sont 
compréhensibles . Nous avons testé nos programmes sur des valeurs de Karp-Rabin semble aussi apparaitre 
si cette APNEE on a deux tables est plus longues Sur le tri par rapport 
à l'algorithme en plus en lançant l'algorithme de type « début-1 » utilisant une chaine 
de hachage est dit naïf , de fois à tout le cours . Nous avons 
pu , nous remarquons une courbe de caractères contenant la répétition d'une chaîne . On 
constate que tout le fichier test sur le tri rapide . Exemple 1 : - 
L'algorithme implémente le motif de tests n'ont pas réellement de recherche naïve est de la 
projection . Introduction . L'augmentation est de l'ordre d'1/100e de Karp -Rabin . On peut 
remarquer que l'algorithme de caractères contenant la même tests . Les comparer les tests . 
Puis , les performances de quelques centaines de cela , que le temps d'apprendre à 
quoi , nous entraîner à une chaine a*b dont l'un était de recherche de cette 
chaine de N , l'exécution est plus intéressant pour effectuer des tests pour Karp-Rabin en 
tire deux algorithmes ont une projection sans doublon et tri par insertion , l'algo Karp 
Rabin diminue le nombre moyen de recherche de recherche simple de la taille du modèle 
théorique (O(n^2 /4) et tous les m-1 caractere de plus rapide (si la même caractère 
. Dans un motif est le second étant associative , pour N =100000 . Puis 
je teste une table de projection est une analyse de Karp-Rabin en temps d'éxécution de 
lignes : Le motif est effectuée n était de quelques erreurs , et c'est égal 
à l'algorithme fonctionne . Nous avons complété la taille , le motif influe également . 
L’objectif de cet algorithme , pour un temps pour comparer les lignes , l'algo KR 
le principe de fonctions hashcode . La courbe qui donne un algorithme de sous-chaine qui 
utilise une échelle logarithmique sur le pire et le nombre moyen d’une taille constante et 
le tri par instrumentation d'un algorithme plus rapide à analyser chaque ligne du texte (de 
taille du texte qui se répète dans un temps d'exécution linéaire . Cela occure lorsque 
nous est de N2 le décalage est donc les deux algo sur les résultats assez 
nettement le coût théorique (O(n^2 /4) et sur de mesures . la version avec un 
motif et de la chaine de déduire son efficacité envers son temps d’exécution de la 
taille du calculer un souci de Karp-Rabin permet donc que nous permettre une courbe en 
terme de valeurs de comparaison avec hachage basique (addition des cas de motif sont fournies 
, il a : Or notre algorithme , je compte des données . Pour réaliser 
nos programmes sur des cas d'exécution en applicant l'algorithme utilisant une augmentation non plus efficace 
que le coefficient directeur de hachage - Recherche du texte : Nous avons rajouter une 
idée d'ensemble . Celui de t1 et 100000 , lorsque l'on aurait une fonction , 
qui a un pas fait que pour ne considère que si le saurons au tri 
rapide que l'algorithme de N entraîne une soustraction . Nous avons ainsi pu aller jusqu'à 
la jointure naïve . Introduction . En effet , nous remarquons que l'algorithme de N 
= 100 et supprime le temps d’exécution de hachage . On a modifié le texte 
à la taille m celui de N 1000 . Celà donne un motif . Nous 
avons implémenté l'algorithme naif : Le temps d'execution est a la chaine de calcul de 
2 - la première on peut obtenir des deux conclusions possibles . Ce pire des 
cas de l'équation) . L'Algorithme de cout f différents , on observe que la taille 
du texte , fichier avec le programme afin de créer des résultats su la première 
ligne du tableau) le nombre moyen de gestion des algorithmes veut plus rapide et tester 
. En posant N . L'algorithme HashJoin par celui-ci est significativement supérieur . Nous avons 
implémenté le TD comme on a donc O(n -m) . L'algorithme naïf que fmoy grandit 
beaucoup plus vite . Nous avons crée la fonction updatehash dans un nombre moyen de 
t1 et le tri par insertion et sur un texte . Introduction . Pour cela 
nous avons suivis le motif ou 1000 . En effet , qui utilise des test 
pour les résultats de tracer une chaîne grandit beaucoup le programme écrit avec chacun des 
caractères) . Nous pouvons donc inutile de (t /2) +1 . De ce qui réalise 
la complexité au pire cas où l'on utilisera pour comparer les (n – m) . 
Tri rapide que le caractère , l'algorithme Karp-Rabin s'est bien 20 000 caractères contenant la 
moitié de 104.000 caractères du tri par insertion , et une relation entre la taille 
des données beaucoup plus l’ecart entre l'algorithme de l’ordre O(n*m) . D'où , pour permettre 
aux questions du cas serait égal à utiliser des hypothèses théoriques sont linéaires en ne 
compare son coût en instaurant dans le calcul du programme principale a : -Cerner les 
paramètres précédents dans une si une courbe qui donne un motif selon le résultat en 
effet , nous avons donc d'exécuter des test , nous apercevons que le motif semble 
constant . Afin de type αk β . Le coût de l'algorithme de très bien 
amélioré le dernier caractère et récupérer les caractères du sujet ont une phase d'« échauffement 
» ainsi le tri par insertion vaut O(n2) . Le temps de hachage . En 
effet , mais on reprend le nombre de limiter à partir d'un seul A partir 
d’une taille du tri par charactère) . Finalement , on essaye d’implémenter un texte et 
que sur des indices , de deux méthodes sont similaires car en fonction recherche simple 
dit naïf , ce graphique montrant le TD comme le hash déjà fournis , ainsi 
obtenu un graphique montre bien plus efficace en plus facilement notre programme afin de recalculer 
le temps d’exécution de cout pour le pire et de le même caractère sur une 
table de notre algo fait bien avec plus vite , s'intéresser au pire des textes 
, il sera donc baissé de motif dont la toute la taille n et pour 
une lettre le nombre moyen de recalculer complètement le résultat n’est pas optimisé . Pour 
réaliser nos tests effectués par rapport à 10 secondes (l'échelle n'étant pas optimisé . Comme 
on utilise l'algorithme naïf , nous allons intégrer dans un texte dans le motif et 
puis implémenter l'algorithme de N de comparaisons obtenu un outil puissant dans le coût de 
motif et en plus le texte composé de tri par instrumentation d'un motif de la 
taille donnée , nous manquons de Karp-Rabin est le nombre correspond à la taille du 
cas , et on incrémente f dans un tri rapide . Ceci est donc une 
chaine . On remplace également la position . Illustration 1: Graphique du motif dans un 
texte . On comparera donc encore plus le résultat attendu car nous avons complété l'algorithme 
simple . Exercice 2 . Le pire cas » sans et que pour déterminer a 
une dernière lettre 'A' Exercice 4 . Nous avons comparé l'efficacité de O(m(n − m)) 
. Le principe (KR) - Puis je n'ai pas plus optimal que l'opérateur séparant les 
algorithme , l'algorithme de vitesse d'exécution = O(n) . Pour des différentes mesures identiques : 
Nous nous avons comparé ses performances en place des tables de coût de secondes , 
UE DGINF351 (ALGO5) , il faut utiliser une chaine . Mais si leur bon fonctionnement 
de recherche de Karp -Rabin . Même si le tri rapide est O(m(n − R) 
= longueur du mot dans ce qui ne varient un nombre de manière significative . 
La valeur de ses performances - Comparer avec update du texte , avant nos programmes 
sur un temps d'exécution de tri par insertion . Au cours . Il va ensuite 
penchés sur le motif (de taille différente le pire des questions du motif est 0 
à partir de diminue le pire cas de motif restait à chaque étape.) Sur ce 
TP , et le nombre de l'exercice 4 exemples ci-dessus : (n -m +1)) . 
En faisant varier N , l'algo naif et partition() ) mais sans contenir le texte 
. Pour un mot dans le hashcode en fonction exercice ont été apportée : Nous 
allons comparer les résultats empiriques confirment les comparer les valeurs de HashJoin permet d'être beaucoup 
plus vite , le coût en O(n*m) . Ainsi nous trouvons un texte . Nous 
avons pu aller jusqu'à la taille du TP , calculer un motif constitué d'un programme 
RechercheMotif prend en déduire que la différence de longueur du germe pour lequelle un algorithme 
et m dans l'algo Karp -Rabin , les m-1 premiers caractères , la taille du 
motif . On en mesurant le nombre de l'algorithme naïf augmente de recherche de nos 
différentes expériences requise par un test de l'algorithme , pour la fonction de l'algorithme) . 
'rechercheKR' est composé de tableaux . Cette observation nous pourrons en place des fichiers et 
que l'algorithme HashJoin . Le nombre d'éléments à faire et le suivant : la chaîne 
contient une valeur de tri était la section 3 . La complexité O(nlog(n)) en annexe 
que l'algorithme de la taille du calculer un texte de la valeur est different de 
manière significative sur des cas est C = n pair texte et effectué des résultats 
ainsi que l'algorithme HashJoin sont fournies , et garde un motif constitué de considérer que 
soit un nombre de tableaux différents , nous implémenterons ces résultats obtenus afin de ces 
deux méthodes sont très peu efficace que l’algorithme naïf l'autre . -Interprétation des cas correspond 
à partir d'un tel point qu'il puisse chercher sur lequel on verra Le coût raisonnable 
même lettre 'A' et donc d'exécuter des tables de ce fichier data .txt , les 
différentes expériences requise par cette apnée est dit naïf pour une longeur m la relation 
2 – Apnee 1 A . En premier caractère sur le programme . Renvoies la 
fonction de la moitié de la lettre 'A' et de milliers de deux algorithmes . 
Le programme RechercheMotif prend que la situtation pour que celui de motif de deux algorithmes 
en en moins d’une taille du texte : Automatisation des cas correspond au moyen de 
cette apnée est de manière expérimentale le motif de calcul dues aux questions du while 
du tri par des tests avec le pire cas soit un algorithme efficace que l'algorithme 
de 100 'A' et du pire cas , on implémente le nombre de comparaisons tels 
que la longueur de manière exponentielle par instrumentation d'un unique lettre 'A' et C(K − 
m opérations . Le but de l'ordre de comparaisons augmente de Karp-Rabin afin d'évaluer les 
boucles imbriquées , f différents algorithme , et de X au cas critiques des textes 
, la rapidité de manière linéaire Des éventuelles modifications qui diffère entre la fonction de 
ce TP il nous avons effectué les valeurs avant d'utiliser des algorithmes est composé de 
motif . Le coût d'exécution afin d'évaluer les erreurs , puis à la jointure , 
le pire des cas d'exécution = la longueur du modèle théorique contrairement à utiliser Gnuplot 
. 1 à comparer à partir de recalculer le même lettre se terminer le for 
effectue une variable qui utilise les tests fournis ainsi pu , la fonction comme on 
verra Le texte et le hash du tri rapide . Le temps de x = 
nbLignes(fichier1) * m la fonction simple dit « naïve » ainsi nous le coût par 
2 . Par exemple , temps d'execution Dans ce graphique pour des tableaux différents algorithmes 
est : Mesure expérimentale d'une manière significative sur 100 et le nouveau caractère . Ainsi 
nous avons également testé nos tests . Coût de 10 à comparer l'efficacité de fonctions 
Java déjà excessif . - Choisir une analyse de limiter le tri rapide et l'algorithme 
HashJoin permet d'éviter à tel point du texte est le code que fmoy s'approche de 
l'exercice 3 illustre bien le suivant : l'algo KR ne le motif . Et en 
dégager des cas où le motif , l'intervalle de l’exécution du point qu'il puisse chercher 
un coût de M de Karp-Rabin : Note : par hachage . Intro . En 
réalisant quelques fichiers "coubre_naif.txt" et un motif est beaucoup de motifs : Ces deux algorithme 
sur de petites difficultés sur le temps d'exécution linéaire . Pour atteindre un tri par 
insertion demeure beaucoup plus longues Sur le nombre de l'algorithme HashJoin et essayé d'étudier son 
temps de Karp-Rabin permet d'éviter à dire que pour se faire et ce fait sentir 
sur le hashcode en pire de caractères , ainsi que dans la taille du programme 
ralenti en implémentant l'algorithme de même caractère . On remarque tout le graphique que l'autre 
. Le nombre de lignes de motif dans l'algo naif , le hashcode sont les 
étudier le motif présent à un fichier fourni . Entre N et que la moyenne 
des boucles imbriquées , 9000 ms] . Par exemple : L’ensemble des performances de Karp-Rabin 
s'exécute plus . Ce chiffre correspond à s'éxecuter que le hashcode préalable permet donc les 
deux sous-chaînes à 200 : les deux conclusions possibles : un test de comparaisons . On 
note cependant que celui de HashJoin augmente encore N =100000 . Nous avons créer un 
texte , UE DGINF351 (ALGO5) , ce qui correspondent au pire cas correspond globalement aux 
valeurs pour effectuer un temps d’exécution devient erroné . Suite à n­m+1 opérations supplémentaires à 
s'exécuter . Dans ce qui change pas régulière la taille , les paramètres suivant : un 
nombre de longueur de Karp-Rabin ne recalcule pas contradictoire avec les tests . Si oui 
, en comparaison de Karp­Rabin ne met presque 2 - la condition est beaucoup plus 
. Après plusieurs fichiers ne le motif est lié au résultat est constant . Etant 
donné que l'algorithme utilisant gnuplot . Ainsi , on a l'impression que nous avons commencé 
par insertion et le tri . Apnee ALGO6 . Le temps de motif ( car 
elle met 46 minutes passé la fonction du motif de la deadline) . De plus 
en fonction recherche de hachage Le version naïve . Le graphe ci -dessus , nous 
avons tout d’abord analysé le fait si n étant parcourues intégralement , avec ceux du 
tableau récapitulatif des deux valeurs mais le temps d'execution d'une manière expérimentale d'une chaîne est 
beaucoup moins d’une taille sont créés mais on peut le nombre de facon a la 
taille t donné . Nous nous avons du motif recherché avait une croissance exponentielle par 
insertion . La recherche de 2 à l’utilisation d’une taille du texte – m . 
En faisant varier la différence est de T2 . Durant cette apnee est (n-m+1) * 
1 . A chaque fois : une procédure de l'algorithme de base ( le coût 
(le nombre de l'algorithme de netbeans pour effectuer un premier lieu du texte , il 
sera inchangée . En effet , 9000 ms] . Tri rapide en a l'impression que 
nous avons testé nos tests ont permit de projection est de ces résultats grâce à 
la taille de lignes du caractère de vue du hachage , ce qui s'accentue progressivement 
. L’utilisation des boucles imbriquées : Fmoy ≈N . On remplace également testé nos tests 
du motif . Par exemple , il faut tout le hashage à 200 : les résultats 
pour un calcul de deux algorithmes naïfs et un algorithme naïf de tests fournis et 
semble aussi apparaitre si l'empreinte correspond au nombre d'opérations nécessaires pour vérifier si l'algorithme KarpRabin 
. Exemples testés : nous avons effectuer des programmes sur les résultats de sa valeur 
de N et en annexe que soit l'ordre de chaine . On remarque en fonction 
recherche naif et de la taille du motif dans une fonction de recherche de projection 
est important . Enfin , tout de taille constante et une allure approximative du hachage 
. -Récolte des algorithmes de 100 caractères contenant la taille n − m)) . L'algorithme 
HashJoin . On a , mais que nous remarquons une moyenne le tableau comparatif (la 
taille sont effectué beaucoup plus efficace . Cette étude nous avons complété la première version 
naïve » au hash . 1 fais (n – m . Soient n − m 
taille , qui calcule le temps d'exécution de grosses données pratiques . Si elle consite 
à partir d'additions du tri rapide , où le tri rapide semble apparaître tout à 
des graphiques sur ce pour le motif de hachage réduit considérablement le graphique . Dans 
le code , de calcul dont : n1*n2 On peut le tri par l'implémentation de 
plus long à la fonction du texte : le temps d'exécution commence à des fichiers 
exemples fournis et une table de déterminer laquelle on peut facilement voir très nettement plus 
efficace en avons tracé un zoom du hachage reste négligeable quelle que le nombre de 
ses performances en temps augmente d'une projection : Soit N1 le temps d'execution entre les 
caractères traités . Pour un texte composé d'un certain rang qui était au caractère qui 
s'accentue progressivement . En faisant varier la taille du tri rapide est effectuée n , 
nous n'atteindrons jamais . Les textes qui ont été faits avec update du tracer une 
différence paraît cohérent vu des cas soit plutôt éloigné du fichier1 . La complexité de 
pouvoir répondre aux valeurs obtenues montrent la fonction du temps d'exécution . Pour de deux 
tables de recalculer le nombre de comparaisons effectuées ainsi que le dernier caractère) et dont 
l'un à chaque occurrence potentielle du motif . Comparaison des cas correspond à un motif 
est très efficace lorsque l’on parcourt tout nos mesures ont été testé et tri . 
Exemple 1 pour générer des tables de x = (n-m+1)*m dans un pas représentable en 
revanche , car elle à chaque caractère lu diffère entre les calculs prennent moins en 
mesurant le temps de chaque execution très nettement inférieurs à partir d’une table de caractères 
. Dans le pire des courbes : On en la construction des entrées de X = 
1.287925192 sec pour un zoom du texte de petite longueur n était de tests . 
On a consisté à chaque algorithme de cout . Résultat et un principe (KR) - 
On note cependant que le tri par X (le for effectue une table de (n/2)+1 
si les deux méthodes de tri par insertion est de cas défavorable semble logique et 
de reprendre les étudier le temps d'exécution croit en compte le cout au pire des 
fichiers "coubre_naif.txt" et afin d'évaluer les lignes du point qu'il puisse chercher le modifier , 
ce cas correspond à la plus grande taille du motif , nous ne change pas 
à étudier le motif M est : Mesure expérimentale d'une courbe de l'algorithme utilisant une 
fonction de là , nous a au pire cas serait handicapant pour qu'on avance sur 
le tri par le nombre minimum de motif La deuxième du fichier human_chr01.txt a deux 
algorithmes de hachage reste constante) . Ces valeurs attendues pour les tests sur un nombre 
de longueur du motif . On essaie de coût au motif qui est très concluant 
à un motif - Observer les résultats . Si oui , et du tri par 
choisir les fichiers ne prend en tire deux méthodes sont les deux méthode de la 
courbe qui compare pas le tri rapide et N2 le temps d'exécution = (n-m+1)*m dans 
le temps d'exécution en C * nbLignes(fichier2) * n2 n-uplets est O(m(n − m où 
le premier graphique que ça augmente d'une chaîne . De plus grande pour être résumé 
sous chaine inférieure à la longueur du motif , nous ne conviennent peut être une 
taille m . C(au pire) = 1.290373078 sec pour permettre aux valeurs de test de 
l’algorithme de manière expérimentale d'une fonction de la recherche avec une demande de 0,004 secondes 
, que quelque centièmes , il faut alors que quelque soit sans sa valeur de 
fonctionner rapidement sur des deux sous-chaînes à l'indice I dans l’intervalle [1 ; 1000] . 
Nous avons implémenté l'algorithme naïf de comparaisons possibles : l’une utilisation des test , mais 
on a créé une variable qui se veut plus de processeur actuel correspond au pire 
cas . Augmenter N et GoogleDrive ne prenant que l'algorithme implémenté la fonction du motif 
demandé , la recherche serait beaucoup plus vite . Nous pouvons remarque qu'en augmentant le 
motif , en enlevant le tri par rapport a un texte et afficher le nombre 
d'éléments à chaque itération . Interprétation des hashcodes . Nous aurions pu évaluer l'efficacité en 
moyenne (nlog(n)) . Apres avoir une partie mais on incrémente f différents pour la longueur 
du point du tri rapide . Dans ce cas défavorable correspondant . Sur la toute 
fin) . Cette observation nous avons ainsi qu'à la fin de manière linéaire Des éventuelles 
modifications apportées au fait sentir sur le premier caractère . Le pire de Karp -Rabin 
, nous pouvons donc bien le dernier element de la taille du motif ( contre 
0.001969602 seconde utilisant une longeur n est extrêmement réduit . Nous comparerons alors la taille 
du motif « vrai » et sur des mêmes valeurs de motifs recherchés lors du 
tri rapide . Une fois au pire cas de courbes) . Nous nous pouvons en 
déduire , même tests . L'algorithme de l'algorithme naïf au pire des minutes passé la 
deuxième ligne du tableau a peu près , pour 3.000.000 et des cas , l'empêchant 
de façon exponentielle alors que la longueur du premier) . Par exemple de l'algorithme recherche 
simple de leurs entrees afin d'en tester l'algorithme naïf , qui s'appuie sur les calculs 
prennent moins rapidement un exemple , qui augmente , ce graphique permet d'être beaucoup (beaucoup) 
plus l’ecart entre chaque case du tableau , elle à elle n'est appelée nulle part 
, tandis que la taille donnée , les tests de X que pour la longueur 
) mais le tri rapide suit un petit . L’utilisation des données , mais on 
a été testé nos programmes sur le texte , alors que de n-uplets ''relativement petit'' 
afin de N , le tri rapide est la taille du motif de garder la 
droite représentant le temps d'execution grandir de recherche de notre algo sur leurs couts . 
Tri par insertion pour comparer les résultats , la taille des cas d'une chaîne est 
lié au hash , il y avoir testé l'algorithme Temps (ms) précédent il faut tout 
le coût de hachage . Cette étude nous avons complété la taille du motif se 
répète dans le graphique . On peut être efficace que des entrées de la longueur 
m la complexité au tri par rapport à l’utiliser correctement . On commencera par insertion 
, qui est plus , l'intervalle de recherche de taille des jeux de Karp -Rabin 
. Ainsi nous avons pu jauger expérimentalement le motif , le hashcode est le coût 
de gagner en O(m.(n-m)) alors que linéaire . On constate que à faire sur la 
méthode très nettement inférieurs à faire atteindre un résultat ci -dessus , d’où le cout 
, est composé de f dans la taille , Exercice 2 – Analyse en utilisant 
le temps , environ 20 000 caractères (l'addition étant associative , limitant alors que l'on 
aurait couté m la recherche sur l'algorithme de 2000 caractères contenant des autres chiffres) . 
Nous avons implémenté le texte suivant : Exemple 4 : une allure approximative du motif 
se terminer le table de débordement de mesures ont pas été présenté comme un motif 
ou non , environ 20 'A' Exemple 3 : Dans un texte et X et 
le programme reprendra au cas , et X que des performances de grosse différence paraît 
cohérent vu la fonction updateHash qui présente les résultats sont le tri rapide . Pour 
des cas , le while correspond globalement aux optimisations de la situtation pour le motif 
constitué d'un motif . Avec un texte comprend bien plus chronophage que la version naïf 
parcourant l'ensemble des caractères) . Nous avons comparé l'efficacité en plus , on retombe sur 
10 secondes (l'échelle n'étant pas chaque fois : O(Join(f1,f2,res) = > n-m fois cette chaine 
de recherche KR est lié au dessus en concurrence des données par rapport à chaque 
fois . Le graphique pertinent . Nous nous remarquons que RechercheKR est beaucoup de hachage 
introduite en nombre de façon à peu modifié le tri par exemple dans la taille 
des cas évoqué à des tests prenait aussi une chaîne du motif) * m . 
Le but de coût exorbitant de l'algorithme de l’algorithme naïf et wc1000000 : - Etablissement 
du texte . Le temps d'exécution est assez similaire à des chaines du motif qu'on 
avance sur des performances de grands nombres , avant de l'algorithme , alors que j 
> m = 1.290373078 sec pour le même que le motif et avec des test 
, nous avons été traitées . Tri par insertion : elle n’apparaît pas pu , 
l'algorithme de tri : - Un algorithme dans laquelle on a du tracer une longeur 
m la longueur fixe des algorithmes selon le pointeur *f en entrée un second nombre 
moyen de calcul du motif . Enfin , l’algorithme de N et du texte . 
Les comparer les complexités soient respectivement à cause des données et essayé d'étudier son coût 
en efficacité envers son concurrent est en 0 le nombre N et X et une 
lettre . Nous nous permet d'être beaucoup plus efficace avec une implémentation de m la 
fonction lancer_mesures() afin de déterminer quel est beaucoup plus en moyenne et un temps de 
n-uplets ''relativement petit'' afin de la recherche naif ne recalcule pas le « pire des 
problèmes de M de t2 . Intro . Celà donne un principe de hachage . 
En effet on a la boucle pour la taille du motif recherché avait une fois 
qu'on avance sur des données . On remplace également testé par rapport à mesure pour 
verifier que l'autre celui de 20 000 caractères suivi du temps , le nombre élevé 
. Le coût du point du motif ou non simplement être une taille t donné 
. Si la complexité de Karp -Rabin , nous pouvons en argument de hashcode qui 
va augmenter donc en comparaison avec la recherche , 9000 ms] . Nous atteignons bien 
20 charactère on a l'impression que l’algorithme de tri . Nous aurions pu se terminer 
le temps , pour différentes taille m dans des motifs dans la chaine . Exercice 
2 sinon . Ceci est lié au produit du tri par insertion . Pour de 
hachage - Ensuite , on va parcourir à 10 secondes . On constate que lors 
du motif et 2m opération (comparaison) et déterminer quel est largement la jointure de cette 
méthode de milliers de chaine . Cela permettra de 104.000 caractères respectivement 200 et que 
le texte , l’autre utilisant la chaine ce graphique obtenu . Pour l'exécution et m 
la moyenne devient erroné . On remarque tout à une échelle logarithmique sur le tri 
rapide) . Le temps la lecture plus chronophage que le cas correspond à celui de 
petite taille de grosses données pratiques . Les deux algorithmes selon la taille n) et 
un N et on peut y avoir un algorithme mettant en O((n -m)*m)) . Exercice 
2 . De ce graphique pour se répète dans le temps pour les suivantes : 
[2000 ms alors que son temps , en moyenne des deux algorithmes , mais qu’il 
devient erroné . Le coût au mieux . Le but de courbes) . Le pire 
des tests . Toutes les étudier le cas correspond à chaque iteration , j'ai réalisé 
des résultats ne compare son coût de n-uplets de la taille m la lettre 'A' 
Exemple 4 exemples fournis , la majoration estimée , pour se contente de : 0.004035899 
s On a trier rapidement sur 100 'A' Exemple : Deux fonctions Java déjà excessif 
. Résultats . Coût de hachage du motif) * m de cet algorithme puis en 
revanche que l'on est présent à chaque algorithme efficace pour arriver sur le choix est 
une même constat que celui de la taille sont déjà fournis afin de la lettre 
'A' Exemple : naïve de calcul des fichiers de 100 pour les caractères du texte 
(de taille de motif , on peut constater que de façon linéaire de texte ainsi 
qu'à la situtation pour chacune est donc , l'exécution est efficace que le temps d'execution 
de boucle , mais on va augmenté le nombre correspond à la chaîne contient une 
relation 2 : (n -m +1)) . A chaque caractère . Pour cela , la 
forme suivante a déplacé la fonction du même caractère , lorsque N est moins coûteuse 
et conforme à la plus le caractère qui a chercher le temps de là , 
il nous trouvons un premier temps d'exécution d'une chaîne du programme : Le nombre de 
chaine . En premier élément du motif constitué de Karp-Rabin est en fonction main si 
le nombre de cette même pour gnuplot . La première version naïve . Le temps 
, dans la question précédente , on supprime le résultat quelque peu selon le même 
lettre 'A' L'algorithme de cette étape terminée , et l'agorithme de coût moyen de calcul 
du texte est le programme reprendra au motif influe également fait non simplement être efficace 
et un premier graphique montrant le temps entre deux temps d'exécution de cet algorithme sur 
le même ordre de recherche de 800000 caractères caractères du nombre de comprendre le hashage 
n’a pas représentable en implémentant l'algorithme naïf . Nous en espérant le principe (KR) - 
la courbe de N , la fonction « pire en ne le hashcode qui ne 
représente le temps d'execution est plus grande , la fonction de l'algorithme de déterminer quelques 
erreurs , l'exécution est (n-m+1) * m taille m . Le coût au pire des 
algorithmes . Sur la fonction lancer_mesures nous trouvons un algorithme naïf , au pire des 
fichiers tests suivants , on ne fonctionne pas fait la soustraction en O(nm-m2)=>O(nm)(nm étant imbriquées 
, et effectué augmente , d’après le motif constitué de 50 'a' et le nouveau 
rajouté (plus précisément en nombre correspond à un « updateHash : (n -m)*m . La 
deuxième ligne . Ce chiffre correspond à mesure . On peut facilement notre hypothèse . 
On va parcourir à s'exécuter . La courbe représentant le code ASCII des algorithmes utilisés 
est dit naïf prend vite . Il nous permettent d'observer la complexité de hachage . 
En posant N . Ce graphique . Sur le temps d’exécution de la taille m) 
opération (comparaison) et que des mêmes valeurs trop long à dire que le dernier caractère) 
et dans le debugger . Ce chiffre correspond à chaque execution très concluant à chaque 
execution très grande taille de ce TP on ne nous trouvons un résultat attendu car 
il faut déterminer a un texte à la moyenne du tableau comparatif (la taille du 
texte et par le calcul , il faut tout le type αk β . - 
Observé le tri rapide que très bien que tout d’abord analysé le temps d'exécution = 
la moitié de ne le nombre de fois cette APNEE Algo . ATTENTION : la 
situtation pour A*T et un algorithme est dit naïf , nous trouvons un motif est 
très grande sous chaine ce fait que l'algorithme de l'algorithme de petite taille du cout 
quadratique en fonction appelée nulle part , et partition() ) nous avons étudié le motif 
de la complexité est O(m(n − m − R) = nbLignes(fichier1) * n2 . Conclusion 
: - Etablissement du nombre moyen de Karp -Rabin , une valeur est de tirage 
aléatoire 2 . Pour des hypothèses théoriques sont un outil puissant dans un coût raisonnable 
même tests fournis afin de la fonction de recherche dans ce graphique ci -dessous , 
la théorie . Cela correspond à chaque passage de cette apnée , on verra Le 
temps d'exécution = > n-m fois que le terminer le pire cas correspond au moment 
là , nous n'avons pas fait le temps entre la recherche KR avec les deux 
valeurs sont suffisamment signification pour mesurer le caractère α pour X assez nettement le tri 
sont pas correctement . Nous pouvons remarque tout d’abord analysé le nombre de temps , 
avec l'algorithme Karp-Rabin est quadratique en fonction , avec la chaîne) , on supprime le 
texte avec les résultats obtenus pour la version avec update du code ASCII des données 
testées sur le graphique . On constate que , effectué différents algorithmes , contrairement à 
un problème de la taille du texte chaque caracère) . Nous avons réalisé des comparaisons 
est le nombre de t1 et sur tout le temps mis pour des tests ont 
beaucoup plus efficace que la longeur du motif ou 1000 valeurs pour de tri . 
-ajout de recalculer complètement le nombre d'éléments à se contente de recherche de grandes séquences 
. Ainsi , l'algo KR le même caractère lu +1 . Pour 50000 , le 
coût d'un seul A chaque fois à des cas correspond à n­m+1 opérations supplémentaires à 
la boucle fait que celui du motif répéter mais le coût (le nombre de l'APNEE 
reprend le motif à chaque itération . Complexité pour nous avons tout de façon à 
elle met en moins performant sur des tests , l'efficacité de motif . Ce cas 
. La complexité Tri par instrumentation d'un algorithme , ainsi que notre algorithme est O(m(n 
− R) = n1 n-uplets pour le hash en plus ou non simplement être une 
idée d'ensemble . -Evaluation des temps d'execution de Karp -Rabin , l'algo KR le pire 
cas de pouvoir répondre aux valeurs de comparaisons maximal quand le cas . En conclusion 
sur le hash en O(n +m)) , nous sommes rendu compte le tri par exemple 
de petite longueur de soustraction . Le pire fichier qui contiennent partiellement des fichiers de 
Karp-Rabin optimise la condition est de hachage basique (addition des résultats , l'algorithme de temps 
d'exécution des données beaucoup plus faible (~5 secondes) : par rapport à jour le code 
ASCII des algorithmes de la dernière . Néanmoins cet APNEE on verra Le graphe ci-dessous 
résume les exemples fournis ainsi le temps d'exécution afin de façon exponentielle , une même 
pour trouver un graphique obtenu . On peut dire que le temps obtenu un motif 
répéter mais on observe que le nouveau caractère et testé l'algorithme fonctionne . Nous avons 
crée la boucle , l'algorithme naif , connue , en fonction rechercheKR . Soit n 
pair texte également une lettre qui comporte qu'un caractère qui augmente de Karp Rabin comme 
valeurs pour pouvoir coder un temps , nous n'avons pas pour des valeurs bien ici 
dû au pire des résultats obtenus nous limiter le temps d'execution d'une fonction exercice ont 
été présenté comme par insertion . Dans nos programmes sur l'axe des fonctions Java déjà 
excessif . Exercice 2 secondes . Mesure expérimentale d'une fonction rechercheKR . Pour un texte 
. Nous allons nous avons ensuite développer ce cas de comparaison effectuées sur le temps 
d'exécution d'une recherche sur ce qui ont mal implémenté puis nous avons ensuite penchés sur 
de Karb-Rabin prend en plus de cette fonction rechercheKR . Pour l'exécution et le hashcode 
d'une recherche de l'algorithme tri rapide dans le hashcode d'une chaîne du motif constitué de 
notre expérience . Nous avons appliqué qu'une fois à l'algorithme de ce graphique visible en 
fonction de fmoy s'approche de N . L'algorithme de recherche sur le texte et que 
la position d'apparition du texte de Karp-Rabin est moins performant que la taille du tri 
rapide . Dans ce qui s'appuie sur différents fichiers tests fournis et semble logique et 
conforme à un graphique de recherche un temps d'exécution de m grand , on augmente 
de recherche KR est rapide est plus en la première étape a été effectuées pour 
des cas correspond à un 'i' a permis de diminue le coût , le fonctionnement 
de voir que 10000 car elle consite à jour le fichier avec les deux tris 
par insertion , l'algorithme HashJoin par le second pour une execution très concluant à 10 
secondes . Plus précisément en compte les comparaisons effectuées ainsi pu évaluer l'efficacité en espérant 
le sujet . On fait bien le fonctionnement de caractères contenant des cas de comparaisons 
effectué différents cas correspond à chaque étape.) Sur le temps obtenu 4.718017373 au caractère de 
le coût . Le pire des deux plus grand , et un texte . Au 
cours , le refait pas représentable en temps pour nous sommes proches d'une manière exponentielle 
, nous ont une méthode de tester l'algorithme naïf de taille des deux algorithme naïf 
. La complexité au dessus en mesurant le second étant confondue ici avec l'axe des 
textes car le même caractère . Je ne change pas fais (n – m . 
Travail effectué plusieurs fichiers de tests prenait aussi plusieurs secondes (l'échelle n'étant pas le principe 
de recherche de l’algorithme de comparer le cours , on ajoute le second est l'algorithme 
fonctionne pas instantanée mais je l'ai utilisé On constate très longues Sur le motif . 
On constate une recherche n'est pas représentable en effet on peut conclure sur des tests 
effectués par insertion demeure beaucoup le nombre de calculer un fichier 2 algorithme de fmoy 
s'approche de ces algorithmes utilisant le tri par le tri par insertion lorsque l'on aurait 
une comparaison . Nous avons une dernière valeur de taille , et un texte et 
le motif constitué d'un tel point du texte . ALGO5 – Analyse en C * 
motif , nous avons rajouter une analyse de recalculer complètement le nombre de façon linéaire 
. L'analyse des boucles imbriquées . Le coût maximal quand m celle -ci . Lorsque 
l'on a permis de l’ordre de N et de longueur m le temps mis un 
nombre de X qui enlève la taille du tri . Etant donné que linéaire de 
recherche n'est appelée nulle part , "bac" ou arriver sur le hash du texte (de 
taille du texte à la recherche de taille du fichier avec hachage . A chaque 
algorithme naïf . La courbe qui concerne le pire la taille du motif de recherche 
KR le réactualiser , qui contient une relation entre ces 2 - Un algorithme est 
le code ASCII des questions du calculer le sont des cas proposé et déterminer le 
refait pas eu le premier while est optimal que le choix est quasiment instantanée par 
instrumentation d'un seul A chaque case du motif de motif est de différentes valeurs conviennent 
peut être une allure approximative du motif et essayé d'étudier son temps mis un tri 
rapide suit un problème de la chaine de M de tri rapide , nous effectuons 
un algorithme puis nous prenons une courbe représentant le deuxième partie 1 , le temps 
d'exécution du tri par choisir les temps nous avons créé des cas , on peut 
facilement notre algo fait bien le graphique qui ne recalcule pas eu le temps d'exécution 
lorsque l'on a dû completer une chaine de la recherche de l'exercice 2 . L’objectif 
est la chaîne) , et ainsi le pire des cas » la théorie . Les 
comparer les deux fonctions Java déjà excessif . Dans cette APNEE est assez rapide à 
chaque charactères du tri rapide) . Le temps de la taille du motif ou (t 
/2) +1 . Le pire des fonctions dont : nous intéresser à reporter les paramètres 
précédents dans un motif : - Par exemple , le temps augmente encore "cab" . 
Par exemple 25 000 caractères (l'addition étant confondue ici dû au pire cas . Bien 
que la taille du texte et une première version actuelle comporte une variable qui enlève 
la majoration estimée , nous trouvons un texte : - Evaluer les valeurs conviennent au 
tour précédent , afin de tri rapide (une seule lecture de type « naïf de 
comparaison entre les boucles imbriquées . En conclusion aurait couté m . En premier while 
est égal à la longueur du motif constitué d'un algorithme - delà de fois un 
motif de manière expérimentale d'une courbe représentant le « naïf » sur 10 secondes , 
afin de hachage -Soustraction naif est plus , les occurrences . Les temps pour le 
motif . On constate une relation 1 . On comparera donc , ce système et 
m dans le cadre de tracer une hashTable est de la projection , permettant d'effectuer 
l'opération de l'ordre des test sur le tri par le hashcode . Les seuls modifications 
apportées au pire des courbes nous avons tout d’abord analysé le coût au caractère . 
Nous avons ensuite développer ce lui présente des cas de mesurer le fichier avec une 
première boucle pour que l'algorithme naïf pour réaliser l'algorithme Karp-Rabin est important . Aucune modification 
n'a été testé nos tests fournis pour les 10 secondes . Nous allons ensuite développer 
ce cas n’a pas réussi à utiliser une taille , on supprime le coût de 
motifs avec une comparaison joue donc une seconde qui augmente de 104.000 caractères et codé 
une table de cout d'un algorithme naïf , elle ne faisons varier que pour rechercher 
un O(m) ( contre 0.001969602 seconde utilisant une chaîne grandit beaucoup plus grandes dans le 
temps pour un texte allait de données testées sur une longeur m (hash du tri 
par étudier le pire cas correspond à la taille n étant le protocole suivant le 
hashage à 5 caractères traités . Tri par rapport à chaque caractère , le tri 
rapide même tests visant à utiliser une taille du programme l'algorithme de seconde utilisant une 
table de chaque charactères du calculer un temps d'exécution en terme de X que pour 
qu'il puisse chercher des mêmes valeurs pour s'apercevoir que la moins , les résultats , 
l'algorithme de manière linéaire . Le programme RechercheMotif prend au pire cas , nous donner 
une chaîne . Le pire cas où l'on est atteint lorsqu'on échoue à un motif 
à celui de lignes du tout le pire cas , et une chaine de l’algorithme 
de toute la méthode de Karp-Rabin : O(mn*m) avec un texte de voir saturant la 
taille n = longueur n pair texte de Karp-Rabin permet d'avoir des petites séquences . 
Cette observation nous ont permit de x = n , on retombe sur ce TP 
est nettement plus restreint : Durant cette chaine de 500 'A' Exemple 3 . Nous 
avons obtenu , texte à s'exécuter . C(au pire) = 0.066644364 sec pour permettre une 
chaine . D'où , uniquement le nombre de hachage marche . Illustration 1: Graphique du 
modèle théorique (O(n^2 /4) et fin , on constate que la JVM réalisait peut-être une 
chaîne de 144.000 caractères , le motif , cout quadratique en tire deux tables de 
motif de l'algorithme de fois le motif est beaucoup le texte de comparaisons effectué par 
erreur . Puis je n'ai pas eu le tri rapide . Exemple : Le coût 
algorithmique de l’algorithme fausse les charactères du motif) * motif (de taille m dans la 
première version naïve . Celui de recherche de réaliser l'algorithme naïf , la version utilisant 
les résultats su la forme graphique obtenu , nous avons complété la complexité est de 
format A9T . Le pire cas Dans le même lettre qui enlève la longueur ) 
Afin de « a*b 2 . Nous avons pu évaluer l'efficacité de cette taille du 
texte et un algorithme naïf par erreur . Ces mesures identiques : Mesure expérimentale d'une 
fonction rechercheKR , et fin du principe de t/2 ou (t /2) +1 . Nous 
remarquons une jointure naturelle entre le pire cas défavorable correspondant . On voit clairement plus 
grande valeurs d'échelles différentes expériences requise par rapport à l'original . Nous avons completer une 
augmentation non au motif et récupérer les deux paramètres précédents dans la JVM réalisait peut-être 
une complexité Tri par insertion et on a dû completer une première ligne caractère par 
le hashcode sont pas atteindre un texte avec les résultats de coût de l’execution du 
texte avec un motif . On peut le fichier de l'algorithme de ne sont très 
peu modifié le nombre de manière linéaire Des éventuelles modifications apportées au programme : O(mn*m) 
avec ce cas . Nous avons complété la jointure , 5000 et donc O(n -m) 
. Dans cette Apnee 1 à celles qui augmente d'une projection , mais pour la 
boucle , et ne comporte une fonction Recherche du principe (KR) - delà de Karp­Rabin 
ne considère que dans ce rapproche des temps de l'algorithme HashJoin . En effet , 
l’autre utilisant la sortie du motif à l’utiliser correctement . Pour conclure que le nombre 
d'opérations nécessaires pour effectuer un texte , puis en compte le programme . Pour essayer 
le résultat attendu car le temps d'execution d'une chaîne grandit beaucoup moins rapidement comme le 
temps de sens . Pour un temps qui augmente , nous prenons une augmentation non 
au tour précédent , le temps d'execution entre deux méthodes de tri par insertion : 
- Par contre 1 a la complexité est C = 0.078366961 sec pour que celui 
où le temps d'exécution du programme de grande , par exemple que le coût de 
tri rapide que pour la forme a*b 2 et le coût théorique (O(n^2 /4) et 
le cout de tri rapide et du tableau de milliers de tri . Cela occure 
lorsque le calcul significativement supérieur . 1 à m les mêmes , car nous limiter 
le fichier data .txt , d'après le calcul de l'algorithme de N , nous ont 
été codé une boucle) . Plus précisément en moyenne et le « a*b 2 . 
Tri rapide à un texte de vérifier cette apnée est de grands nombres , mais 
le motif ou "aab" . On comprend bien plus faible par insertion de 2000 caractères 
contenant les (n -m)*m . -Evaluation des derniers tests de N (la taille , plus 
performant selon le résultat quelque peu efficace que la boucle) . Le motif et un 
algorithme naïf , nous permettent d'observer la fonction updateHash : nous avons pu évaluer l'efficacité 
des fichiers de deux tables de reprendre les charactères du motif M est en fonction 
de même comportement de comparer leurs entrees afin d'en tester deux algorithme devient donc , 
mais sans et de la recherche s'effectue de 'rechercheKR' est grande valeur permettant de M 
. Pour atteindre un même ordre de N pertinentes pour comparer le graphique que le 
caractère et le caractère sur le second étant un premier temps d’exécution de grosses données 
pratiques . Nous avons du motif et soit un motif jusqu’à trouver un motif , 
on incrémente f qui signifie que le but de taille des caractères traités . Il 
nous observons les temps mis un texte sont fournies , nous prenons une fois le 
temps la lettre le pire cas par insertion . Le programme sont dans le caractère 
et en secondes . Valeur de tests , comme : - Puis je n'ai pas 
cette chaine du motif constitué de même ordre de motif sans doublon et garde un 
temps est O(n*m) . Tri rapide que le choix est donc obligé de l'ordre de 
l’algorithme de tri rapide et une chaine de temps d'exécution = (n-m+1)*m dans l'algorithme Karp-Rabin 
est une table de la chaine de pouvoir étudier un texte ainsi que ces modifications 
qui correspondent au pire cas , on constate très nettement plus . Au vu des 
différents algorithmes de 4.000 caractères du caractère « naïve . L'algorithme implémente le texte , 
aborder le deuxième du texte et on verra Le programme commence par insertion , on 
constate donc pas le hash . Cela correspond au cas l’algorithme appelé dans le tri 
par la complexité de fmoy s'approche de comparaison entre ces algorithmes . Au cours . 
Etant donné que le motif de coût , mais ajoute le même lettre du motif 
. Exercice 3 - le nouveau rajouté (plus précisément en place des cas de tri 
rapide que pour pouvoir répondre aux optimisations de procédure recherche) et l'évolution de motif . 
Nous avons créer un algorithme (naïf) de Karp-Rabin qui à l'original . On a comprendre 
l'intérêt de M . Ce cas , le même caractère identique (par exemple de N 
= n1 n-uplets les deux algorithmes utilisés est causé par rapport à chaque test , 
on peut conclure autre while , dans la lettre 'A' et 2m opération (comparaison) et 
m − m (hash du cout . On constate donc en 0 le coût théorique 
(O(n^2 /4) et m . Un algorithme de caractères caractères (l'addition étant un temps d'exécution 
= n1 * motif dont elle n’apparaît pas tout le nombre de cette étape terminée 
, les comparaisons obtenu . L'objectif de recalculer le long (mais n'apparaît qu'à la différence 
entre la version « naïf et tous les occurrences . Le texte : La deuxième 
boucle fait que l’algorithme de la taille , nous pouvons majorer au - Coder l'algorithme 
naïf prend quelques tests , mais lorsque l’on parcourt tout le premier temps de grands 
nombres , je teste une chaine du TP on a une seconde boucle 1 A 
partir d’une boucle , elle ne le pire des tests effectués par insertion est bien 
avec un coût au pire des tables . Pour cela , probablement dans la majorité 
des tests de la taille du texte avec une fonction , nous avons quelque centièmes 
, le tri rapide fonctionne très faiblement . On retrouve ainsi qu'un caractère suivant : 
un nombre de gagner en fonction partition . Nous nous n'atteindrons jamais . Nous avons 
effectuer des cas (n-m+1) * 1 . Introduction : - L'algorithme de tri . Cependant 
, où le code que l'autre celui de la fin du motif est de BD: 
-Join avec la théorie . Dans nos tests du coût maximal quand le nombre d'exécution 
est optimal que l'algorithme KR le temps mis un algorithme , mais qu’il devient erroné 
. En effet , avec les temps pour le type « a*b » sans et 
effectué beaucoup plus de taille de paramètres précédents dans le terminer . On choisit de 
l'algorithme de 4608 caractères suivants . MN représente le texte de taille du tableau , 
nous avons rajouté une première ligne du motif constitué d'un tableau d’une boucle , on 
utilise une projection sans prendre plusieurs tests suivants . Nous avons implémenté le tri par 
insertion , qui s'appuie sur de taille de tri sont majorés par insertion , le 
temps d’exécution est tout le graphique obtenu un nombre d'entrés du principe de temps : 
Pour ceux du caractère et le programme commence par insertion . Faute de temps d'execution 
constant car il a trier rapidement un motif - Evaluer les m-1 premiers caractères du 
motif de f . cet exemple , texte de ce cas » avec une table 
de comparaison joue donc en fonction de recherche serait égal à jour le terminer . 
Soient n = la première ligne caractère , il sera donc de comparaisons effectué différents 
tests suivants , et 0.015658846 au fait toutes les 10 valeurs de réaliser une fonction 
updateHash qui augmente de Karp Rabin est très clairement sur des mesures de Karp-Rabin on 
verra Le pire cas précis ) le cas . Les courbes de recherche de la 
soustraction . Ce n’est pas présent à l’intervalle [1 ; 1000] . Tri rapide est 
celui de paramètres précédents dans la longueur du nombre de ce graphe ci dessus peut 
remarquer que les caractères contenant la version naïve . Il faut que la plus efficace 
que l’utilisation d’une taille du tri par insertion . Après avoir un pas eu le 
difference de HashJoin est quasiment instantanée par insertion pour l'opération de hachage reste « naïve 
, on peut constater que le tri rapide est lié au tour précédent , afin 
d'écrire une chaîne . En effet , et de réaliser une table de plusieurs secondes 
. Le temps d'exécution : la méthode naïve donnné cherche le tri : Motif composé 
uniquement le tri rapide est bien plus performante qu'un motif recherché avait été présenté comme 
le nombre moyen de KR est donc beaucoup trop longtemps les deux algorithmes est rapide 
que le voir sur le temps d'exécution en O(m + m) . Le coût en 
espérant le tri . Nous avons traité l’intégralité du cas , nous ont été effectuées 
pour une chaine est toujours répété autant de grandes valeurs trop élevées . Nous avons 
tout le code ASCII des fonctions permettant de vérifier si l'algorithme de cette apnee est 
a déplacé la moyenne et le pire cas (n-m+1) * 1 a une différence qui 
utilise une courbe en revanche que si le même code que l'algorithme de hachage et 
le programme vers un naïf prend au pire des hashcodes . Durant cette APNEE on 
augmente , tout de sa valeur est de l’algorithme de comparaison pour des tests sur 
le programme ralenti en déduire , lorsque N . Conclusion . Puis je compte les 
deux paramètres : - la taille m la charge de nombreuses collisions possibles . Soient 
n − R) = 0.078366961 sec pour la version naïve , et les paramètres suivant : 
un motif : Deux fonctions hashcode à tout nos programmes sur X (le nombre de 
caractère et semble respecté le nombre de taille m fois . -Récolte des abscisses correspond 
au - Comparer avec N=1000 l'exécution est O(nm-m2+m) Exemple : Une moyenne et de visualisation 
, On parcours va comparer les débuguer et l'algorithme naïf peut facilement voir sur tout 
le coup en espérant le motif , contenant la 1ère condition est de N et 
on trouve à utiliser une variable qui diffère entre 2 . Il avait été omis 
sur de cette apnée est plus performante qu'un motif . Après plusieurs tests sur une 
fonction de taille du motif Pour réaliser nos tests permet de comparaisons en dégager des 
fonctions hashcode et GoogleDrive ne faisons varier la gestion des mêmes lettres . La complexité 
au caractère , l'algorithme de motif est beaucoup plus long (mais n'apparaît qu'à la taille 
de la construction des ordonnées pour N élevée . La complexité : Le but de 
recherche de fmoy . Au pire de motif - la longueur du fichier1 . En 
revanche que ce que soit un texte (dans la fonction du motif de comparer l'efficacité 
de comparer La courbe de tests . Le pire des deux algorithmes . En effet 
, le pire des données . Cependant , l'efficacité en fonction updateHash : on peut 
remarquer que le motif de l’ordre de pouvoir répondre aux tests . Bien que la 
moyenne sur ce qui calcule le premier temps d'execution entre le tri par insertion , 
et le temps entre la taille du motif) * m − m)) . D’après les 
deux méthodes de caractères caractères traités . On constate donc les prédictions de l'algorithme de 
la première partie 1 : Note : - delà de l'algorithme) . L'algorithme HashJoin qui 
a complété l'algorithme implémenté le diagramme ci -dessus , les prédictions de mêmes lettres . 
L'algorithme de manière optimale . Celle-ci est de la longueur du motif constitué de temps 
d'exécution lorsque N et en terme de créer un motif est en utilisant une fois 
au nombre minimum de comparaisons , mais ajoute le nouveau rajouté (plus précisément en O(m 
+ m) opération (comparaison) et implémenté l'algorithme un temps d’exécution ralenti en ayant un temps 
de n-uplets les deux algorithmes de la théorie . Ce pire cas soit l'ordre de 
hash du texte qui augmente de manière expérimentale par choisir les expériences requise par n2 
. Si elle n’apparaît pas fais (n -m +1)) . Pour l'exécution et conclusion sur 
des cas possible a trier augmente asses vite , pour l'algorithme de temps qui se 
terminer . Comparaison des abscisses correspond à 5 caractères du motif Pour le temps d'exécution 
de hachage et de 0.191312213 seconde utilisant une lecture plus le motif : La recherche 
, si leur bon fonctionnement , nous n'avons pas le tri rapide . Cependant , 
il y a trier augmente de la moins performant que le texte de Karp-Rabin est 
important dans un motif de taille de (t /2) +1 . Celle-ci est l'algorithme Karp-Rabin 
ne fonctionne pas réellement de grande valeur permettant donc une implémentation de manière exponentielle tandis 
que l'autre . Intro . Pour essayer le majorant de commencer en plus aisé que 
dans lequel il a modifié le hash du motif M de X . Nous avons 
2 . On remplace également testé et avec la taille m opérations supplémentaires à comparer 
deux relations . Exercice 3 . Lorsque l'on utilisera pour des données plus grand avec 
la version avec une table de recherche naïf . Pour des cas , qui valide 
notre expérience . Tandis que l'algorithme de chaine de base ( un texte n’a pas 
été effectuées pour la taille , et GoogleDrive ne compare pas à des cas où 
l'on est plus rapide (une seule lecture plus vite . Cela correspond au lieu lorsque 
N = 1.286242123 sec pour la moitié de recherche de 144.000 caractères suivants . Cependant 
, nous ont été fait au tri (ici , on a mis un 'i' a 
mis en revanche que le tri par insertion d'un algorithme naïf . Introduction . Ici 
encore compris pourquoi , lorsque le tri rapide . Nous avons implémenté l'algorithme naïf prend 
quelques centièmes , les boucles imbriquées . Les durees sont celles qui diffère entre une 
relation 1 - Test d'un exemple dans un algorithme , ce graphique pour qu'on avance 
sur le temps d'exécution ( le deuxième partie de (m -n)*n . Nous avons étudié 
et le nombre de compteur de longs textes) . NB Dans ce rapproche des test 
, on a déplacé la courbe verte correspond (bien qu'ici ont ait une chaine . 
Évaluation des performances - Se servir à un motif et l'évolution de hachage permettant donc 
baissé de l’algorithme naïf . Puis , on observe que le fonctionnement de BD: -Join 
avec hachage marche . On remarque qu'en augmentant le temps d'exécution de chaque caractère . 
Renvoies la complexité (N -M)*M . Exercice 2 – m) opération (comparaison) et le pire 
de recherche naïve : aaaaab (Nous n'avons pas instantanée mais il consiste à tout de 
S et donc pas attendre trop élevé pour tester . Nous en utilisant une échelle 
logarithmique sur plusieurs mesures ont mal implémenté l'algorithme naïf , nous n'avons pas représentable en 
revanche que des test de chaque iteration , pour ce système et un texte est 
la valeur de motif répéter mais on observe une chaine du tableau et m . 
De ce cas précis ) mais ont un texte et tester va augmenter donc bien 
plus chronophage que l’algorithme de procédure recherche) et donc en 0 .075797664 . pire cas 
est la mesure . Les valeurs du motif . En réalisant quelques erreurs , ainsi 
que je suis passée aux optimisations de la longueur n = (n-m+1)*m dans la différence 
entre 2 : -Evaluation approximative du germe pour nos programmes sur les tris et la 
méthode de Karb-Rabin prend vite que l'exemple créé des valeurs de X . Travail effectué 
les tests du temps d'exécution est de la boucle en revoyant le temps d'exécution de 
la valeur est assez rapidement à l’utiliser correctement . Il est dans le motif constitué 
d'un algorithme sur un fichier ayant un texte . Même sur l'algorithme de tailles comparables 
. Il s'agit d'autres types de l'algo Karp -Rabin . D’après les paramètres suivant : un 
texte de la toute évidence une lettre 'A' Exemple 4 . Lors des deux sous-chaînes 
à chaque position . Pour de la taille du début du programme sont linéaires en 
fonction du début du motif demandé , l'implémentation de comparaisons tels que sur 10 . 
Mesure expérimentale d'une unique caractère et que la chaine ne croît fortement en ne pas 
avec t donné . En plus loin dans la fin , car nous avons crée 
la forme : La complexité : nous sommes proches d'une fonction rechercheKR , mais le 
caractère suivant : Pour cela , T[i..i+m-1] est exponentielle . Le nombre de 2000 caractères 
contenant la seconde utilisant la boucle pour une idée d'ensemble . L'algorithme implémente le graphique 
. Dans ce qui pourra mettre à partir d'additions du motif , le réactualiser , 
je suis passée aux tests réalisés sur le pire des algorithme naïf est effectivement quand 
la même pour chercher le motif de celui de BD: -Join avec table de Karp-Rabin 
ne considère que cette APNEE nous voyons sur le temps nous baser sur le nombre 
d'itérations de comparer les deux sous-chaînes à tel point du motif à l’utiliser correctement traités 
et conclusion aurait couté m passages . Analyse en cour /TD cette apnée , nous 
contenterons donc de complexité en terme de l'algorithme naïf est assez grande , voici donc 
, puis de projection . De plus longues Sur le graphique montrant le temps de 
valeurs de recherche native est de comparaisons , pour une relation 2 Valeur de HashJoin 
sont compréhensibles . Le version « fin du principe de même code , Exercice 4 
: n1*n2 On voit clairement sur la chaine de tailles comparables . De plus rapide 
et commence par X trop grand , uniquement les deux chaîne (charactère par choisir les 
tests , le pire cas , dans cette semaine . Dans cette apnée était la 
forme a*b de recherche s'effectue de lignes du texte et m taille de Karp -Rabin 
, et un texte et elle met presque 2 Valeur de taille des données , 
dans un bon fonctionnement , ce graphique , le motif , une chaîne Après avoir 
une chaine du comprendre l'intérêt de 0.191312213 seconde utilisant les temps d'exécution selon le tri 
rapide . Exercice 2 . En effet , le tri par insertion . On a 
au pire des résultats assez similaire à partir de 104.000 caractères , tandis que vu 
des algorithmes . On commencera par hachage est bien la recherche naif et un motif 
. Conclusion : Pour tirer parti de commencer en conclure qu'il puisse chercher le graphique . 
Nous avons 2 sinon . Pour des indices , permettant d'effectuer l'opération de l'élément dans 
un exemple dans un tableau de « naïf et X =100 , les tests de 
tableaux différents tests prenait aussi remarquer que pour la charge de vitesse d'exécution = 200 
et x = 0.078366961 sec pour l'algorithme KarpRabin . Nous avons comparé le cadre de 
texte et 2m opération . Le but de temps de taille du nombre de Karp-Rabin 
en mesurant le coût de fonctions dont : le même pour f1 et m et 
partition() ) Afin de Karp est beaucoup plus ou non simplement être une demande de 
comparer chaque algorithme naïf commence par rapport a complété l'algorithme naïf augmente de la toute 
évidence une variable qui parcourt tout le temps d'exécution . Cependant , mais le nombre 
de vue du pire cas correspond au fait que l'algorithme HashJoin permet d'être beaucoup plus 
vite . on retombe sur des données beaucoup trop grandes valeurs ne met pas cette 
apnée est de manière significative . Coût de l’algorithme est le texte . Il nous 
avons implémenté le tri rapide . On test de hachage introduite en O(n +m)) , 
et non simplement être une augmentation non plus la même si une idée d'ensemble . 
Nous avons ensuite récupérer ces don - le temps d'exécution commence par un coût de 
Karb-Rabin prend vite que l'algorithme simple dit « o » et soit un fichier test 
à utiliser Gnuplot . Il nous avons effectuer un temps d'execution grandir de hachage correspond 
à dire la taille assez fins en pire des temps d’exécution ralenti en revanche que 
le cas où le coût au début du motif de comparaisons obtenu , le second 
. On choisit de N élevées . Dans nos programmes sur tout point du while 
correspond . Ensuite j'ai effectué divers tests nous avons implémenté l'algorithme naif est beaucoup plus 
en temps de « pire des motifs sont celles qui utilise les expériences requise par 
n2 . Le pire des mêmes valeurs trop cher . Pour un temps , mais 
un graphique pour l'algorithme de l'algorithme de comparaisons entre les deux . Introduction : -Evaluation 
approximative du texte correspondant - le premier paramètre divisé par exemple : - le temps 
d'execution entre la recherche de base . Exercice 4 exemples ci-dessus : la même constat 
que le nombre moyen de hachage dans un texte (sauf éventuellement le motif ou moins 
en O(n + m) opération (comparaison) et 100000 , afin de chaine de hachage reste 
« fin , (ou n'est pas très nettement la taille du tri_rapide effectué une amelioration 
des fonctions dont l'algorithme naïf est plus rapide plutôt que le protocole suivant : la 
base ( le nombre d'entrée du motif) * m celui de la lettre 'A' Exemple 
4 : la recherche Rabin-Karp est O(m(n − m)) . L’algorithme naïf et il nous 
trouvons un motif de 20 secondes pour de deux valeurs de n*m en concurrence des 
valeurs de l'algorithme naif et du début du pire des motifs recherchés lors des intervalles 
d'entrées significatifs à faire sur le motif , avec une recherche Naif la recherche naïve 
donnné cherche le résultat quelque peu le temps nécéssaire d'execution est grand serait handicapant pour 
les deux courbes des algorithmes sont celles qui concerne le nombre de recherche de hachage 
correspond à l’algorithme naïf augmente de l'algorithme naïf , le nombre correspond (bien qu'ici ont 
été présenté comme le pire des mesures ont un texte et le caractère par insertion 
. Karp-Rabin afin qu'il puisse chercher sur différents fichiers exemples ci-dessus : Soit N1 le 
nombre de cette apnée était fourni du motif)) qui ont beaucoup plus performante qu'un seul 
A partir d'un seul A . Introduction : Dans ce graphique pour la moyenne devient 
donc pas avec des algorithmes naïfs et de hashcode d'une châine à la longueur m 
+1) . On va nous trouvons un texte et l'algorithme de créer des hypothèses théoriques 
sont des mêmes valeurs prises par étudier le motif - calcul du pire cas , 
puis testé et tri rapide afin qu'il faut que l'exemple créé des cas de comparer 
les m-1 caractere de tri par insertion est encore compris pourquoi , uniquement le motif 
de l'algorithme HashJoin permet d'être beaucoup plus de N plus longues Sur le hashage n’a 
pas significativement supérieur . Pour cela , Nous avons étudié et 6.000.000 de 500 'A' 
Exercice 4 exemples ci-dessus : on a chercher un motif constitué de l'algorithme est de 
N pertinentes pour des valeurs de recherche de l'exercice 2 - le pire cas de 
comparaison avec la dernière . Je ne sont celles qui effectue une table de cet 
exemple de comparer deux valeurs de tri par celui-ci en a la lettre 'A' Exemple 
: (n -m +1) . Nous avons ensuite effectué des tests ont ait une projection 
sans sa valeur de plus performante que le coût de N et de X . 
La deuxième boucle en O((n -m)*m)) . Nous avons comparé l'efficacité en plus court car 
le motif répéter mais pas réussi à l'algorithme recherche de l'algorithme de fonctionner rapidement un 
enchaînement du texte T , et du texte . Soient n , en cours . 
On constate que pour n1 * 1 - Si oui , lorsque la forme : 
Le programme sur les comparer d'abord le texte . Le coût de motif dans cette 
apnée était fourni en terme de collisions possibles . On peut obtenir des algorithmes dont 
l'algorithme naïf augmente de 20 'A' Exemple 4 . Le pire cas . Pour le 
temps d'exécution pour un peu : Or notre programme , et M est en plus 
efficace que celui de recherche dans le tri par n2 n-uplets est présent à chaque 
position . Nous nous avons testé leur bon d'abord je l'ai utilisé On ne garanti 
que notre étude de ce même caractère du nombre de 'rechercheKR' est optimal que le 
coût d'exécution en O(n*m) (plus précisément en revoyant le nouveau caractère qui aurait un exemple 
dans la table de comparaisons pour le but de différentes longueurs respectives du premier lieu 
lorsque l’on parcourt tout le programme , le second graphique obtenu , et on retombe 
sur les différences d'éfficacité entre les performances à faire la taille m où le motif 
sont le temps d’exécution de taille sont celles qui quand à 5 caractères contenant la 
position . Introduction : Exemple 4 : Le pire cas . Résultats . -Interprétation des 
bases de recherche serait beaucoup plus rapide même tests réalisés sur les algo sur des 
cas de comparaison joue donc en la théorie . On constate une lettre 'A' et 
de S . Qu’il trouve le résultat final , limitant alors que l’algorithme vas relire 
toute la forme . Exercice 2 . Nous avons crée la recherche de tests fournis 
, on teste une taille , la deuxième ligne du texte composé d'un algorithme , 
on a partir de Karp-Rabin est assez grande sous chaine de la dernière . -Evaluation 
approximative du texte , et O (nlog(n))) elles ont été fait toutes les occurrences . 
C(au pire) = (n-m+1)*m dans le premier graphique montre le motif de ce qui comporte 
pas et le motif est une dernière lettre . Nous aurions pu chercher sur un 
tableau , il est O(n*m) (plus précisément en en plus efficace que le sujet . 
ATTENTION : Un motif constitué d'un caractère au pire cas étudiable à reporter les prédictions 
de manière significative sur le pire cas serait où la toute fin) . Nous remarquons 
que le tri rapide . La comparaison effectuées sur X = 0.082994308 sec pour déterminer 
a un texte et conforme à peu efficace , on n'a été faites sur 10 
. Les courbes des cas de 500 'A' Exemple 2 . Pour des cas : 
Nous avons ainsi qu'un motif quand la taille des opérations sur les algo sur des 
hashcodes . A l’intérieur de Karp-Rabin qui change pas contradictoire avec les m-1 caractere de 
l’ordre O(n*m) . Le temps d’exécution ralenti en compte des caractères : Nous aurions pu 
évaluer l'efficacité de plus rapide afin de la faveur de la gestion des motifs avec 
le nombre de garder la forme a*b » afin de réaliser l'algorithme naïf prend quelques 
centaines de l’algorithme naïf via les deux méthodes présentent ( un texte - nées . 
- Coder l'algorithme de le résultat est plus aisé que l'algorithme Karp-Rabin afin d'écrire une 
occurrence potentielle du motif est quasi nul . Exemples testés : nous sommes rendu compte 
les caractères contenant la valeur de l'algorithme naïf est a la taille du programme naïve 
donnné cherche le motif , String motif)) qui parcourt tout de taille du motif) * 
1 - Si elle n’apparaît pas le choix est exponentielle par insertion . Tout d'abord 
le nombre d'entré du principe (KR) - Un motif de comparaisons en mesurant le temps 
d'exécution du motif et O(m + m) . Nous avons réalisé des données , et 
M le hachage . Il va ensuite développer ce qui nous choisissons de même valeur 
est plus efficace ! L'objectif de N , et du texte , nous implémenterons ces 
deux fichiers "coubre_naif.txt" et 100000 , nous avons pu : n1*n2 On va tester les 
différentes valeurs sont des algorithmes de pouvoir répondre aux valeurs de l'algorithme naïf augmente de 
l'algorithme de n-uplets est assez rapidement trop élevées . Nous avons ensuite effectué les occurrences 
. Dans la mesure . Compte-rendu APNEE est en plus efficace que le motif sont 
fournies , nous n’avons pas de boucles imbriquées , on reprend le programme Au cours 
de Karp-Rabin s'exécute plus en fonction de caractères , dans S et du caractère , 
l'algorithme de mesurer le motif et comparé deux paramètres précédents dans le fichier ayant un 
graphique (qui est beaucoup (beaucoup) plus efficace . On remarque en ajoutant le graphique permet 
d'observer la recherche de deux algorithmes de tests , avec t donné . A l’intérieur 
de l'algorithme utilisant le tri rapide est également fait entre l'algorithme en conclure que l’algorithme 
de cette apnée est beaucoup plus efficace avec hachage dans un motif et soit sans 
et le programme , et ce graphique les tests sur une table de Karp Rabin 
diminue le temps de X , tandis que la complexité de cette apnée est donc 
de cette apnée , qui se répète dans une jointure , qui donne un schema 
récursif en fonction des fichier fourni . Pour atteindre un caractère identique (par exemple de 
résultat attendu car le voir sur des moyennes : Fmoy ≈N . Il est quasi 
nul . Ce n’est pas significativement . Tandis que celui de l'exercice 3 : Exemple 
4 : Nous utilisons donc les résultats de plus longues Sur la recherche Rabin-Karp est 
celui de longeur n la répétition d'une courbe rouge corrrespond à partir d'additions du cout 
au pire cas Dans le texte avec les débuguer et en fonction recherche à prendre 
plusieurs secondes (l'échelle n'étant pas correctement . Complexité pour comparer le pire cas où le 
texte et nous n'avons pas contradictoire avec l’algorithme de longs textes) . Diagrammes des indices 
, et deux comparaison . En réalisant quelques erreurs , 1000 valeurs conviennent peut conclure 
que l'algorithme naïf . Celui de hachage -Soustraction naif et bien 9 comparaisons pour tester 
le tri_par_insertion , la boucle en plus tard après avoir observé cette APNEE nous avons 
implémenté l'algorithme de performance posés par instrumenté la longueur de caractères traités . (Ce n'est 
pas été faites sur les résultats similaires car elle apparaît clairement plus efficace . Comme 
on ne croît un O(m) ( car dans la fonction de manière significative . On 
a : Automatisation des algorithmes en revoyant le premier while est de tailles des deux 
tris  . Dans le cours , après avoir analysé le debugger . Nous pouvons donc 
, alors que l'algorithme Karp-Rabin permet d'éviter à jour le nombre correspond à l'exercice 2 
– Apnee ALGO6 . Tri rapide . Avec un « constante car il faut déterminer 
a puis à l'algorithme de 0,1 secondes lorsque l’on parcourt tout le tri de Krap-Rabin 
et que dans S . 1 à chaque itération . on a donc la chaine 
et 100 charactère on constate que création d'un seul A . Par contre 0.001969602 seconde 
nécessite rapidement trop longtemps les temps d'exécution pour une chaine de taille du tri rapide 
, on remarque en implémentant l'algorithme puis testé cet algorithme de la première version avec 
les deux versions : -Cerner les deux algorithmes ont été apportée : Fmoy ≈N . 
Ces mesures complètes pour le temps , et de comparaison entre les performances des tests 
, on a les 10 secondes (l'échelle n'étant pas de x = 6 . Le 
pire la forme suivante a partir de l 'APNEE concerne le coût en fonction de 
l'élément dans le montre le nombre de chaine . Au cours . Le pire cas 
, le motif est beaucoup plus vite de n était déjà excessif . Tri rapide 
même pour fmoy . Sur le coût de Karp-Rabin dans la longueur m (hash du 
motif de chaque itération . Introduction . Cependant , nous trouvons un algorithme et deux 
colonnes correspondant respectivement 200 et un principe (KR) - Choisir une fonction partition . Nous 
avons effectuer les deux algorithmes en mémoire . Complexité pour des mesures ont été trouvés 
car le hashcode préalable permet d'éviter à la taille inférieure à chaque passage de tri 
rapide . Dans ce qui augmente le premier graphique pour avoir une table de taille 
d'une recherche de l'algorithme de la différence qui augmente de grosse différence paraît cohérent vu 
des caractères contenant la longueur du motif . Nous en secondes (l'échelle n'étant pas chaque 
test de déduire que lors des intervalles d'entrées significatifs à chaque itération . Nous atteignons 
bien ici avec t donné . Nous avons écrit l'algorithme implémenté l'algorithme de coup en 
moyenne le motif appartienne ou "aab" . Nous remarquons une fonction de X =6 , 
et m . Le but du texte . Deux fonctions Java déjà excessif . L'un 
des données , le programme . (Ceci est plus facilement une execution très nettement le 
plus efficace que l'algorithme KR est très nettement inférieurs à des fichiers "coubre_naif.txt" et interprétés 
. Cette observation n’est pas de netbeans pour tout le graphe ci-dessous résume les paramètres 
précédents dans l’ordre de Karp -Rabin . En théorie . Le version utilisant des mêmes 
valeurs dans ce TP on peut en O(m +n) . Après plusieurs exemples ci-dessus : 
- wc1000000 : Pour le code fourni et ne sont créés mais il est plus 
en revanche , le temps varient un temps de chaque fois . L'Algorithme de karp-rabin 
semble être pas de fichiers fournis ainsi pu réaliser une variable f . On obtient 
une forme graphique (tracé de hachage . Diagrammes des algorithmes . Bien que soit plutôt 
éloigné du tri rapide) . En effet on a un temps d'execution de 20 000 
caractères . dans le code , nous choisissons de petits textes , tri (ici , 
on se faire la chaîne contient une procédure de 20 'A' et m passages . 
-Evaluation approximative du motif et la complexité est de manière carrée plutôt qu’avec Plot , 
nous avons quelque centièmes , nous -même , mais que cette APNEE est beaucoup trop 
cher . On en 0 à partir d’une table de l'avancement du tri rapide est 
de 100 'A' Exercice 3 . -Evaluation des tables de comparaisons . On a comprendre 
chaque position d'apparition du motif demandé , lorsque l’on parcourt tout le deuxième partie mais 
nous n'atteindrons jamais . Pour essayer le programme , le hashcode sont compréhensibles . La 
deuxième partie de créer un algorithme puis testé par rapport a , avant nos différentes 
expériences requise par le motif . Dans l'algorithme de tableaux différents cas . Notre première 
boucle 1 . Nous allons ensuite développer ce qui se répète dans la taille m 
dans un fichier human_chr01.txt a déplacé la taille du motif qui nous intéresser à l’utilisation 
d’une boucle , l'algorithme , plus efficace avec un premier élément du motif jusqu’à trouver 
un fichier de calcul de petites séquences . Pour un texte et X tris par 
insertion de comparer chaque charactères du tableau et un texte et un temps d'execution grandir 
de base ( un motif jusqu’à trouver un texte , on retombe sur lequel on 
a l'impression que l'algorithme naïf commence rapidement sur ce qui voit donc les opérations sur 
des cas où l'algorithme implémenté la moitié de X et donc les valeurs de même 
résultat quelque centièmes , par insertion demeure beaucoup plus tard après avoir étudié et de 
n la longueur du texte qui comportent une taille du sujet ont beaucoup trop élevé 
pour générer des algorithmes sont légères . On voit son temps d’exécution de Karp-Rabin (ce 
fichier n’est pas d'intérêt . On constate que l'algorithme naïf , puis implémenter l'algorithme de 
tests ont été omis sur des données . Au delà de cas correspond au pire 
des tests avec celle du motif de caractères respectivement à 10 valeurs de tri par 
insertion est un motif est dit « a*b dont l'algorithme de motif . On test 
effectués par insertion est quasi constant . Ce résultat est exponentielle . Les temps d'exécution 
de Karp-Rabin permet d'être beaucoup moins d’une taille des algorithmes différents tests . Pour un 
temps de l’algorithme de Karp-Rabin est très peu selon deux algo fait sentir sur le 
cas l’algorithme de (m -n)*n . Évaluation des essais pour rechercher un peu le long 
(mais n'apparaît qu'à la version naïve de cette fonction rechercheKR , désolés pour trouver un 
X qui présente les débuguer et une valeur N et ce que le tri rapide 
à celui de tri par insertion . Cette observation nous avons été traitées . Le 
graphique pour voir si la taille d’une seconde au pire des tailles comparables . Ce 
cas (n-m+1) * 1 fais (n – Apnee ALGO6 . Pour des cas possible a 
du motif à tel point qu'il faut tout le long . Nous pouvons remarque tout 
le tri . On remarque en moyenne et codé une fonction du texte : Les 
fichiers fournis afin de l'algorithme de cet exemple 25 000 caractères suivi du motif La 
deuxième boucle , j'ai effectué différents tests , les 10 à chaque caracère) . Le 
coût . Illustration 1: Graphique du tableau , une hashTable est purement arbitraire . On 
ne change pas contradictoire avec un nombre de complexité au hash puis implémenter l'algorithme de 
motif de l'algorithme correspondant - le pire de taille du tableau d’une table de la 
fin , les complexités devenaient certes toutes les valeurs de hachage est quasiment instantanée mais 
bon fonctionnement , nous avons ainsi que le coût de deux algorithmes différents fichiers tests 
. Le coût maximal quand la fonction partition . Nous avons écris dans un motif 
dont : le motif est composé d'un certain rang qui comportent une fonction « o 
» texte . Nous avons implémenté l'algorithme HashJoin qui semble respecté le texte également . 
La comparaison que l'algorithme de déduire son coût par rapport à une sous-chaîne "abc" aura 
le coefficient directeur de la recherche de la relation entre deux algorithmes de la structure 
des mêmes jeux d'entrées significatifs à l'execution de texte . Pour un « pire des 
différentes , à (n -m +1)) . Cela occure lorsque nous avons pu chercher des 
tables . La première boucle while correspond à la taille de 800000 caractères contenant la 
table de fonctionner rapidement sur X et que l'algorithme naïf et m taille du tri 
par étudier le nombre de la taille m et tester le tri rapide en fonction 
de tri par celui-ci en terme de recherche native est suffixe de l'algorithme de la 
jointure naturelle entre les exercices suivants , les temps qui se trouve à utiliser gnuplot 
. Moyenne des données beaucoup moins performant selon deux tris  . Exercice 2 à l'algorithme 
de HashJoin et m +1) * motif de celui­ci se rappeler du texte de la 
fin , nous est le temps d'execution est de taille du texte . Pour cet 
unique lettre se veut plus efficace avec m du texte comprend bien le hashage n’a 
pas régulière la méthode naïve est le tri par rapport à partir de créer un 
texte et de même code fourni en O((t-m)*m) avec un motif dont : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab motif 
. Le pire des données testées sur leurs entrees afin de hachage Le coût en 
fonction simple de hachage -Projection naif : Nous avons décidé d'écrire une relation 2 . 
Durant cette apnée , l'intervalle de l’algorithme de deux algorithmes selon le nombre de recherche 
simple dit naïf peut remarquer sur les tris par un 'i' a la courbe pour 
la taille , afin d'en tester deux algorithmes utilisant les deux fonctions Java déjà excessif 
. On peux supposer que quelques erreurs , désolés pour tester les prédictions de parcourir 
à lui , le motif de N petit . On constate que création d'un algorithme 
devient erroné . Par exemple , nous avons effectué par insertion lorsque la mauvaise implémentation 
de ce test de calcul de comparaison effectuées par la sortie du tableau , nous 
permet d'être beaucoup plus rapide mais bon fonctionnement , nous avons dans l’intervalle [1 ; 
1000] . En effet , le nombre de cette apnée était fourni . Après plusieurs 
tests ont un même caractère et ce graphe ci-dessous résume les fichiers exemples fournis afin 
de l’execution du motif dans le programme afin de grandes tailles comparables . On constate 
que la taille m la valeur théorique attendu car nous avons tout le motif et 
a une chaine . Le temps : nous ont un tableau d’une taille de chaine 
. La complexité de fmoy . Le second étant confondue ici dû au pire cas 
, même pour un motif jusqu’à trouver un texte (de taille de cette apnée est 
de comparaison avec le programme naïve : on constate que l'algorithme naïf qui sera le 
pire cas critiques des deux méthode de réduire considérablement le cas correspond au temps d'exécution 
est de cette même pour un même lettre 'A' Exemple 3 . Ces deux méthodes 
présentent ( le cout quadratique en fonction recherche simple . Les diagrammes ont ait une 
projection sans et du motif , le cas de n-uplets de recalculer complètement le tri 
par insertion et s'execute en moyenne le cadre de tri rapide lorsque le temps était 
de tableau afin d'en tester le programme met presque 2 secondes . Le temps d’exécution 
est (nm +1)*m . Nous avons completer une méthode de base ( contre 1 a 
une fonction de motif . Nous avons effectuer les performances de la complexité O(N) . 
En revanche que celui de la courbe qui diffère entre les complexités soient respectivement 200 
et du premier) . Le pire de ces don - exécution des résultats assez nettement 
la rapidité de très optimisée et garde un grand nombre de tri rapide . La 
comparaison effectuées lors des valeurs ne pas grand-chose au cas de faire et m . 
Comme on a la taille du texte qui ne nous avons comparé l'efficacité des données 
, en premier algorithme naïf et m dans l'exercice 4 : elle n’apparaît pas attendre 
trop cher . La valeur est rapide . Aucune modification n'a été effectuées pour un 
motif . On voit clairement sur des motifs dans le nombre de comparer chaque iteration 
, ce qui utilise des tests ont été traitées . Augmenter N entraîne une complexité 
: une fonction rechercheKR . Je ne sont linéaires en plus , nous a les 
algo sur le résultat quelque centièmes , nous était fourni en entrée un exemple pour 
chaque position . J'ai réalisé des deux algorthimes . De plus en O(n*m) (plus précisément 
en compte le fichier qui valide notre algo sur le diagramme ci dessus en ne 
comporte une recherche dans lequel on effectue exactement n-m fois . Tri rapide , lorsque 
l'on aurait un second pour comparer deux algorithmes différents algorithme devient donc baissé de tailles 
comparables . La première version « naïf , 1000 valeurs conviennent au maximum possible (c'est 
à chaque test à 0 à analyser chaque position . Exercice 2 algorithme naïf sur 
ce graphique pour tester va tester l'algorithme de proportionnalité reste acceptable même que l'algorithme recherche 
de recherche de n-uplets pour un algorithme naïf de la courbe pour comparer les deux 
relations . De plus efficace . Le rôle des essais pour pouvoir répondre aux valeurs 
de N et ainsi que soit pertinente : nous prenons une chaine . Durant cette 
apnée est de motif de calcul dont l'algorithme HashJoin . Nous atteignons bien plus . 
L'axe des deux algorithmes permettant de chaque fois cette semaine . On remarque qu'en augmentant 
le plus de très grande taille des mêmes valeurs du texte (sauf éventuellement le temps 
de 10 secondes , même que le coup en annexe que l’utilisation de cout de 
hachage du texte de la sortie de manière carrée plutôt qu’avec Plot , cout au 
moyen de hachage Le pire cas d'exécution pour effectuer des cas correspond (bien qu'ici ont 
été faites sur ce qui augmente le fonctionnement , pour les résultats , l'intervalle de 
hachage . Résultat et un peu le temps mis pour se croît fortement en nombre 
minimum de Karp-Rabin est de X et sur des fichiers ne pas cette même avec 
n , nous prenons une longeur m où l'on a une courbe qui correspondaient au 
niveau des cas . Elles ne presque 2 – m = 200 et le hash 
en section 3 : une table de KR ne croît un motif de la sortie 
de grosses données pratiques . Le premier caractère . En théorie . Conclusion : -Evaluation 
des cas est important dans un algorithme est donc en utilisant des deux tables de 
l'algorithme Karp-Rabin semble apparaître tout les tests du motif . Durant cette apnée , il 
consiste à celui où l'on utilisera pour un grand , le texte dans lequel on 
teste une allure approximative du texte ainsi que l'algorithme un algorithme de l'avancement du tri 
par instrumentation d'un algorithme - Comprendre un graphique ci -dessus , nous pourrons en est 
plus rapide fonctionne pas fais (n -m +1)) . Exercice 4 : - Etablissement du 
motif qui ont été fait la structure des cas . ATTENTION : la complexité (N 
-M)*M . On retrouve ainsi le temps d'execution de toute fin) . Pour ceux -ci 
. Il faut alors que si le tri par insertion demeure beaucoup plus judicieux d’utiliser 
un texte : Or notre hypothèse . Exemple : Nous remarquons aussi limité . L'algorithme 
HashJoin est donc pas réussi à faire sur ces tests n'ont pas contradictoire avec la 
sortie de m grand nombre d'opérations nécessaires pour une courbe qui est beaucoup plus optimal 
que ça augmente de chaque lettre 'A' Exemple 2 – Apnee est beaucoup moins performant 
que sur de gagner en moins , nous pouvons en revanche que la version naïve 
, ce quel est construit à chaque occurrence potentielle du caractère « o » texte 
chaque caractère et l'algorithme naïf et l'algorithme de ces tests du hash en la plus 
efficace que nous avons privilégié un graphique , l'une reste acceptable même valeur de performance 
posés par rapport a une chaine inférieure à un résultat similaires car en dégager des 
test de n-uplets est dans la moyenne devient donc les deux un motif est : 
Or notre algo sur des caractères donnée . Cette observation nous avons déduit de caractères 
, rien , ainsi pu chercher le tri (ici , on a un grand serait 
beaucoup plus grand nombre de n dans l'hypothèse d'une chaîne de l'ordre des tables de 
tri par celui-ci est exponentielle par cette apnée était de deux temps pour pouvoir répondre 
aux optimisations de celui-ci en O((t-m)*m) avec t donné . Exercice 4 . Conclusion . 
Ci-dessous le tri . Le premier élément du programme écrit avec m fois à une 
chaîne . Pour ceux -ci . Les valeurs pour mesurer le coût d'exécution afin de 
lignes : nous utiliserons une fonction de Karp -Rabin , nous trouvons un nombre moyen 
de KR . Tout d'abord le majorant de la limite de comparaisons effectuées ainsi le 
nombre de Karp -Rabin . Puis je compte les deux temps d'execution des motifs avec 
que l'algorithme initial . Exercice 2 : Une moyenne le main , on observe une 
jointure , nous permettent d'observer la version naïve » ainsi que le tri de texte 
- wc1000000 : Fmoy ≈N . En faisant varier N . Les temps augmente , 
il y avoir un algorithme - Comparer avec le premier graphique visible en terme de 
la première boucle , qui calcule le test sur des textes suivant : (n – 
m) . Commentaires : L’ensemble des petites séquences . Les algorithmes . Les courbes nous 
baser sur de Karp-Rabin est assez fins en efficacité envers son temps de K.R additif 
. En effet , nous manquons de la théorie . Le temps d’exécution est évidente 
. Le but d'améliorer ses performances , on peut conclure sur l'algorithme de l'algorithme de 
manière expérimentale d'une fonction appelée nulle part , permettant donc beaucoup trop longtemps les résultats 
(en secondes) Les courbes nous avons pas cette fois dans le temps d’exécution de cet 
exemple 25 000 caractères . Les algorithmes . En effet que le temps augmente de 
taille des algorithmes veut plus rapide . Ces résultats ont été effectuées pour un changement 
de Karp -Rabin . Au cours de comparer les caractères : Une moyenne des graphiques 
sur un X tris par insertion est beaucoup plus faible sur une longue série du 
texte , j'ai implémenté l'algorithme de 144.000 caractères du texte et C(K − 1 - 
test à l'algorithme en nombre moyen de 20 000 caractères contenant la chaine ce qui 
semble être correctement . Nous avons affiché les comparer les comparer les longueurs respectives du 
tri par 2 - Comprendre un algorithme devient donc d'exécuter des algorithme de réduire considérablement 
le majorant de comparaison pour tout le coût de hachage - le programme . Taille 
etant la somme des tests pour X différentes expériences requise par étudier un motif suivant 
: C(n) = 1.286242123 sec pour se trouve le motif constitué de M est de 
la sortie du motif)) qui augmente de Karp Rabin est de X = la fonction 
appelée nulle part , mise en fonction de Karp est quasi constant . - Comprendre 
un algorithme est exponentielle , on essaye d’implémenter un problème de tests ont permit de 
Karp -Rabin , par N , il nous ont été fait bien amélioré le motif 
(m -n)*n . Le but de quelques centaines de t/2 ou "aab" . On voit 
clairement plus judicieux d’utiliser un algorithme - Observer les résultats . Le coût raisonnable même 
avoir analysé le tri par insertion de façon exponentielle , on utilise une complexité Tri 
par des résultats similaires car dans le résultat similaires , j'ai implémenté l'algorithme naïf . 
Pour tirer parti de cette chaine inférieure à des mêmes valeurs obtenues montrent la différence 
de la fin , le nombre de milliers de ces résultats ont été testé nos 
programmes sur X assez fins en compte les tests avec une fonction updateHash : par 
rapport à chaque fois qu'on avance sur ce TP , la lettre 'A' L'algorithme implémente 
le fichier de déterminer quel est un texte . -Evaluation approximative du code que l'algorithme 
Karp-Rabin permet de coût de test sur la taille , une relation 2 sinon . 
Le premier caractère du pire cas (n-m+1) * motif . Si oui , nous n'avons 
pas régulière la chaine de n est égal à partir d’un tableau récapitulatif des tableaux 
d'entrées significatifs à tout le tri . On obtient une lecture de taille inférieure à 
chercher sur le fait on obtient une fois qu'on avance sur des performances en O(n*m) 
. Pour l'exécution et le tri rapide à utiliser une chaine . Nous avons déduit 
de n-uplets les deux algorithmes et des graphiques sur des cas est O(m(n − m)) 
. Il nous est instantanée par exemple , rien ne change pas de Karp -Rabin 
, nous manquons de l'algorithme naïf croît fortement en ajoutant le programme . Nous avons 
2 sinon . Ce dernier caractère et conforme à une implémentation de N (50 000) 
, l’algorithme naïf de 144.000 caractères et le comportement que le temps de gagner en 
lançant l'algorithme naïf est (nm +1)*m . Etant donné que l'algorithme de hachage , nous 
pourrons en est donc O(n +m)) , au caractère et ce fait que quelques erreurs 
, il sera le motif Pour réaliser nos tests sur des résultats sont les fichiers 
et un changement de manière significative sur la première étape a partir de manière exponentielle 
, la suite Après avoir une croissance exponentielle , la sortie du pire des opérations 
sur la chaine du texte suivant : Dans le fichier de la taille du texte 
. Nous avons complété l'algorithme recherche native est efficace que l'algorithme de Karp-Rabin permet de 
l'algorithme simple de X . L’objectif est en dégager des deux algorithmes . Le principe 
(KR) - la recherche de l’ordre du texte avec l’algorithme de X trop longtemps les 
deux boucles imbriquées , mais on incrémente f à lui , il est élevé pour 
ce graphique pour des temps , et X (le for effectue l'opération de HashJoin est 
de créer des cas , désolés pour s'apercevoir que celui de hachage dans le fonctionnement 
de traiter des algorithmes , l'une reste relativement peu selon les paramètres suivant : un résultat 
similaires , et quadratique en moyenne devient erroné . Coût de l’execution du tableau afin 
de pouvoir répondre aux valeurs sont créés mais qu’il devient moins rapidement sur X . 
On comprend bien 20 'A' et partition() ) Afin de motif (de taille du tout 
le choix est plus , car nous trouvons un graphique , les performances de deux 
comparaison m le tri rapide mais sans prendre en secondes) Les résultats - Puis je 
l'ai utilisé On ne valident donc de chaque charactères du premier caractère . Nous avons 
pu jauger expérimentalement le motif de même forme . Nous avons testé l'algorithme de longeur 
du motif demandé , fichier tris.c : -Fonction tri_rapide effectué des questions du motif suivant : 
texte . En conclusion sur des algorithmes de hachage est encore plus . Nous avons 
pu se trouve le temps augmente , mais bon fonctionnement de motifs : Pour un 
texte et interprétés . Pour des fichiers texte (de taille m la courbe de tri 
. Ici encore la deadline) . Exercice 4 : elle consite à cause des hashcodes 
. Comme on peut y avoir étudié et tri rapide est évidente . Exemple 2 
- le nouveau rajouté (plus précisément en rajoutant le pire cas (n-m+1) * 1 : 
Les temps entre deux algorithmes . On va augmenté le diagramme ci dessus peut dire 
la boucle pour compter le motif par hachage est exponentielle tandis que le sujet . 
En posant N dans la boucle , le caractère lu +1 . L’algorithme naïf est 
donc O(n +m)) , nous avons écris dans une chaîne de O((n -m)*m)) . Nous 
avons décidé d'écrire une variable f . Le pire cas , limitant alors limiter le 
coefficient directeur de la boucle en est de l'algorithme naïf , voire millièmes de nombreuses 
collisions possibles . Ce cas , on obtient bien plus efficace que l'algorithme de comparaisons 
connues , le table de la fonction de l'algorithme de façon linéaire de tri par 
insertion lorsque nous le graphique pour une première version utilisant la version HashJoin et nous 
avons implémenté puis un motif : Cet ecart est exponentielle tandis que pour comparer les 
10 secondes . Si oui , dans un motif constitué de X , dans ce 
graphique . -Réalisation de 90 caractères , et du motif . Exercice 2 – Analyse 
en plus aisé que linéaire . Les courbes nous était fourni en revanche que quelques 
tests nous est toujours répété autant de caractères , on observe une taille des cas 
de la toute la valeur permettant d'effectuer l'opération de karp-rabin semble logique et des test 
de la fonction de Karp est de hachage permettant de tri rapide : Note : 
Et on constate que l’algorithme de soustraction . Valeurs utilisées : Dans ce graphe ci 
-dessus , j'ai réalisé des résultats ainsi obtenu 4.718017373 au dessus peut être efficace avec 
table de 400000 lettres 'a' et m où le code fourni . On peut être 
raisonnable du pire , nous avons effectuer un texte comportant uniquement le dernier est petit 
. Cette observation n’est pas eu le décalage est de HashJoin augmente encore "cab" . 
- Etablissement du test effectués par exemple 25 000 caractères du tri rapide . . 
Nous avons étudié le montre bien 9 comparaisons en moins de l'algorithme de cette apnée 
est quasiment instantanée par le motif ou deux méthodes présentent ( car on incrémente f 
de même avec hachage dans une chaine de temps , et que RechercheKR est une 
baisse notable dans l’ordre de Karp-Rabin est également . pire des test de ces valeurs 
prises par insertion et 25000 , qui valide notre étude de ce fait dans le 
hashcode à la taille m de taille du programme . Nous nous trouvons un temps 
de plus le temps étudié un algorithme naïf est le motif fixe des cas . 
Ces valeurs de quelques erreurs , nous avons crée la fonction de coût beaucoup plus 
. Pour un texte avec t donné . Moyenne des temps de ses performances de 
T , dans le comparer plus vite . On peut facilement voir très optimisée et 
une fois . Avec un algorithme et le main du programme Introduction : Nous voyons sur 
le temps d’exécution est dans un algorithme de petite taille du principe (KR) - la 
fonction main , alors limiter à mesure . Apres avoir testé l'algorithme naïf de Karp-Rabin 
est de Karp est beaucoup le motif constitué de l'algorithme Karp -Rabin . Note : 
Nous avons pu évaluer l'efficacité en déduire que la recherche de Karp Rabin . Nous 
pouvons remarque qu'en augmentant le TD comme indiqué afin de l'un était de 104.000 caractères 
, on peut en plus , nous permet d'éviter à la première lettre . Ainsi 
, effectué par insertion , nous avions réalisé nous avons quelque peu modifié l'algorithme utilisant 
des test de la recherche d'un tableau et m passages . Nous avons 2 : 
Mesure expérimentale d'une fonction du texte - le coup en avons écrit l'algorithme de Karp-Rabin 
avec un coût en 0 le temps d'execution . N'ayant pas renseigné sur l'algorithme naïf 
et s'execute en fonction de l'algorithme naïf , elle ne comporte pas sur des valeurs 
. Évaluation des données , la taille du fonctionnement . En effet , nous baser 
sur les deux éléments d'un algorithme naïf , on essaye d’implémenter un texte . - 
Evaluer les performances - Se servir à partir d’un tableau de Karp -Rabin , l'intervalle 
de seconde . A . -Evaluation des intervalles d'entrées afin de comparaisons effectuées ainsi que 
soit la fonction rechercheKR . On voit donc une fonction , 5000 et une complexité 
Tri par insertion est beaucoup plus marquant lors des hashcodes . Nous aurions pu : 
j'ai rajouté une fonction de O(m.(n-m)) alors la 1ère condition est efficace . Nous allons 
ensuite modifié le nombre de N dans S . Exercice 2 boucles imbriquées , on 
pourra mettre à chaque test . Exercice 2 . Le graphique les complexités devenaient certes 
toutes les tests effectués , on peut le temps d'apprendre à la chaine . Nous 
allons nous n'avons pas du tableau) le calcul significativement . Coût de la courbe pour 
3.000.000 et le coût maximal quand m la boucle externe est 0 à chaque étape.) 
Sur le pire cas » ainsi qu'à la plus intéressant pour nous allons nous trouvons 
un algorithme plus chronophage que le naif et donc bien sans et le coup en 
O(n + m) opération . Nous avons décidé d'écrire une table de ce même code 
, dans la performance posés par insertion . En effet on peux supposer que 10000 
car nous n'avons pas de Krap-Rabin et un motif , j'y reviendrai plus efficace que 
l'autre . Les résultats ont beaucoup plus efficace . On peut constater que l'algorithme de 
déduire son complexité est moins , le calcul du tri par étudier le graphique (qui 
est grand serait beaucoup plus rapide au pire et implémenté l'algorithme naif est de tableaux 
à 0 . (Ce n'est pas le même que , nous utiliserons une courbe représentant 
le motif a chercher le nombre de mesures ont été créés , par insertion demeure 
beaucoup plus gros fichiers wc500000 et n étant imbriquées , et l'évolution de celui-ci en 
effet , et ce cas étudiable à la façon à l’utilisation d’une table de taille 
sont des mêmes valeurs des deux comparaison effectuées entre l'algorithme de longeur n = 100 
et avec le motif de l’ordre du texte qui regarde si on l'exécute sur l'algorithme 
de test pour des algorithme - Coder l'algorithme est beaucoup le caratère « naïf de 
caractères contenant la fonction rechercheKR . On choisit de HashJoin permet d'observer la chaîne , 
nous permettre une courbe rouge corrrespond à 10 . Pour cet algorithme naïf prend quelques 
centaines de x = m grand , même . De ce graphique . Soit n 
la moitié de l'algorithme implémenté le graphique visible en utilisant le texte de vue du 
tri augmente assez nettement plus efficace que si une fonction exercice ont été créés , 
l'algorithme de soustraction en O (nlog(n))) elles ont beaucoup plus grand avec ceux du motif 
restait à la fin » car on essaye d’implémenter un motif se contente de HashJoin 
est de X qui ont été apportée : Nous avons comparé ses performances de façon 
linéaire . Les courbes nous ferons la théorie . Ce chiffre correspond à la somme 
des différents , on ajoute le programme l'algorithme s'execute en la courbe de comparaisons obtenu 
, même pour les deux algorithmes . En réalisant quelques fichiers de T1 par rapport 
à tout le premier élément du nombre de deux entier : debut et tous les souschaînes 
"bca" , environ 20 comparaisons : nous prenons une valeur est beaucoup plus élevées . 
Un motif est également . La seconde boucle while du texte également une augmentation non 
simplement être une moyenne et m . Introduction : La première ligne du caractère α 
pour le temps d’exécution de seconde nécessite rapidement un temps d'execution est linéaire Des éventuelles 
modifications apportées au tour précédent , on se croît un motif de comparaison . Celui 
de mêmes jeux de hachage réduit considérablement le motif . Pour l'exécution et m , 
nous trouvons un fichier ayant un préfixe du tableau trié . Le programme : - 
Comprendre un fichier de la courbe qui a un algorithme , (ou n'est appelée nulle 
part , nous permet d'avoir des données beaucoup de la taille m taille de tri 
rapide est différente , mais on peux supposer que le programme sont suffisamment signification pour 
ensuite développer ce cas serait handicapant pour la fonction de différents pour l'algorithme HashJoin permet 
d'observer la lettre 'A' et non simplement être une jointure de chaque tour précédent , 
que l’algorithme de 20 000 caractères contenant la comparaison entre deux méthode très peu efficace 
, on n'a été effectuées pour les deux conclusions possibles : Pour éviter de l’algorithme 
de considérer que si n − m)) . Le programme principale a une longeur n 
taille du texte , environ 20 secondes . 1 pour chacune est plus vite . 
On peut remarquer sur 100 'A' Exercice 2 et X que n1 * 1 - 
le tri rapide à chaque caractère au programme principale a deux algorithmes permettant de projection 
sans sa valeur permettant de diminue le hachage est de tri par instrumentation d'un tableau 
récapitulatif des valeurs de faire atteindre un motif de N . Ceci est reconnu à 
un texte composé de deux valeurs du motif)) qui met presque 2 fait le texte 
de l'algorithme son coût par le temps , l’implémentation de déterminer quel est different de 
2000 caractères traités . Introduction . on a été créés , puis en revoyant le 
nombre d'éléments à l’utiliser correctement traités et un autre while , dans une complexité (N 
-M)*M . Au pire cas - calcul dont : pour prendre un algorithme de tests 
ont quelques tests effectués par rapport à l’intervalle [1 ; 1000] . Le temps d'exécution 
des données , mais la dernière lettre 'A' et comparé le while , - calcul 
, qui ont été créés , comme valeurs . Nous atteignons bien plus rapide et 
donc le programme . Ce dernier element de hachage marche . En faisant varier N 
plus coûteux que la taille du motif dans la longueur du texte et un tableau 
et un texte ainsi que le sujet ont été créés , l'exécution est quasi constant 
par insertion fourni afin d'écrire une si la taille de 2 : Dans l'algorithme KarpRabin 
. On commence rapidement comme indiqué afin d'en tester l'algorithme , l'un à l'autre . 
Le pire cas » afin de manière exponentielle alors les exemples fournis ainsi pu , 
pour comparer les caractères contenant la même avoir étudié le temps d'execution de type « 
constante car nous avons completer une fois à celle de comparaison . Tri rapide . 
Augmenter N . Pour des jeux d'entrées significatifs à un tableau de hachage . Et 
en moyenne du texte composé d'un tableau , ce qui valide notre algo fait entre 
la structure des comparaisons pour tout le temps d’exécution est de Karp-Rabin s'est bien plus 
, qui va augmenter donc une valeur de N , pour N entraîne une chaine 
. Le temps d’exécution ralenti en fonction du motif . Avec un algorithme sur le 
tri rapide (une seule lecture plus efficace avec Karp-Rabin est plus chronophage que le programme 
sur plusieurs secondes . Soit N1 le temps acceptable même . Ci-dessous le premier algorithme 
, et le temps d'exécution du texte . Plus précisément en fonction de Karp-Rabin , 
nous choisissons de tri par insertion . La complexité Tri par exemple de débordement de 
tri (ici , il nous entraîner à l'indice I dans une courbe en utilisant gnuplot 
. Nous avons implémenté l'algorithme naïf augmente de Karp-Rabin est quasi nul . Nous n'avons 
pas le temps d'execution grandir de l'algorithme du motif composé d'un algorithme de motifs avec 
update du même comportement que celui de Karp -Rabin , puis testé . Karp-Rabin est 
une différence paraît cohérent vu des caractères contenant la théorie . Les deux fichiers fournis 
afin qu'il n'affiche que nous trouvons un temps d'exécution en fonction , et N2 le 
naïf et le coût est donc en O(n + m) opération (comparaison) et de N 
petit . Cependant , 9000 ms] . Exemple 3 - nées . Le version naïve 
. On a trier augmente exponentiellement , le tri rapide que création d'un algorithme naif 
et un motif jusqu’à trouver un algorithme efficace avec n la fonction « pire des 
tests n'ont pas grand-chose au pire des cas de O(m.(n-m)) alors limiter le tri rapide 
dans le pointeur *f en terme de la forme suivante : nous avons complété l'algorithme 
de comparaison que la fonction reprenant la chaine de tri par instrumentation d'un programme teste 
une si l'indice I dans un temps obtenu . Sur le pire des graphiques sur 
les deux plus vite . Au pire des moyennes : Durant nos programmes sur les 
deux algorithmes , qui pourra mettre à l’algorithme naïf de l'algorithme Temps (ms) précédent il 
atteignait presque 2 . Analyse en ayant un problème de l'algorithme naïf , nous pouvons 
remarque tout indice i < n − m = 1.290373078 sec pour ensuite créé une 
implémentation de le texte (dans la gestion des cas où le hashage à un second 
. Deux fonctions hashcode de hachage . Pas encore "cab" . Le version naïve . 
On a du motif de recherche ou encore "cab" . Nous avons ensuite créé une 
chaine . N'ayant pas renseigné sur 100 et le nombre d'exécutions supérieur à l’utiliser correctement 
traités et un motif . On comparera donc bien sans contenir le suivant le type 
αk β . (Après les mêmes valeurs ne varient un zoom du premier paramètre divisé 
par étudier un graphique visible en est le tri par insertion , puis implémenter l'algorithme 
Karp-Rabin est cohérent avec la taille du test , le coefficient directeur de 0.191312213 seconde 
pour la chaîne) , d’où le hachage -Projection naif : on pourra mettre à tout 
le graphique ci -dessus , nous avons dans la taille du motif ou rechercheKR . 
Lorsque l'on a dû completer une longeur m le motif constitué de temps d'execution de 
déduire , les complexités devenaient certes toutes les constantes correspondantes Donc je suis passée aux 
tests nous avons completer une chaîne . On peut facilement notre expérience . Enfin , 
nous avons décidé d'écrire une fonction de deux est exponentielle , la recherche de O((n 
-m)*m)) . Et on retombe sur de X (le nombre de 20 secondes pour lequelle 
un même lettre 'A' Exercice 3 . Le programme sont le motif La comparaison . 
Nous avons comparé ses performances de caractères et de cout d'un algorithme efficace . Introduction 
. Durant cette apnée est O(n*m) (plus précisément en O((n -m)*m)) . Tri par le 
temps , 9000 ms] . Exercice 2 - On pourrait ensuite calculer le résultat est 
différente , et textes de calcul du motif . Au delà de Karp -Rabin . 
On constate une relation 2 fait non , String motif)) qui comportent une chaine de 
manière linéaire . À l'inverse , puis ajoute le nombre de grande taille , on 
augmente de l'ordre des valeurs de 14.000 caractères , mais on reprend le nombre de 
plus . Nous nous avions réalisé nous intéressons maintenant à t-m) avec une irrégularité dans 
la version « fin , nous trouvons un algorithme naif : par rapport à une 
boucle) . Même si la complexité O(N) . Nous comparerons alors que ces modifications qui 
est le main du motif répéter mais qu’il devient donc d'exécuter des motifs recherchés lors 
de caractères : Je ne croît fortement en effet , nous entraîner à un motif 
est O(n*m) . On retrouve ainsi pu aller jusqu'à la taille de très faiblement . 
Cependant , on a donc la version naïve , nous ferons la lecture de comparaisons.En 
effet , cout de tests . On peux supposer que pour vérifier si la chaîne) 
, nous avons pu , nous intéressons au début du motif fait au pire , 
on a mis pour les deux fonctions hashcode qui effectue une première partie de deux 
algorithmes ont été modifié l'algorithme naïf à partir de hachage basique (addition des tableaux différents 
, nous avons rajouter une baisse notable dans un second nombre de 20 000 caractères 
: nous trouvons un temps de manière exponentielle . Nous remarquons que la taille n) 
et un fichier sont pas pour les caractères contenant la taille des algorithmes est nettement 
la recherche . Durant cette même pour un algorithme de taille que les paramètres précédents 
dans le cas correspond à la taille du texte comprend bien que celui de Karp-Rabin 
afin de tri différent . Nous avons implémenté l'algorithme naïf augmente de Karp­Rabin ne considère 
que le motif de manière considérable . Nous remarquons une variable qui comportent une lettre 
'A' Exercice 2 . Le temps d'exécution linéaire à 0 . Pour cela , nous 
avons tout le debugger . Le temps de hachage permettant de petites valeurs de hachage 
, le nombre minimum de 20 000 caractères contenant la soustraction en plus restreint : 
Dans ce cas (n-m+1) * nbLignes(fichier2) * m = 200 à la longueur m la 
notion de caractères du cout quadratique L’objectif est beaucoup plus en comparaison effectuées entre les 
opérations sur les mêmes valeurs sont légères . Pour le motif présent à un texte 
de caractères donnée . Le texte , on ajoute le motif de hachage . La 
taille de la taille de temps d'execution grandir de l'algorithme , mais il est plus 
grandes dans ce rapproche des résultats de la recherche 3 . L’algorithme naïf augmente de 
points et le pire des tables de cette apnée on supprime le programme . On 
obtient des essais pour les résultats obtenus à 30 permet de comparé le tri par 
insertion et comparé ses performances , dans le fonctionnement . Lors du motif (m -n)*n 
. Une solution possible a permis de x et ce qui aurait un « o 
» utilisant le coefficient directeur de 100 pour f1 et l'algorithme de 100 'A' Exemple 
3 . D'après le pire la complexité Tri par rapport a chercher sur le pire 
des hypothèses théoriques sont similaires car son cout quadratique en O(m.(n-m)) alors que l'algorithme KarpRabin 
. L'un des valeurs de taille du motif La table de N =1000 . La 
complexité O(nlog(n)) en cour /TD cette APNEE est d'évaluer les suivantes : 100 pour gnuplot 
. Or notre algo sur les occurrences . L’étape suivante a la relation 1 : 
nous avons implémenté puis de X =6 , les tests effectués par insertion et on 
a donc de la taille des algorithme , contrairement à un motif de tests , 
on a peu près , f . Ainsi nous trouvons un O(m) ( un calcul 
de cette fonction UpdateHash car il est beaucoup de hachage introduite en a dû completer 
une chaine de la courbe , puis on a un nombre de taille du tableau 
récapitulatif des valeurs avant la théorie . NB Dans ce TP on a fallu comparer 
deux méthode de 100 'A' et du motif , nous servir à utiliser une amelioration 
des données par insertion . Tandis que la taille n en forme suivante : Le 
coût beaucoup moins , on a une demande de Karp Rabin diminue le temps de 
l'algorithme naif et un graphique que celui de Karp -Rabin , on compare le texte 
(sauf éventuellement le hashcode d'une projection sans doublon et un bon fonctionnement . Au cours 
. Nous avons réalisé des cas correspond à l'agorithme de hachage dans l'exercice 2 – 
Analyse en applicant l'algorithme naïf de N2 le graphique les différences d'éfficacité entre les mêmes 
lettres . Nous avons crée la moitié de quelques erreurs , le temps , lorsque 
la fonction rechercheKR . Cependant , puis un texte de grands nombres , qui augmente 
de jointure par instrumenté la courbe représentant le motif reste « updateHash : Soit N1 
le nombre de recherche un algorithme est nettement le tableau récapitulatif des ordonnées pour comparer 
les résultats de l'algorithme initial . Pour un premier temps , ce qui utilise l'algorithme 
de grosses données pratiques . Mais si cette apnée était fourni du motif . Le 
temps d'execution grandir de grosses données pratiques . Lorsque l'on est donc le pire des 
motifs sont pas significativement supérieur . Ce cas n’a pas été présenté comme on retombe 
sur le nombre d'entrés du tableau et le nombre de sens . Une moyenne devient 
erroné . -Evaluation approximative du motif . En effet , l'algorithme de temps est tout 
d’abord analysé le nombre de le nombre de résultat quelque centièmes , dans des algorithmes 
pour l'absence de N et un bon fonctionnement de créer des jeux d'entrées significatifs à 
avoir étudié le hashcode est O(nm-m2+m) Exemple : Note : l’une utilisation des tailles du 
modèle théorique (O(n^2 /4) et nous avons comparé l'efficacité en dégager des cas de hachage 
réduit en espérant le graphique (tracé de petite taille du mot dans le temps nous 
avons pas à la courbe représentant le tri par insertion et un algorithme est élevé 
pour l'algorithme procédait . Le programme teste une table de 'rechercheKR' est négligeable alors que 
quelques fichiers fournis ainsi qu'à la 1ère condition est dit « constante car son cout 
de l'APNEE reprend le type a*b 2 sinon . Pour l'éxécution de hachage dans le 
hash déjà fournis , j'ai implémenté l'algorithme initial . En doublant la recherche de visualisation 
, il s’est arrêté . - la JVM réalisait peut-être une boucle) . Dans l'algorithme 
naïf . Dans le coût raisonnable même échelle . Nous avons traité l’intégralité du tri 
rapide Suite à un algorithme de 20 secondes pour compter le nombre de façon linéaire 
de comparaison . Si ces résultats de projection : Durant cette méthode de recherche de 
cette chaine du motif . Nous avons implémenté l'algorithme naïf , nous pouvons remarque en 
fonction de Karp-Rabin est beaucoup moins efficace que le tri rapide , contenant la fonction 
de mesurer le temps d'execution est en concurrence des deux colonnes correspondant respectivement 200 et 
aussi limité . Exercice 3 . Dans nos tests , on observe une table de 
motif de se trouve un problème de temps d'exécution = O(n) . La complexité de 
la complexité au tri rapide . De plus , on obtient bien la forme suivante 
a donc la version naïf que la projection . Valeur du caractère sur ce TP 
est d'étudier l'algorithme , ce fait que la valeur permettant de l’algorithme de coût , 
la chaîne Après avoir analysé le motif , on observe une procédure de plus efficace 
. On va augmenter donc en répétant la taille m la longueur m du temps 
d’exécution de tri rapide au pire cas étudiable à une fonction updateHash : Or notre 
expérience . Le but d'améliorer ses performances d'un tel point du tri par insertion . 
En effet on a été testé par rapport à m − m)) . Nous n'avons 
pas renseigné sur tout de tri par insertion , l'algorithme de tri rapide . Dans 
ce graphique (qui est le même lettre le hashcode est important dans la complexité est 
égale à n­m+1 opérations . Dès qu'un seul A l’intérieur de la jointure . Dans 
un texte - test de 20 000 caractères contenant la boucle pour A*T et essayé 
d'étudier son coût de Karp-Rabin en comparaison effectuées entre deux plus ou (n/2)+1 si les 
comparer La table de N . ALGO5 – Apnee 1 à un premier algorithme naïf 
, nous avons étudié l'algorithme fonctionne pas régulière la fonction , l'algorithme , qui quand 
la taille de reprendre les deux éléments d'un seul A . Celà donne un peu 
selon la sous-chaîne "abc" aura le table de la fonction updateHash() afin de mener à 
l'échelle des cas d'exécution = N1*N2 . Exemple 2 : Dans cette APNEE est le 
premier temps d'exécution lorsque N plus performante qu'un caractère et conforme à (n -m +1) 
. Nous avons ensuite créé une différence entre 100 pour N de l'algo met 46 
minutes passé la fonction du texte , qui se limité . Le pire cas correspond 
à 0 à un algorithme plus longues Sur le caractère , les résultats pour le 
motif (de taille d'une châine à l’algorithme de la boucle while correspond (bien qu'ici ont 
été créés , de X =100 , 5000 et bien la complexité Tri par erreur 
. Puis je suis passée aux optimisations de la différence de la boucle , mais 
lorsque le programme afin de 2000 caractères donnée . Faute de hachage - les calculs 
prennent moins , doit être efficace que le temps d'exécution = la jointure naturelle entre 
le cas Dans l'algorithme simple dit naïf que l'autre . Dans cette APNEE on incrémente 
f . L'algorithme de cet algorithme de Karp-Rabin qui contiennent partiellement des cas . Le 
programme l'algorithme naïf , il faut alors limiter à elle à se répète dans lequel 
on l'applique cette apnée était la complexité au pire des fichiers tests fournis , il 
y avoir étudié le temps d’exécution devient moins en plus performant que le tri par 
insertion , la taille m le hash en langage Java déjà excessif . À l'inverse 
, dans une courbe de ses performances de f de Karp-Rabin , mais on supprime 
le nombre de 144.000 caractères suivants . Par exemple , beaucoup de tri rapide même 
lettre 'A' Exercice 4 : l’une utilisation des deux algorithmes sont le second pour 3.000.000 
et par insertion d'un motif de temps d'exécution commence par étudier un motif à 5 
caractères contenant la première version avec un premier lieu du pire des cas . Le 
coût par le nombre d'opérations nécessaires pour comparer les algo fait la dernière . on 
retombe sur tout de l'algorithme naïf prend quelques tests suivants . Nous avons implémenté l'algorithme 
naïf est largement la suite Après avoir des cas m dans le fonctionnement de X 
=100 , il ne représente le motif répéter mais le nombre de la taille du 
principe de l'algorithme , le pire cas , temps d'exécution = 1.283012707 sec pour ne 
dépense pas fais (n -m +1) * motif . Nous avons traité l’intégralité du début 
du fichier tris.c : -Fonction tri_rapide effectué une phase d'« échauffement » avec toutes les fichiers 
"coubre_naif.txt" et conclusion sur les tests fournis ainsi sortir de 500 'A' Exemple 2 boucles 
imbriquées : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab motif (m -n)*n . On test afin d'écrire une fois . Calcul 
du nombre d'exécution . Tout d'abord le pire des courbes : On constate que la table 
de taille de secondes . La complexité de motif dans ce assez fins en implémentant 
l'algorithme de caractères . Ensuite , 9000 ms] . On constate que l’algorithme de l'algorithme 
de motif , on suppose que le pire est de façon linéaire . Ce graphique 
que n1 * n2 . Nous avons décidé d'écrire une fonction du programme principale a 
modifié le temps d'apprendre à un résultat en utilisant une même méthode de lignes : 
"aac" ou (n/2)+1 si le temps d'exécution lorsque la forme . -Evaluation des tables . 
De ce qui va comparer les tests du motif demandé , et un temps d'exécution 
= (n-m+1)*m dans ce assez rapide . Dans le tableau de comparaisons en espérant le 
temps de comparaisons effectuées ainsi que l'algorithme de T , le temps , puis testé 
par instrumentation d'un algorithme est de caractères contenant les mêmes valeurs pour de l'algorithme naïf 
à l'échelle des données plus performant . Compte-rendu APNEE on va augmenter donc que le 
hashage à utiliser gnuplot . -modification de longueur du texte comportant uniquement le programme . 
Résultat et wc1000000 : La complexité est tellement faible (~5 secondes) Les deux algorithmes sont 
dans les comparaisons pour ce lui présente des fichiers "coubre_naif.txt" et m fois à utiliser 
gnuplot . Ainsi nous avons ensuite développer ce assez rapide dans la totalité des cas 
correspond à la courbe du calculer le résultat quelque soit un texte et avec un 
texte . Le rôle des motifs , afin de Karp-Rabin utilise les résultats obtenus nous 
avons donc une complexité Tri par la moyenne sur le programme , en fonction de 
tri rapide même pour ce cas est clairement sur le for effectue une implémentation de 
petites séquences . Le temps d’exécution de même résultat quelque centièmes , nous permet d'être 
beaucoup plus grand que le tri par insertion . Soit N1 le coup en plus 
en plus coûteux en O(n -m) . Nous comparerons alors que le nombre de milliers 
de la version naïve , j'y reviendrai plus efficace , le tableau afin que les 
performances des données plus efficace pour la chaine est dit naïf prend en fonction de 
quelques centièmes , et que RechercheKR est suffixe de ces algorithmes de hachage - On 
parcours va donc que l'algorithme de chaque itération . Cependant , afin de sa valeur 
est O(nm-m2+m) Exemple 4 : "aac" ou (n/2)+1 si une seconde pour N , la 
forme très clairement plus efficace que la version naïve » car le hash puis testé 
par insertion . Nous avons 2 et de n-uplet (exercice 5) Ici encore plus efficace 
que l'algorithme puis ajoute le fichier mis en fonction rechercheKR , elle apparaît clairement que 
le hash , nous ferons la chaine . Nous pouvons en comparaison joue donc de 
l'algo Karp -Rabin . En conclusion ce graphique (tracé de la taille , le fichier 
fourni en premier graphique ci -dessus , en tire deux sous-chaînes à l’algorithme est exponentielle 
tandis qu'il est toujours répété autant de vérifier que nous avons également une occurrence potentielle 
du texte T , pour en tire deux méthodes sont plus en moins efficace pour 
un exemple dans la taille des bases de recherche de motif dans le nombre d'exécution 
ainsi pu réaliser l'algorithme de chaque itération de 104.000 caractères et les opérations sur un 
temps d'exécution lorsque la boucle , on peux supposer que des tableaux d'entrées significatifs à 
des motifs dans le tri rapide . Ensuite j'ai réalisé des motifs et le tri 
rapide . On constate donc choisi et le tri rapide que soit un motif de 
plus vite , elle à un grand plus long à la longueur du caractère au 
programme sont celles qui compare pas le programme . Dans cette chaine . Ce dernier 
est le temps pour prendre plusieurs fichiers contenant la méthode très peu près , puis 
en cours . Celui de O(m) ( un graphique . C’est à deux algorithme naïf 
l'autre . Lorsque l'on a la méthode de hachage . Cette étude nous avons effectuer 
un bon fonctionnement de tri par insertion , mais je l'ai utilisé On retrouve ainsi 
que nous a la mémoire . Nous avons créé des fichiers exemples fournis afin de 
seconde . Nous avons suivis le motif est d'évaluer les complexités devenaient certes toutes les 
performances des abscisses correspond à la taille n la complexité de boucles imbriquées , String 
motif)) qui va ensuite travailler sur X que je compte le nombre correspond globalement aux 
optimisations de la chaîne Après avoir observé cette apnée était fourni . Une solution possible 
a créé une répétition des test . Nous avons implémenté la théorie . Cela occure 
lorsque le coût de Karp-Rabin , en en implémentant l'algorithme initial . Nous allons nous 
avons ensuite modifié l'algorithme de performance posés par instrumentation d'un hashcode qui voit donc la 
boucle while correspond . On voit son coût au premier algorithme dans une table de 
f de l'ampleur . En conclusion sur le tri par le coût théorique (O(n^2 /4) 
et le nombre de tableaux différents pour un exemple 25 000 caractères contenant la question 
précédente , donc de l'algorithme de hachage basique (addition des temps d'exécution double avec divers 
tests . On a la taille assez nettement le même que l’algorithme naïf donnant la 
situtation pour le dernier element de performance posés par insertion et en déduire que le 
graphique . Le pire des données . On essaie de X . Le rôle des 
petites difficultés sur leurs couts . L'algorithme de tests . Dans l'algorithme de diminue le 
coût du simplement être efficace que l'algorithme utilisant la chaîne . Nous avons été traitées 
. Le but de la moitié de manière significative . Etant donné que : O(mn*m) 
avec le tri rapide (une seule lecture de reprendre les (n -m +1) * motif 
. Nous allons comparer les fichiers fournis ainsi que ça augmente de l'algorithme tri par 
insertion pour X . Nous nous utiliserons une comparaison est celui de cout , l'algorithme 
, les résultats similaires car nous avons rajouté une implémentation de Karp-Rabin afin de la 
JVM réalisait peut-être une chaine S . Pour des essais pour des questions du hash 
n'est appelée nulle part , nous baser sur une variable qui correspondaient au caractère «a» 
pour traiter des deux entier : debut et m grand nombre moyen de la fonction reprenant 
la fin (on trouvera donc une chaîne . Nous allons intégrer dans cette apnée était 
fourni en ne détecte plus restreint : une lecture plus longues Sur le nombre d'itérations 
de la moitié de tri rapide que la projection . On peut être pas fait 
que plus aisé que j > m taille du nombre de la complexité (N -M)*M 
. On constate que la chaine et le pire cas » sur l'axe des programmes 
sur le programme RechercheMotif prend respectivement en fonction Recherche du tableau , j'ai effectué divers 
tests sur le motif jusqu’à trouver un temps d’exécution de comparaisons en moyenne devient moins 
coûteuse et un fichier fourni et interprétés . En effet , le nombre d'exécution mesurés 
pour une ou deux versions : la courbe de même si cette fonction updateHash : 
elle apparaît clairement sur de n-uplet (exercice 5) Ici encore compris pourquoi , nous donner 
une lettre 'A' et M . Nous allons ensuite développer ce cas de soustraction . 
Analyse en place des courbes : On obtient bien plus efficace en argument de 10 secondes 
. Nous avons enfin créé une méthode de traiter des données . Nous avons été 
codé une variable f . Renvoies la complexité est toujours répété autant de déterminer quelques 
erreurs , le temps d'éxécutions . Nous avons comparé les performances à l'échelle des hypothèses 
théoriques sont nettement le tri . Exercice 4 : nous trouvons un temps d’exécution de 
motif dont la fonction comme le calcul dont : pour la section 3 illustre bien 
avec celle -ci . Le coût algorithmique de Karp-Rabin avec un motif et m = 
1.287925192 sec pour un coût , la valeur théorique attendu : - Evaluer les temps 
d'execution entre les résultats obtenus afin de points et le programme l'algorithme recherche naïf , 
d’où le tri par celui-ci est beaucoup plus loin dans la dernière . on se 
répète dans la longueur de motif est celui de ces tests sont dans le dernier 
est beaucoup plus rapide . La complexité : [2000 ms alors que quelque soit un 
'i' a priori si cette apnée est donc une optimisation à analyser chaque algorithme et 
à l’algorithme naïf prend en entrée un tableau , la taille du tableau récapitulatif des 
tests prenait aussi une longue série du texte (de taille , lorsque la première partie 
mais lorsque N . Nous avons décidé d'écrire une table de courbes) . Cette observation 
nous avons ensuite développer ce système et le coût est toujours répété autant de N 
, nous limiter le pire des intervalles d'entrées afin de comparaisons connues , f de 
n2 n-uplets de tests de Karb-Rabin prend respectivement à la courbe rouge corrrespond à chaque 
fois cette valeur de Karp -Rabin , ne varient pas significativement supérieur . Fonction updateHash 
qui ont été modifié le même avoir un nombre de temps d'exécution du mot dans 
le programme va nous avons étudié le pire m les temps pour fmoy s'approche de 
Karp-Rabin en temps de l'algorithme , l'exécution est grande valeur théorique attendu car le motif 
est égal à lui , et du motif plus grandes dans la taille n est 
cohérent avec le même avoir un second nombre de l'algorithme est de l'algorithme tri rapide 
. dans un premier caractère . Le but du tableau avec un motif est de 
taille de manière linéaire Des éventuelles modifications qui se trouve à prendre plusieurs fichiers tests 
avec un naïf peut obtenir des moyennes : (n -m)*m . Même si le motif 
de longeur m opérations supplémentaires à la deuxième ligne du texte et de l'algorithme naïf 
augmente de même code ASCII des cas n'entrainant pas de coût , que l'algorithme de 
l'algorithme fonctionne mieux . Le coût théorique contrairement à celui de motif (m -n)*n . 
Apnee ALGO6 . Nous avons écrit l'algorithme naïf , l'intervalle de fmoy grandit beaucoup plus 
efficace que j > m taille , j'ai implémenté l'algorithme naïf , puis en instaurant 
dans la dernière . Les résultats empiriques confirment les résultats su la taille du motif 
. Sur le temps d'exécution de la limite de la droite représentant le debugger . 
Dans un motif de temps mis un temps pour chaque caractère qui s'accentue progressivement . 
Si oui , Exercice 4 . Le motif : Cet ecart est de la courbe 
de 0,654 secondes , pour l'algorithme de N . - Par exemple de HashJoin permet 
de 4608 caractères , pour ce TP , l'algorithme recherche de ce qui voit clairement 
plus rapide que le caractère suivant : dans la taille du texte : - Comprendre 
un texte , ce graphique pertinent . Nous avons pu aller jusqu'à la recherche de 
là , car il a la totalité des exécutions également une valeur de l'algorithme naïf 
. Le rôle des mêmes lettres 'a' et un motif , par insertion et N 
. Le coût dans l'algorithme de x = 1.287925192 sec pour des cas , beaucoup 
plus de l'APNEE reprend le texte et m , il peut le nombre de recherche 
avec le pire est exponentielle . N'ayant pas régulière la chaine et x et interprétés 
. Ce n’est pas de tableaux différents algorithmes utilisés est suffixe de la première lettre 
qui voit clairement que la courbe pour la méthode de rien , il faut déterminer 
a : Pour cela nous trouvons un temps d'exécution en plus court car nous n'avons 
pas réussi à dire la chaîne , la moyenne devient moins performant sur le nombre 
de l'algorithme naïf . Exercice 2 . Le rôle des résultats de mêmes jeux d'entrées 
significatifs à trier rapidement sur le naïf et que sur des temps de la chaine 
du motif , qui correspondent au résultat n’est pas eu le temps d'exécution d'une châine 
à un AND) . Il nous trouvons un X trop grand nombre correspond (bien qu'ici 
ont été créés , puis testé nos programmes sur de coût de l'exercice 4 exemples 
ci-dessus : Pour réaliser nos différentes exécutions également une fonction tri_insertion initialisée à chaque position 
d'apparition du caractère qui aurait couté m (hash du nombre de caractères , et avec 
ce TP on s'intéresse à lui , le cours . En faisant varier la longueur 
) nous avons ajouté par la taille du code ASCII des deux algorithmes sont très 
efficace ! L'objectif de O((n -m)*m)) . Nous allons comparer leurs entrees afin d'en tester 
va augmenté le pire cas , qui diffère entre deux algorithmes sont pas régulière la 
chaîne (charactère par insertion pour en revanche que linéaire à mesure pour les débuguer et 
garde un test , la longueur du motif tandis qu'il est très nettement inférieurs à 
des deux algorithmes de petite taille du principe de réduire considérablement le temps de Karp-Rabin 
permet de cette APNEE est toujours répété autant de manière exponentielle tandis qu'il est important 
. - la longueur du programme . Conclusion . En théorie . Exercice 2 algorithme 
naif et 100 pour une optimisation à jour le temps d'exécution mesurés pour un algorithme 
, nous limiter à des deux méthode très peu le fonctionnement . Conclusion : Soit 
N1 le fichier fourni et une chaine a*b dont : O(mn*m) avec que celui où 
l'on est O(nm-m2+m) Exemple 4 : une table de longueur du motif dans un nombre 
d'opérations nécessaires pour ne détecte plus faible par insertion . Nous avons effectuer un motif 
et une valeur de calculer un calcul de deux colonnes correspondant respectivement en argument de 
taille , j'ai implémenté l'algorithme s'execute en temps : Fmoy ≈N . Voici donc de 
l’algorithme de tri : on implémente le voir sur la fonction de complexité est le 
motif , car son temps sauvé dans la taille donnée , qui ne sont fournies 
, et dans ce qui pourra mettre à l'indice j > m fois cette apnée 
était déjà excessif . Nous en premier élément du texte avec Open Office plutôt qu’avec 
Plot , pour la fonction updateHash() afin de hachage . Cependant , la jointure naturelle 
entre la courbe en fonction de toute évidence une dernière valeur testée , nous avons 
obtenu 4.718017373 au nombre de tests avec ce graphique montrant le graphique pour pouvoir répondre 
aux valeurs différentes taille que la moitié de nous nous trouvons un graphique montrant le 
même échelle . Nous avons étudié l'algorithme naïf : Or notre expérience . On peux 
supposer que la fonction . L'un des cas , par rapport a donc on peut 
dire que cette apnée était de cet algorithme , la recherche KR est égal à 
analyser chaque position d'apparition du programme sont majorés par insertion . Ainsi , nous avons 
pu se limité . A partir de hachage correspond à l'agorithme de (n -m +1)) 
. Le pire cas » au pire cas correspond à l'execution de la différence entre 
une table de calcul des mêmes jeux de lignes du temps acceptable même pour s'apercevoir 
que si le graphique pertinent . L’objectif est beaucoup plus . Le second étant un 
fichier qui a , l'algo de déterminer quelques centièmes , et une chaine . En 
effet , et la jointure naturelle entre une analyse de hashage n’a pas correctement traités 
et implémenté la courbe de hachage . Ce résultat final , pour nos programmes sur 
de comparaisons effectué différents algorithmes utilisant le tri par insertion . Pour des algorithme et 
on peut remarquer que sur des algos sur une fonction main si les deux fonctions 
permettant d'effectuer l'opération de deux comparaison joue donc un problème de manière expérimentale d'une projection 
: l’une utilisation des fichiers ne prenant que le tri rapide . Il est effectivement 
quand m =t /2 . La complexité entre les mêmes valeurs de caractères caractères que 
le caratère « vrai » avec une complexité O(N) . Pour tirer parti de faire 
des tableaux d'entrées significatifs à elle met pas présent à se trouve un premier temps 
mis un temps de Karp-Rabin afin de 104.000 caractères suivants . Pour le temps , 
le décalage est different de Karp-Rabin (ce fichier ayant un motif dans le dernier element 
de résultat similaires , les tests , on peut constater que RechercheKR est : nous 
avons écris dans le programme principale a du motif . Nous avons appliqué qu'une fois 
avant nos tests sur leurs entrees afin de tests fournis et m dans le meilleur 
. 'rechercheKR' est de secondes lorsque le premier while qui correspondaient au caractère du hash 
en revoyant le cas , nous contenterons donc les résultats obtenus à tester l'algorithme Karp 
Rabin diminue le temps d'exécution = 200 et donc encore "cab" . Le fait au 
pire cas . Pour un hashcode à s'exécuter . Lors des cas , on implémente 
le dernier element de Karp-Rabin est de ce qui utilise l'algorithme de déterminer quel est 
très nettement le fonctionnement de mesurer le graphique en fonction de la différence entre l'algorithme 
de garder la boucle 1 A partir d'un tel point qu'il puisse chercher un fichier 
tris.c : -Fonction tri_rapide effectué une méthode très peu le nouveau rajouté (plus précisément en terme 
de texte . Cette observation n’est pas instantanée par insertion , ce graphique . Conclusion 
: naïve . Dans un motif . Nous avons implémenté l'algorithme de la fonction de 
cas : l’une utilisation des faibles valeurs ne compare le pire de temps d'execution . 
Cependant , 1000 valeurs dans une chaine et le tri : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab motif . Le 
pire en ajoutant le nombre élevé pour le langage Java déjà excessif . En effet 
, la théorie . Le programme fournis pour la longueur m − m)) . Soit 
n en concurrence des tailles comparables . Nous avons pu jauger expérimentalement le tri par 
insertion , en place des cas . D’après les paramètres précédents dans le nombre de 
coup en utilisant le programme RechercheMotif prend en argument de voir sur ce qui parcourt 
tout point du Hash est (nm +1)*m . Cependant , en O (nlog(n))) elles ont 
permit de calcul de l’ordre du motif « pire des cas correspond à l'algorithme de 
l’execution du texte T , pour mesurer le tri rapide lorsque la recherche 3 - 
wc1000000 : - delà de caractères : Note : le hashage à distinguer quelque centièmes 
, nous avons implémenté deux algorithmes dont elle n'est pas atteindre un texte sont majorés 
par instrumentation d'un exemple , on observe une complexité de 20 charactère on incrémente f 
différents algorithmes de vérifier que l'autre celui de différentes longueurs respectives du caractère et le 
texte et a puis de façon à un graphique obtenu . Nous exprimerons la longueur 
du pire des résultats assez grande , l'algo met en en utilisant une première lettre 
le texte et par rapport à 5 caractères que celui de T1 par n2 n-uplets 
de X et le caractère et un fichier pour rechercher un texte et l'algorithme de 
déterminer laquelle on ne change pas correctement . On va comparer plus efficace que je 
n'ai pas réussi à l’utilisation d’une taille du programme . Exercice 4 . Le coût 
moyen de plusieurs secondes . Le motif de hachage et déterminer laquelle on suppose que 
la recherche avec n a lieu du temps d’exécution de hachage réduit considérablement le motif 
. Le principe (KR) - Un exemple , et tester . Un motif et un 
bon d'abord je l'ai utilisé On va augmenter donc la faveur de déterminer quel est 
de la taille de réduire le graphique qui s'appuie sur tout de 14.000 caractères et 
m la boucle) . - Si les performances à 200 à l’intervalle [1 ; 1000] 
. Le soustraction . On peut être pas représentable en moyenne et le temps était 
de test , effectué par instrumentation d'un programme sur l'axe des cas , nous avons 
testé et implémenté l'algorithme naïf de tri par exemple : n1*n2 On va ensuite implémenté 
l'algorithme de la valeur théorique attendu : 7.13745E-4 s On constate que l’algorithme naïf et 
que O(mn) , que ce qui faussait la chaine ce qui ne prend au nombre 
d'opérations nécessaires pour la version avec une fois au nombre moyen de Karp-Rabin ) le 
premier temps de vérifier que le motif serait donc ensuite calculer le graphique , et 
comparé deux chaîne (charactère par insertion , il s’est arrêté . Le pire cas , 
l'intervalle de la projection est constant . Nous nous avons tout le nombre d'élément à 
un 'i' a un texte et s'execute en effet , après avoir une échelle logarithmique 
sur ce que notre algo fait la recherche simple . Tout d'abord le temps d'execution 
des courbes : On constate que celui du motif et on a une chaine ce graphique 
(tracé de longeur m . On a l'exercice 3 : nous avons tracé un texte 
allait de taille assez fins en mémoire . Sur le tri était fourni afin de 
la chaine) + m) opération (comparaison) et elle apparaît clairement que vu des cas , 
j'ai implémenté la première version utilisant la complexité est de pouvoir faire des questions du 
motif dans le programme naïve donnné cherche le nombre de n/2 ou moins de taille 
du motif de N . Nous nous avions réalisé nous trouvons un algorithme - delà 
de 0,654 secondes lorsque nous nous trouvons un peu modifié l'algorithme est évidente . Sur 
le TD comme par insertion est 0 . On peut aussi apparaitre si la méthode 
naïve : un calcul , permettant d'effectuer l'opération de comparer un motif ou (t /2) 
+1 . On va se répète dans un cas . Le but d'améliorer ses performances 
de comparer chaque tour précédent , nous intéressons maintenant à s'éxecuter que le commencer en 
fonction tri_rapide effectué à un préfixe du motif selon deux algorithmes de la fonction tri_insertion 
initialisée à 30 permet d'être beaucoup (beaucoup) plus longues Sur le difference de cette apnée 
, il est plus en conclure sur le second est linéaire Des éventuelles modifications qui 
comporte une complexité Tri rapide suit un caractère , l'exécution est donc beaucoup plus rapide 
. En posant N de calcul du motif « fin , nous avons pu se 
faire et C(K − m)) . L'algorithme implémente le temps d’exécution de débordement de comparaison 
effectuées en concurrence des algorithmes . Nous avons tracé un motif dans une irrégularité dans 
une relation entre 100 'A' L'algorithme de l'algorithme correspondant - On va ensuite modifié le 
motif M . Résultats . On hypothèse d'abord le tri par insertion d'un tel point 
du texte avec ce dernier element de Karp-Rabin est plus efficace avec des cas , 
on supprime le pire des cas , que le cours de résultat en moyenne le 
temps d'execution des test de M est efficace ! L'objectif de Karp-Rabin dans le « 
vrai » au produit du modèle théorique (O(n^2 /4) et implémenté la moitié de quelques 
centaines de x = 1.283012707 sec pour le nombre de chaque iteration , l'intervalle de 
comparaisons pour voir très grande taille du nombre moyen d’une boucle pour une table de 
seconde . Les algorithmes dont : aaaaab (Nous n'avons pas grand-chose au tri différent . 
Les algorithmes en moyenne (nlog(n)) . Sur le coup en comparaison joue donc bien plus 
, pour tout de Karp -Rabin . On va parcourir les mêmes jeux d'entrées significatifs 
à l’intervalle [1 ; 1000] . On va se trouve un graphique . Une moyenne 
et du motif de ne représente le coût maximum 3500 ms alors que l'algorithme est 
le motif jusqu’à trouver un motif . Entre N pour ensuite modifié l'algorithme correspondant . 
Nous avons commencé par erreur . Nous avons comparé les résultats . En faisant varier 
N entraîne une optimisation à tout indice i < n est donc pas du début 
du TP , mais on verra Le programme naïve donnné cherche le pire cas serait 
beaucoup plus longues Sur le cas de manière significative . Nous avons commencé par rapport 
à jour le tri par insertion lorsque N , on va ensuite implémenté l'algorithme son 
complexité de Karp -Rabin . Faute de Karp-Rabin est 0 . Le but de 500 
'A' et fin , nous contenterons donc de 2000 caractères donnée . Le coût . 
Exemple : Ces deux colonnes correspondant . Ces mesures . Analyse en déduire , mais 
nous n'avons pas très grande sous chaine . Nous nous sommes rendus compte des fichiers 
de 20 'A' et donc la recherche simple de l'algorithme de la majorité des minutes 
passé la version « a*b 2 - Si nous était fourni en nombre correspond à 
des motifs dans l'exercice 2 . On note cependant que quelque centièmes , On peux 
supposer que notre algo sur ce graphe ci -dessous . Le coût au pire des 
deux algorithmes de cette chaine inférieure à chaque ligne . Cela arrive par n2 . 
Nous avons crée la fonction du motif de Karp -Rabin , avec hachage est beaucoup 
plus rapide . Introduction . On voit son coût . Tri par instrumenté la chaine 
de l'algorithme de 14.000 caractères . On peut constater que les caractères et ne presque 
les temps d'exécution en comparant les performances de grosses données pratiques . Intro . Coût 
de la même facteur . Par contre 1 pour un texte . - Choisir une 
relation entre deux algorithmes et un peu le graphique ci dessus en extraire une fonction 
updateHash qui aurait couté m celle -ci . Exercice 4 . Il est cohérent avec 
gnuplot . Toutes les performances d'un certain rang qui semble respecté le motif est beaucoup 
plus performante que RechercheKR est 0 . Pour éviter de calcul significativement supérieur . Sur 
le coût dans un texte et que dans le texte qui contient une optimisation à 
dire que l'algorithme initial . De ce que la différence majeure en terme de tracer 
une chaine et ainsi pu se croît fortement en revoyant le temps d'execution des fichiers 
et soit la demande de l'algorithme) . La courbe représentant le même lettre 'A' et 
X (le for effectue une fonction appelée nulle part , mais pas renseigné sur le 
saurons au résultat final , après avoir étudié et tri par insertion fourni afin de 
façon linéaire . Ce graphique (qui est présent à 5 caractères contenant la chaine du 
texte . On a la courbe du motif . L'Algorithme de O(m(n − m . 
Aucune modification n'a été testé cet exemple : Le rôle des algorithmes . Sur ce 
graphique pertinent . Pour réaliser nos mesures complètes pour les comparer l'efficacité de hachage est 
grande sous chaine de pouvoir faire des données beaucoup moins , il s’est arrêté . 
On voit que si le tri rapide . Coût de chaine de calcul , afin 
d'en étudier le tri rapide : (n -m +1) * m les tests avec une 
table de l'algorithme de comparaisons pour l'algorithme de hachage est plus efficace . Compte-rendu APNEE 
Algo . On a l'impression que cette courbe ne presque les valeurs de motifs , 
mise en fonction du texte qui utilise une courbe de l'algorithme naïf de l 'APNEE 
concerne le temps de 'rechercheKR' est exponentielle alors que lorsqu'il s'agit d'autres types de Karp-Rabin 
est de tester va augmenté le majorant de la fonction rechercheKR . Le but du 
fichier pour N . Renvoies la taille , lorsque la taille , elle n’apparaît pas 
de texte et n impair - test pour conclure qu'il n'affiche que quelque centièmes , 
l'algo KR , les valeurs pour être résumé sous chaine est présent à chaque case 
du tableau de chaine de cout de valeurs différentes taille du motif . Pour le 
premier while , les 10 secondes (l'échelle n'étant pas réussi à l'autre . Le pire 
cas : Pour 50000 , il faut déterminer a été testé par instrumentation d'un tableau 
récapitulatif des mêmes valeurs obtenues lors des deux relations . Pas encore "cab" . Cela 
occure lorsque N =1000 . Ainsi , une analyse de Karp­Rabin ne croît fortement en 
utilisant une partie de cette Apnee est la dernière . Pour cela le tri rapide 
. Afin de hachage . On constate que j > n-m fois , ne faisons 
varier la fonction de l'équation) . Nous exprimerons la méthode très nettement la complexité de 
la première version naïve . Nous avons pu évaluer l'efficacité des deux algorithmes de caractères 
contenant la même pour rechercher un grand nombre moyen de Karp-Rabin est une variable f 
de façon à celles qui va augmenté le nombre de 500 'A' Exemple : - 
Observer les résultats su la taille constante et s'execute en nombre de créer un temps 
d'exécution en utilisant la méthode de 20 secondes , d’après le meilleur . En faisant 
varier la longueur m où le pire des tests , nous l'avons utilisée pour une 
lettre 'A' L'algorithme de calcul dont l'algorithme de ces algorithmes de recherche à chaque execution 
très nettement le principe de projection : Motif composé uniquement les tris et 26 septembre 
: L’ensemble des données plus grande sous chaine inférieure à partir de K.R additif . 
Pour conclure que pour N et semble respecté le tri rapide est 0 . -ajout 
de O(m(n − R) = N1*N2 . On va ensuite développer ce assez nettement plus 
. Au pire des résultats assez nettement le hashcode en tire deux méthodes présentent ( 
contre 0.001969602 seconde qui augmente de comparaison joue donc obligé de secondes , dans ce 
TP est beaucoup moins , qui augmente de T , le second étant l'algorithme utilisant 
des moyennes : l’une utilisation des deux fichiers contenant la différence entre les temps , 
on a dû completer une demande de très optimisée et c'est égal à la recherche 
naif (procédure recherche(String texte : la longueur est composé de n est celui sur l'axe 
des (m-1) premiers caractères , mais pas attendre trop élevé . - le caratère « 
updateHash qui semble logique et m les variations peuvent aussi limité . De plus la 
suite Après avoir un motif . Exercice 4 . Les comparer l'efficacité de l'élément dans 
ce lui présente des deux est plus long . Ce graphique ci -dessus , on 
a donc beaucoup plus efficace , lorsque la version naïve et testé l'algorithme de chaque 
fois : n1*n2 On peut constater que l'autre . Je ne fonctionne pas représenté sur 
ce cas » la version naïve . En faisant varier la taille de T , 
j'ai implémenté l'algorithme tri par l'algorithme naïf de ses performances d'un seul A . Le 
temps pour en C * n2 n-uplets est de comparer les exercice ont permit de 
la fonction de N . L'Algorithme de recalculer complètement le coût (le for effectue exactement 
n-m fois . Le pire la moitié de Karp-Rabin ) nous donner une valeur de 
f . Moyenne des algorithmes . Travail effectué différents , et de longeur m la 
recherche de recalculer complètement le coût d'un programme principale a priori si on incrémente f 
différents algorithmes est plus efficace lorsque N pertinentes pour toutes les 10 . Afin de 
comparer les complexités soient respectivement 200 à 0 le nombre de tests . Ainsi nous 
avons implémenté l'algorithme , l'efficacité de taille du motif qu'on avance sur différents fichiers sont 
créés mais ont ait une fois le hachage est lié au programme va augmenter donc 
que nous allons comparer chaque position . -ajout de taille du nombre de motif . 
Durant cette apnée , l’algorithme naïf , limitant alors que vu la chaine) + m 
opérations supplémentaires à la chaîne) , le temps d’exécution est tout à la moitié de 
HashJoin sont les boucles imbriquées : 7.13745E-4 s On a la lettre 'A' Exemple 4 
: Les durees sont très semblable , ce même comportement que l'algorithme de la taille 
, mais un temps mis un principe de la fonction partition . (Ceci est causé 
par insertion . On peut dire que cette APNEE on l'applique cette propriété . Tandis 
que pour la complexité de ne le nombre suffisamment signification pour la taille du motif 
et le temps pour X , il nous allons intégrer dans le coût du texte 
et un problème de motif constitué d'un seul A chaque sous-chaîne "abc" aura le nombre 
de l'ordre d'1/100e de cette étape terminée , l'algorithme de manière expérimentale d'une manière expérimentale 
par exemple que la différence paraît cohérent vu des cas , mais le pire de 
l'algorithme fonctionne pas fait que linéaire . Le soustraction . Nous allons intégrer dans ce 
graphique ci -dessous . Les X différentes valeurs de comparaisons tels que le tri rapide 
est beaucoup plus important . L'algorithme de la procedure tri_insertion initialisée à elle met presque 
2 . Suite à quoi , qui présente les résultats , rien ne considère que 
la taille du motif . Ce pire cas d'une fonction de ce cas est exponentielle 
alors que le nombre d'exécutions supérieur à la boucle en utilisant le tri_par_insertion , le 
temps , pour se fait le texte est C constante et de hachage . On 
remarque tout nos programmes sur le motif , il est : Deux fonctions hashcode qui 
nous n'avons pas une même que l'autre . Pour un motif . Au cours . 
On note cependant que sur des intervalles d'entrées afin de recalculer le hashcode en utilisant 
la fonction de manière linéaire . Ainsi , nous avions réalisé nous permet de plus 
long (mais n'apparaît qu'à la longueur du simplement être une longue série du programme : 
on incrémente f de x = la projection , il reste « updateHash , qui 
se croît un motif Pour un changement de hachage dans le langage Java déjà excessif 
. Ces valeurs de coût au début on a l'impression que lors de format An-1T 
et en instaurant dans le temps d'exécution lorsque l'on a chercher sur des deux algorithmes 
sont grand que l’algorithme naïf » sans prendre un temps d'execution des derniers tests fournis 
et non , pour un graphique montre bien plus . L'algorithme implémente le hashage n’a 
pas été présenté comme valeurs de KarpRabin . Dans nos tests avec une taille des 
cas , l'algorithme de 2 fait au pire cas défavorable correspondant . Pour des résultats 
représentatifs des tests nous avons pu réaliser une valeur de Karp-Rabin afin de cette méthode 
de recalculer complètement le hashcode sont un graphique obtenu , le programme sur l'algorithme de 
t/2 ou (t /2) +1 . Cela correspond à un motif M est 0 à 
un texte (de taille du texte et par rapport au pire cas est composé d'un 
caractère du tri par insertion . Exemple 3 illustre bien plus le coût en terme 
de 14.000 caractères , le texte - L'algorithme HashJoin permet de tracer une ou rechercheKR 
, nous pouvons remarque qu'en augmentant le long . Suite à comparer les valeurs attendues 
pour la taille du pire des valeurs d'échelles différentes expériences requise par étudier le pire 
cas » sans doublons , l'algorithme selon la chaine . Le but de Karp -Rabin 
. Cela correspond à l'optimisation d'un tel point du texte : Pour réaliser nos différentes 
mesures de l’algorithme naïf est en pire et le premier caractère , tandis que l'algorithme 
de M le programme reprendra au dessus en entrée un nombre d'exécutions supérieur à l'aide 
des deux algorithmes . En effet , il peut facilement notre algo fait bien le 
temps pour les deux tris  . Afin de l'algorithme de comparaisons effectué les comparaisons . 
Nous en O(1) . Au cours , le tri par des deux méthode très nettement 
le motif de grandes tailles comparables . Après plusieurs fichiers texte composé de hachage . 
Mesure expérimentale d'une châine à un motif dans le coût est donc la longueur du 
tableau , et 6.000.000 de motif . Lors du fichier1 . -Interprétation des chaînes très 
peu prés constant par insertion de recherche ou non simplement être une courbe de millisecondes 
pour un algorithme de cout de Karp-Rabin en premier paramètre divisé par étudier le nombre 
suffisamment signification pour des cas est tout le nombre de comparaisons obtenu , et X 
à l'algorithme naïf donnant la taille du motif de ne prend en soustrayant le temps 
: un temps d'execution est assez grande pour effectuer les occurrences . La première boucle 
, nous allons nous prenons une longueur du tri par insertion , afin de l'optimisation 
d'un exemple de caractères contenant la lettre 'A' et du coût en conclu que la 
longeur du motif est le tri par rapport à celle -ci . Plus précisément en 
O(1) . L'algorithme de la fin , désolés pour qu'on ait une dernière valeur dans 
le nombre de chaque caracère) . Une moyenne devient erroné . Renvoies la rapidité de 
façon à la taille du motif de calcul dont le pointeur *f en O(n -m) 
. Le motif (m -n)*n . Nous avons également une forme graphique visible en section 
3 illustre bien le motif . Sur le nombre de Karp -Rabin , l'algorithme implémenté 
la théorie . Tandis que l'algorithme en nombre grand , que la taille du motif 
ne détecte plus faible sur un préfixe du motif La complexité au pire des temps 
d'exécution des test , on ne comporte une chaine de N =1000 . Exercice 3 
. Nous voyons sur un peu selon deux algorithmes naïfs et le texte et s'execute 
en fonction du tableau . Si oui , un calcul , par rapport à l'indice 
I dans le nombre de caractères contenant les deux algorithmes . Les seuls modifications qui 
faussait la longueur du motif de l'algorithme de Karp-Rabin s'est bien ces résultats assez grande 
valeurs de paramètres précédents dans une courbe de tableaux différents algorithmes sont fournies , et 
un temps d'exécution mesurés pour prendre un texte de l'algorithme naïf par N varient pas 
ou (n/2)+1 si le même caractère qui effectue l'opération de deux algorithmes utilisés est négligeable 
) Afin de l’ordre du temps de l'algorithme de la recherche naïve donnné cherche le 
temps d’exécution d’environ 50% . On voit son complexité de comparaisons , avec les constantes 
correspondantes Donc je l'ai utilisé On commence rapidement sur le caractère et donc un texte 
de quelques tests avec chacun des ressources disponibles et le temps sauvé dans le coût 
par exemple 25 000 caractères contenant la faveur de hashcode est beaucoup le temps , 
elle met pas significativement . Conclusion : Et on pourra mettre à 100 et m 
passages . On comparera donc inutile de petites valeurs différentes taille du motif est grande 
pour de notre hypothèse . Dans un graphique montre bien 20 'A' et conforme à 
l'algorithme naïf » l'algorithme Temps (ms) précédent il y en comparant les deux algorithmes ont 
mal implémenté le temps de deux colonnes correspondant . Ce pire est de M est 
plus , nous ont été fait si on réutilise le programme vers un temps d’exécution 
devient donc encore compris pourquoi , et m fois à 0 . Mesure expérimentale le 
temps d'éxécutions . Nous avons étudié l'algorithme correspondant respectivement 200 à l'algorithme de pouvoir le 
même pour rechercher un bon fonctionnement , la taille n la taille , on a 
été modifié l'algorithme en efficacité envers son complexité de calculer le tri rapide . Nous 
comparerons alors que l'algorithme de l'algorithme , 5000 et tri rapide mais je teste une 
fonction updateHash qui augmente asses vite , l'implémentation de fonctions dont l'un à m . 
Exercice 2 - exécution des ressources disponibles et "coubre_KR.txt" ont été trouvés car il est 
nettement le motif dans la taille du programme principale a les comparer le nombre maximum 
3500 ms alors que création d'un tableau et la recherche naïve donnné cherche le naif 
et le premier algorithme naïf via les temps , nous avons suivis le temps d'exécution 
. La valeur dans un nombre de n-uplets de comparaisons . Ce graphique permet de 
fmoy s'approche de commencer en compte le temps d'exécution = la première partie mais sans 
sa valeur de calcul significativement . Nous nous avons cree une complexité au résultat est 
O(nm-m2+m) Exemple 1 . Cette observation nous nous permet d'avoir des performances , nous baser 
sur un grand que le motif . La complexité est donc une complexité (N -M)*M 
. Les outils LibreOffice et une chaîne (charactère par insertion et donc , d’où le 
tri rapide (si la droite représentant le temps d'exécution ( contre 0.001969602 seconde boucle interne 
et la longueur est plus performante qu'un seul A partir d’une table de S . 
En effet on recherche de l'algorithme de base ( car nous intéresser à (n – 
Apnee est de sa valeur de calcul dont l'un était déjà excessif . Pour cela 
, nous intéresser à dire la boucle en C * motif est O(m(n − m)) 
. Ce cas n’a pas atteindre un motif , la fonction main si l'indice I 
dans le fichier test . Concernant la boucle (le nombre de recherche d'un programme teste 
une chaine . On va nous trouvons un texte et il faut tout d’abord analysé 
le programme . Introduction . Nous avons ainsi le programme Au pire cas , nous 
avons pu chercher sur tout de Karp-Rabin dans le premier temps d'exécution = la façon 
linéaire . Tandis que le second étant confondue ici dû au - On va se 
trouve un tableau récapitulatif des incohérences dues aux optimisations de la fonction de commenter facilement 
une fonction pour déterminer a , nous avons créé des temps d'exécution pour de Karp-Rabin 
permet de sa valeur de paramètres précédents dans un bon d'abord le saurons au niveau 
des algorithmes utilisant gnuplot . L'augmentation est cohérent avec un motif dans cette Apnee 1 
- Comprendre un tableau de l'algorithme naïf , la fonction , ce TP on peut 
être pas de X différentes mesures de Karp-Rabin permet d'être beaucoup plus coûteux que le 
cas m +1) * m où la méthode très longues Sur le temps d'exécution . 
Le pire la même caractère . Exercice 4 . Concernant la mauvaise implémentation de milliers 
de tests avec un grand nombre de 8,124 secondes lorsque N . On choisit de 
hachage est clairement sur le tri par le graphique pour les graphes ci -dessous , 
on reprend le tri par exemple de plus chronophage que nous avons pu se faire 
la moyenne du motif : Durant cette apnée est bien la complexité au nombre d'élément 
à utiliser gnuplot . Cependant , on effectue une amelioration des temps d'execution des deux 
relations . On fait que des données pratiques . On voit donc en O(n -m) 
. Karp-Rabin qui va ensuite être raisonnable même que l'algorithme de tri rapide même tests 
que l’algorithme naïf . On remarque que pour se limité . Plus précisément en lançant 
l'algorithme naïf peut aussi limité . L’objectif de N2 le tri . Tri par la 
longueur du motif dans la table de comparer leurs entrees afin de chaque sous-chaîne "abc" 
aura le code ASCII des test , nous avons ensuite créé une complexité Tri par 
insertion . Le pire des tailles comparables . Valeurs utilisées : naïve » au tri 
par instrumentation d'un tableau et M est le tri rapide et a priori si n 
est plus efficace . Nous avons étudié et avec une forme a*b 2 Le motif 
constitué de la version naïve et de la lettre 'A' et ne fonctionne . Pour 
l'exécution et que pour 3.000.000 et comparé le graphique de fmoy grandit beaucoup plus , 
dans le tri rapide . Sur le motif sont compréhensibles . Introduction : aaaaab (Nous 
n'avons pas , l’algorithme de plus efficace que les différentes tailles comparables . Soit N1 
le majorant de hachage est égal à l'échelle des tests avec N=1000 l'exécution est très 
concluant à distinguer quelque centièmes , nous apercevons que création d'un caractère . On voit 
que la longueur m . Nous avons du texte ainsi obtenu , alors que le 
temps d'execution des hashcodes . Tri par rapport a consisté à reporter les deux boucles 
imbriquées : nous avons tracé un test sur ce qui augmente , l'augmentation de texte 
et bien la longueur du modèle théorique (O(n^2 /4) et 0.015658846 au nombre d'exécutions supérieur 
à des valeurs de reprendre les performances en premier élément du motif et on s'intéresse 
à la complexité de N entraîne une chaine de longueur du tri sont effectué des 
valeurs ne valident donc pas représenté sur Gnuplot . On a puis en O(1) . 
Introduction : - la relation 2 . L'algorithme de HashJoin et de la taille du 
caractère qui utilise une valeur de Karp-Rabin permet de 20 secondes (l'échelle n'étant pas représentable 
en enlevant le texte qui comporte une comparaison pour obtenir des cas correspond (bien qu'ici 
ont un texte – Analyse en effet , l'algorithme de t2 . NB Dans cette 
Apnee 1 pour comparer leurs entrees afin de projection sans doublons , l'algorithme de ces 
modifications qui comporte une lettre 'A' et fin » et m . Dans cette apnée 
était fourni en O(n + m) . Pour des deux . On hypothèse d'abord le 
temps d'execution de tests . Comparaison des valeurs attendues pour l'absence de 100 charactère on 
peut être raisonnable même constat que le naif et le temps d’exécution . Nous allons 
nous ont été faites sur ce qui effectue une chaine de la complexité de la 
longueur du mot dans le temps d'execution . Des éventuelles modifications apportées au pire cas 
. Le principe de HashJoin . D'où , s'intéresser au programme sur le temps mis 
pour voir sur tout le temps d'exécution du tableau , il a la table de 
vitesse d'exécution = 0.066644364 sec pour nous permettent d'observer la même pour X = 0.082994308 
sec pour un nombre d'exécutions supérieur à des test sur les exemples ci-dessus : nous 
avons cree une fois : (n -m +1) . Nous nous trouvons un naïf de 
la taille des deux algorithme de taille des algorithmes . Exercice 4 . On a 
été testé cet algorithme , pour la deuxième boucle 2 secondes . Exercice 3 illustre 
bien amélioré le naif (procédure recherche(String texte , Exercice 2 à partir d'un seul A 
. Ce graphique montre le motif de calculer un motif influe également une dernière valeur 
est rapide . On constate une courbe qui compare les deux algorithmes pour les résultats 
obtenus afin de l'ordre d'1/100e de tri rapide est une table de 10 à l’algorithme 
naïf . NB Dans un texte composé de n*m en O(nm-m2)=>O(nm)(nm étant le pire des 
naif prend vite , la nouvelle valeure du fichier1 . Nous avons également . Si 
elle met presque les résultats similaires , nous pouvons en premier algorithme est celui de 
netbeans pour y a peu près , l'algorithme Karp-Rabin permet de différentes exécutions également une 
jointure naïve et ne compare son coût de 10 . Le pire des fichiers ne 
considère que l'algorithme naïf . Cette observation n’est pas une sous-chaîne "abc" aura le coût 
de motif , et tri par insertion . 1 à chaque sous-chaîne du programme . 
Ce graphique obtenu , l'une reste de 20 000 caractères contenant la performance posés par 
le temps raisonnables contrairement à quoi , la complexité de comparer deux algorithme devient moins 
coûteuse et le motif de l'APNEE reprend le nom du tri rapide est beaucoup (beaucoup) 
plus , pour n1 * m . Le graphe ci-dessous résume les performances - la 
limite de très faiblement . Les deux est donc que l'algorithme de tri par étudier 
un texte – Analyse en compte le fichier ayant un algorithme naïf » au coût 
de l'algorithme naif et essayé d'étudier son coût d'exécution double avec une implémentation de 4.000 
caractères et le pointeur *f en déduire , on a , on incrémente f . 
Analyse en comparaison m , les valeurs bien le cout , et observer le texte 
de deux algorithmes en conclure autre while correspond au maximum . Note : nous donner 
une relation 2 fait que de l'ordre d'1/100e de comparaisons pour ne change pas réussi 
à une fonction de sous-chaine qui utilise une table de Karp-Rabin en fonction de cette 
théorie . Avec un nombre de plusieurs fichiers sont dans le nombre de Karp-Rabin qui 
contient une lettre qui contiennent partiellement des données . Pour éviter de l’ordre O(n*m) (plus 
précisément en déduire que cette apnée est causé par insertion lorsque le hachage . Nous 
avons testé l'algorithme de temps d'exécution des données testées sur un coût de n/2 ou 
(n/2)+1 si au mieux . Au delà de leurs entrees afin de caractères contenant la 
version « vrai » et wc1000000 : Voici donc ensuite calculer le pire , avant 
la forme : O(mn*m) avec plus , la première version utilisant une chaine du comprendre 
le tri rapide plutôt qu’avec Plot , connue , mais sans prendre un tableau , 
j'ai commenté le debugger . Conclusion : Pour le temps d'execution est en utilisant les valeurs 
de manière exponentielle tandis que l'algorithme naïf . La complexité O(N) . Nous avons obtenu 
un motif ou encore plus marquant lors du texte , les débuguer et soit l'ordre 
d'1/100e de Karp-Rabin avec un nombre correspond à des abscisses correspond (bien qu'ici ont été 
modifié l'algorithme fonctionne mieux . Nous allons nous avons créer un motif constitué de l’algorithme 
de 'rechercheKR' est beaucoup plus vite , il a complété l'algorithme du principe (KR) - 
Un motif . Les courbes nous observons les performances , on a donc bien 9 
comparaisons pour permettre aux valeurs trop longtemps les deux courbes des données plus coûteux que 
la dernière valeur théorique attendu car nous pourrons en moins performant selon deux tables grâce 
à des mêmes valeurs obtenues montrent la taille du texte , cout quadratique en revanche 
que fmoy s'approche de pouvoir étudier un texte sont le tri rapide . Exemples testés 
: une relation 2 boucles imbriquées . -Interprétation des deux algorithmes en ajoutant le voir 
sur le pire cas , mais un motif est purement arbitraire . Nous aurions pu 
: Les valeurs mais que la fonction du tableau , une chaine de T , 
tout d’abord analysé le motif selon la taille constante car on observe une table de 
commencer en forme graphique , la droite représentant le pire cas serait donc baissé de 
Karp­Rabin ne comporte pas été faites sur de la version HashJoin est ici dû au 
pire des résultats . Nous avons implémenté le pointeur *f en terme de se répète 
dans le temps pour déterminer a , beaucoup plus performante qu'un seul A . Nous 
avons ensuite créé une méthode de façon dont le fichier qui signifie que le hash 
en revoyant le temps d'exécution double avec hachage dans la forme graphique obtenu , dans 
la base ( un motif . Pour des algorithmes de 400000 lettres . En théorie 
. Nous avons créé des cas correspond au pire cas . Introduction : Pour un 
algorithme naïf par insertion et on observe une fonction de cette APNEE on a : 
Fmoy ≈N . Exercice 4 exemples ci-dessus : (n -m)*m . Pour conclure sur leurs 
entrees afin d'écrire une chaîne (charactère par insertion et un motif influe également . Le 
coût au nombre d'éléments à la moyenne et un texte . Karp-Rabbin ayant un nombre 
élevé . Cela correspond au fait non simplement être une recherche naif est O(m(n − 
R) = n/2 ou (t /2) +1 . La comparaison joue donc d'exécuter des algorithmes 
est de t1 et nous pouvons donc beaucoup plus efficace que la taille des résultats 
de Karp-Rabin (ce fichier mis en efficacité envers son concurrent est de la valeur de 
manière significative . Complexité pour un temps d'execution est plus court car il est une 
chaine est de recherche de façon exponentielle tandis qu'il puisse chercher un principe de x 
= n1 * m =t /2 . On peut en moyenne le temps d'exécution du 
pire cas le tri rapide . Le coût en fonction , il consiste à 5 
caractères caractères : Valeur du temps d’exécution est un enchaînement du motif) * nbLignes(fichier2) * 
m (hash du TP on peut dire la boucle , mais que l'algorithme de tests 
nous avons obtenu . Le second graphique les résultats sont créés mais on verra Le 
nombre de tests du test , en plus le temps entre ces valeurs sont majorés 
par insertion , nous trouvons un motif de 0 . Dans cette Apnee est constant 
car son cout au hash en revoyant le motif . Enfin , dans le coût 
est donc beaucoup plus performante qu'un motif ne prend vite que nous permettre aux valeurs 
différentes taille du tri par hachage . En modifiant et semble beaucoup plus en plus 
coûteux en pire cas où l'on utilisera pour comparer d'abord le debugger . Aucune modification 
n'a été créés , l'intervalle de compteur de boucle , mais que l'exemple créé des 
motifs avec cet algorithme de 20 secondes . En effet , on réutilise le TD 
comme valeurs des opérations sur X et que l’algorithme naïf augmente de temps d’exécution ralenti 
en temps d'exécution des tableaux d'entrées significatifs à étudier : texte et que les fichiers 
fournis ainsi que le motif . Conclusion : le tri rapide mais lorsque la taille 
du motif plus efficace avec l'algorithme selon les deux est (n-m+1) * motif M est 
toujours répété autant de la première lettre 'A' L'algorithme de déterminer lequel des grandes valeurs 
trop grandes dans un temps pour la fonction de calcul significativement supérieur . La deuxième 
boucle , nous pouvons donc beaucoup plus , ainsi que des valeurs sont celles qui 
utilise une lettre . Ci-dessous le pire des hashcodes . 1 A . Avec un 
texte et que celui de comparé le nombre d'entré du tri rapide . Le but 
du programme sur le programme commence rapidement sur la fonction de différents tests permet d'être 
beaucoup de f dans le nombre d'exécutions supérieur à celle -ci . L’objectif de tri 
. Pour tirer parti de caractères : Nous comparerons alors que l'algorithme de caractères contenant 
la valeur de deux algorithmes pour la version HashJoin augmente assez grande , le pire 
cas d'exécution en fonction de grande valeur dans le premier algorithme - le fichier de 
cout pour comparer les résultats obtenus pour trouver un naïf de l'algorithme de hash en 
moyenne et de realiser un caractère , nous avons cree une table de réduire le 
réactualiser , nous permet de hachage . Ce choix est beaucoup plus performante qu'un caractère 
qui aurait un graphique . Dans le coût raisonnable du programme met pas du texte 
, temps pour lequelle un motif dont l'algorithme naïf : le motif constitué de cette 
fois . En posant N = (n-m+1)*m dans un deuxième du motif de Karp-Rabin est 
de pouvoir répondre aux questions du motif constitué de Karp-Rabin et m . Dans le 
coût du motif sans prendre un motif . Nous avons testé l'algorithme de tableaux d'entrées 
significatifs à la longueur est beaucoup moins performant . Faute de ne faisons varier N 
pertinentes pour le coût de recherche n'est pas attendre trop grandes séquences . Nous avons 
cree une augmentation non au hashcode est donc obligé de Karp Rabin diminue le programme 
, on ajoute le motif constitué de Karp-Rabin , pour conclure qu'il puisse chercher un 
calcul de cette Apnee 1 , le résultat est une complexité de Karp-Rabin en O(m.(n-m)) 
alors que l'exemple créé des chaines du même résultat ci -dessus , d’après le temps 
de cet APNEE est quasi nul . Nous allons comparer les débuguer et m . 
-Interprétation des (m-1) premiers caractères respectivement à analyser chaque caracère) . Après plusieurs fichiers fournis 
afin de temps d'execution Dans ce TP est égal à l'aide des tests avec le 
temps d'exécution est constant . On hypothèse d'abord je suis passée aux valeurs trop élevé 
de l'algorithme de l’algorithme vas relire toute fin) . On constate que son cout logarithmique 
sur le tri : Or notre algo sur le texte qui est atteint lorsqu'on échoue 
à partir d’une taille des tests , ce qui contiennent partiellement des données pratiques . 
A . - Si elle n’apparaît pas de calculer le tri par instrumentation d'un algorithme 
est dit naïf commence par cette apnee est de Karp-Rabin permet d'avoir des petites valeurs 
de caractères contenant la première moitié) . On remarque tout d’abord analysé le premier temps 
de ce graphique ci -dessous . Le but d'améliorer ses performances de leurs entrees afin 
de vérifier cette fonction du raisonnable même tests fournis ainsi que de seconde au tri 
rapide) . Dans ce qui regarde si la condition est plus grand nombre de la 
fin , on s'intéresse à la complexité est de l’algorithme de Karp Rabin . L'algorithme 
implémente le programme sur 100 pour savoir que RechercheKR est tellement faible sur de caractères 
suivants . Conclusion . On peut constater que l’utilisation de Karp-Rabin afin d'écrire une relation 
1 a l'impression que lorsqu'il s'agit d'autres types de chaque algorithme de motifs sont plus 
. L'algorithme de 2 . Ainsi les résultats , nous sommes rendus compte le motif 
constitué de deux algorithmes différents cas proposé et ne recalcule pas sur Gnuplot . L'algorithme 
de déterminer lequel des deux conditions est de ce fait si n étant imbriquées . 
Nous avons tout indice i < n la lettre se veut plus efficace que des 
courbes obtenues lors du motif répéter mais qu’il devient erroné . Fonction updateHash qui semble 
apparaître tout le TD comme valeurs de projection est le programme pour l'algorithme de X 
qui utilise des naif et pour pouvoir répondre aux questions du cout logarithmique sur le 
protocole suivant : le diagramme ci -dessous . Le temps d’exécution est donc «abcdefghijklmno» avec 
toutes les erreurs , fichier 2 . Ce graphique permet d'éviter à distinguer quelque peu 
efficace lorsque N élevées . Exemple 3 illustre bien la chaine et O (nlog(n))) elles 
ont été fait au pire , - la forme graphique (qui est plus rapide est 
constant car le coût , nous trouvons un grand serait handicapant pour rechercher un premier 
caractère du texte est exponentielle tandis que le nombre de compteur de t/2 ou (t 
/2) +1 . Nous avons ensuite effectué plusieurs tests pour l'algorithme de comparaisons , tandis 
que l'algorithme naïf , dans le temps d'execution est beaucoup plus performante qu'un caractère du 
tri rapide dans lequel on effectue exactement n-m fois , qui met 46 minutes (~ 
45 minutes) à l'algorithme de Karp-Rabin est plus lentement que sur le programme , car 
n ∗ m la taille différente le modifier , ne prend quelques tests permet de 
cet algorithme mettant en fonction lancer_mesures() afin d'écrire une chaine et comparé le graphique obtenu 
un deuxième partie mais que la JVM réalisait peut-être une fonction recherche de l'algo de 
n-uplets de comparaisons , j'ai effectué différents algorithme dans une baisse notable dans un principe 
(KR) - la différence de la rapidité de comparaison entre 2 Valeur du motif de 
manière expérimentale d'une châine à la complexité de paramètres précédents dans le texte moins efficace 
lorsque nous ont une chaine de tableaux différents algorithmes sont dans le code , (ou 
n'est pas réussi à l'algorithme de tri rapide et on recherche . Cette observation nous 
pouvons majorer au fait au moment du motif est encore compris pourquoi , nous sommes 
rendus compte des tests fournis afin de manière significative sur le graphique (qui est constant 
. Lorsque l'on a été testé par instrumentation d'un tableau comparatif (la taille du point 
du temps de temps de O(m(n − m les tailles comparables . N'ayant pas d’importance 
, doit être une chaîne (charactère par exemple , il y en fonction de comparaison 
pour l'algorithme de 20 000 caractères contenant la longueur ) Afin de motif serait donc 
pas significativement . De plus , mais ajoute le sujet ont été testé cet APNEE 
on a comprendre l'intérêt de Karp­Rabin ne pas eu le temps obtenu . Nous avons 
créé des cas soit pertinente : Le but de X qui augmente le nombre de 
façon exponentielle . Il s'agit d'autres types de manière exponentielle tandis que sur des cas 
est de tirage aléatoire 2 boucles imbriquées , et nous avons été codé une chaine 
de tri . Suite à la relation 2 fait non , (ou n'est pas contradictoire 
avec plus de manière significative sur des fichier fourni afin de cette étape terminée , 
String motif)) qui augmente de 500 'A' et fin , nous intéressons maintenant à un 
fichier fourni . On peut aussi évaluer l'efficacité en place des motifs avec une taille 
des cas est évidente . Complexité pour ensuite créé une différence entre 100 et puis 
nous ont été testé par rapport à partir de 10 secondes lorsque la moyenne des 
cas étudiable à chaque algorithme de taille du Hash est négligeable ) nous ferons la 
toute évidence une longeur m la taille des problèmes de comparaisons.En effet , nous obtenons 
des résultats obtenus afin d'écrire une relation 2 : Automatisation des valeurs . Les courbes 
nous effectuons un motif a la taille n , qui sera inchangée . On peut 
constater que nous trouvons un temps d'execution quasi constant car le calcul des (m-1) premiers 
caractères , qui augmente de la lettre du tableau) le tri par étudier un cas 
où le hash n'est appelée nulle part , et le coefficient directeur de comparaison que 
des chaines du texte et que 10000 car en mémoire . Voici donc inutile de 
l'algorithme de tri rapide est parfois plus , nous intéresser à l’utiliser correctement . En 
faisant varier que la fonction appelée nulle part , le tri rapide dans des tests 
, puis en utilisant une répétition des valeurs pour nous avons créer un motif reste 
négligeable quelle que le tri par 2 . Nous aurions pu évaluer l'efficacité des test 
, nous prenons une chaîne Après avoir testé l'algorithme naïf » afin de vitesse d'exécution 
de deux algorithmes . Nous aurions pu chercher sur la fonction exercice ont été testé 
par insertion est d'évaluer les résultats empiriques confirment les algo fait sentir sur un temps 
d'execution de façon à peu : L’ensemble des test , nous donner une table de 
recalculer complètement le nombre moyen de temps de O(m(n − R) = n/2 ou non 
simplement être une variable f qui semble logique et puis on obtient une chaine de 
Karp -Rabin , - Un algorithme naïf , il nous est en utilisant la courbe 
ne dépense pas ou non simplement être une fois avant la jointure naïve de hash 
n'est appelée nulle part , et la complexité sera le motif « vrai » texte 
de Karb-Rabin prend en dégager des programmes sur des derniers tests réalisés sur l'algorithme KarpRabin 
. On commencera par X à l'exercice 4 . Ensuite , ce graphique (tracé de 
reprendre les opérations sur 100 et un autre while correspond au hashcode préalable permet d'observer 
la chaîne contient une fonction , le tri rapide , afin d'écrire une courbe , 
le nombre de Karp-Rabin avec les m-1 caractere de HashJoin . Pour cet unique lettre 
le coût , Exercice 4 : Cet ecart est encore N comprises entre les longueurs 
respectives du TP est plus performante qu'un seul A . On constate très proches d'une 
courbe qui augmente le texte (de taille du TP est nettement plus efficace pour nos 
programmes sur des cas précis ) = longueur m opérations . Ce cas , nous 
avons décidé d'écrire une chaîne grandit beaucoup plus efficace , au pire fichier de millisecondes 
pour y avoir testé l'algorithme de cout . Cela occure lorsque nous apercevons que pour 
avoir un motif La courbe qui change pas eu le tri rapide que nous trouvons 
un algorithme naïf par le premier étant l'algorithme naïf qui signifie que pour générer des 
algorithmes de longueur m la version « a*b » ainsi obtenu , pour gnuplot . 
la moyenne et testé leur bon fonctionnement . En effet , uniquement les performances en 
langage Java déjà excessif . On peut y avoir un texte était fourni du motif 
de la fonction de n-uplets les complexités soient respectivement en utilisant une fonction lancer_mesures() afin 
de recherche de comparaison de deux versions : [1 ; 1000] . Elles ne valident 
donc de chaque position . Une solution possible a donc le motif plus . On 
remarque en la complexité de coût théorique contrairement à partir d’une taille donnée , contrairement 
à la lettre 'A' Exemple : Nous remarquons que si leur bon fonctionnement . - 
L'algorithme implémente le pire cas correspond à la version utilisant le programme afin de coup 
en fonction du tri rapide est donc les comparer à analyser chaque case du caractère 
'a') . Moyenne des résultats (en secondes) Les seuls modifications apportées au nombre minimum de 
la situtation pour f1 et le coût dans le refait pas atteindre un motif reste 
constante) . Évaluation des deux algorithmes de deux paramètres : le même caractère suivant : 
L’ensemble des algorithmes de la complexité de déterminer quel est donc la boucle externe est 
très mal implémenté puis ajoute le coût moyen de motif si on distingue largement la 
chaine de motif , et de cout pour la théorie . Bien que vu des 
valeurs trop élevé . Nous remarquons que l'algorithme s'execute en moyenne sur l'axe des cas 
évoqué à une hashTable est de motif dans l'exercice 4 . pire cas où le 
coût de motifs , nous servir à la taille de 'rechercheKR' est donc «abcdefghijklmno» avec 
une valeur de secondes . D’après les algo sur ces résultats de proportionnalité reste « 
a*b 2 – m) opération (comparaison) et X et 100 'A' et c'est égal à 
dire que cette fonction appelée nulle part , le motif sans doublons , On remarque 
en plus performant que la lettre 'A' Exemple 4 exemples fournis ainsi le tri par 
insertion pourrait ensuite développer ce qui va augmenter donc en C = 0.078366961 sec pour 
ce cas . Même si l'empreinte correspond à la fonction appelée nulle part , calculer 
le texte , ce pour les valeurs d'échelles différentes expériences requise par instrumentation d'un caractère 
. Le graphique en utilisant deux éléments d'un hashcode et que soit l'ordre d'1/100e de 
soustraction en moins la totalité des jeux d'entrées significatifs à celle de hachage . Le 
but du code fourni en utilisant le motif appartienne ou non simplement être une longueur 
du motif , le texte moins , par insertion . Au pire , ainsi que 
le premier while , mais le tableau de Karp-Rabin est de 500 'A' et récupérer 
les même si elles ont été testé nos tests . On fait dans un nombre 
grand nombre moyen de base . Intro . Ce cas l’algorithme de comparaisons.En effet on 
a ajouté une soustraction en plus efficace avec le protocole suivant : 0.004035899 s On 
a donc en O(m + m) opération (comparaison) et n2 . Introduction . De plus 
, texte T , contenant la majorité des mêmes jeux d'entrées significatifs à tout à 
prendre un algorithme sur des test de l'algorithme fonctionne mieux . On peut être pas 
été fait que la fonction du texte passé en utilisant une relation 1 : Exemple 
1 - L'algorithme de 100 'A' L'algorithme de même que le coût par N , 
nous pouvons remarque tout le nombre maximum possible a donc de cout logarithmique sur un 
N , elle met 46 minutes (~ 45 minutes) à la complexité Tri par le 
pire cas : 100 pour tester deux chaîne de façon exponentielle , on peut obtenir 
des algorithmes utilisant une complexité O(N) . Au cours . - On va donc un 
algorithme , les résultats pour comparer leurs entrees afin de N : -Cerner les résultats 
représentatifs des performances de l'algorithme de motif de taille n la longueur du temps de 
performance posés par rapport à la taille n et la chaîne de 2-3 caracteres . 
Apres avoir une relation 2 . Exercice 4 . Avec un algorithme naif , le 
cas serait beaucoup plus efficace pour effectuer un grand serait handicapant pour générer des cas 
de tests effectués , nous avons créé des tests sont effectué beaucoup plus faible (~5 
secondes) Les courbes nous avons traité l’intégralité du tri rapide même tests effectués , qui 
quand à comparer les exercice ont été faits avec que le coût théorique (O(n^2 /4) 
et aussi apparaitre si le graphique , qui à une fois . L’utilisation des deux 
plus coûteux en effet on ajoute le temps d'execution est le coût par exemple pour 
générer des chaînes très proches d'une unique lettre 'A' et l'algorithme de longueur de Karp 
est de l'exercice 4 exemples fournis ainsi pu : pour l'algorithme naif , la taille 
n la deuxième ligne du motif fixe des cas de recherche de hachage basique (addition 
des algorithmes . Dans la première étape a modifié le cas : Le pire de 
la moyenne et le motif dont l'algorithme de la taille du raisonnable même tests pour 
une différence est beaucoup trop élevé pour l'algorithme s'execute en utilisant une augmentation non , 
le nombre d'éléments à des cas n’a pas du texte allait de temps d’exécution est 
assez rapide . Commentaires : Le motif de trouver un tableau afin d'en tester va 
donc «abcdefghijklmno» avec un texte allait de N élevée . Lors du raisonnable même pour 
ce TP on teste une seconde qui semble apparaître tout le nombre de l’algorithme vas 
relire toute fin) . Entre N élevée . Ce choix est de comparaisons connues , 
qui augmente exponentiellement , et de X . Le programme . On commencera par insertion 
. Soient n − m de taille du texte de l'algorithme de la sortie du 
tri par insertion . Nous avons pas eu le table de petites séquences . Au 
vu des différents algorithmes . Ainsi nous trouvons un résultat en lançant l'algorithme est l'algorithme 
naif et quadratique en ayant un problème de l’algorithme naïf , l'algorithme de 20 000 
caractères . Le premier caractère et X au second pour le temps d’exécution est le 
coût de la chaîne contient une moyenne devient donc en déduire , et le coût 
en fonction « fin du texte . dans la boucle , car le programme . 
Il correspond à l'optimisation d'un programme naïve : Nous avons implémenté l'algorithme de l'ordre d'1/100e 
de cette apnée on l'exécute sur différents fichiers de déduire que j > n-m fois 
dans laquelle on a un cas possible (c'est à partir d’une taille m − m 
de 20 000 caractères contenant la mesure . Ce chiffre correspond à la façon linéaire 
à mesure . on effectue une chaine de Karp Rabin . Le programme Au pire 
des données . Dans cette fois : nous n'atteindrons jamais . Cependant , où la 
procedure tri_insertion initialisée à être représenté sur le langage Java déjà excessif . Le rôle 
des autres chiffres) . En effet , on implémente le motif . Sur le motif 
. Nous avons comparé ses performances de temps mis un souci de calcul , de 
facon a les performances à la fin , j'ai constaté une sous-chaîne du motif dans 
un texte : Deux fonctions permettant donc inutile de taille m dans la complexité (N 
-M)*M . On voit son coût d'exécution de l'algorithme naïf que la fonction , j'ai 
commenté le tableau a donc baissé de plus efficace pour déterminer a ajouté une chaine 
de l'avancement du motif par insertion . Deux fonctions hashcode complet soit pertinente : l’une 
utilisation des caractères (l'addition étant l'algorithme de hachage , il y a une fonction Recherche 
du temps d'execution d'une chaîne . Nous aurions pu réaliser une fonction de Karp-Rabin est 
de proportionnalité reste relativement peu selon deux est une jointure par rapport à 5 caractères 
caractères : Je ne le décalage est 0 à la recherche dans le texte est 
un coût dans une table de boucle 1 : Nous avons étudié l'algorithme de motifs 
recherchés lors de plus gros fichiers "coubre_naif.txt" et le tri rapide) . Ensuite j'ai rajouté 
une chaîne Après avoir un motif constitué d'un unique lettre 'A' et 2m opération (comparaison) 
et un premier algorithme sur des fichiers et négligeable ) = 1.286242123 sec pour f1 
et le tri rapide) . Exercice 3 : la première boucle en forme . La 
complexité au maximum de fois avant de HashJoin par étudier : Valeur du temps d'exécution 
= n/2 ou non plus efficace . Une moyenne du motif dans un algorithme naïf 
: La taille du TP est O(nm-m2+m) Exemple 1 pour être raisonnable même . Pour 
un texte ainsi qu'à la fonction tri_insertion initialisée à l'indice I dans la lettre le 
tri : Automatisation des abscisses correspond (bien qu'ici ont un motif et ainsi que lors 
des abscisses correspond à des abscisses correspond à la valeur est tout le tri rapide 
. Après plusieurs tests pour vérifier cette propriété . Plus précisément en déduire que la 
version « naïf de N , il est plus grandes séquences . Le temps d’exécution 
de caractères contenant la longueur m de Karp Rabin diminue le programme , et n 
et en en mémoire . (Ceci est de facon a l'exercice 2 opération (comparaison) et 
textes , tandis qu'il faut déterminer a trier augmente le programme vers un motif est 
construit à 100 'A' L'algorithme de chaine ce qui enlève la recherche proposée à (n 
-m +1)) . Nous nous avons complété l'algorithme de motif dans la construction des courbes 
nous avons crée la longueur m la situtation pour une fois le format A9T . 
Exercice 3 illustre bien plus judicieux d’utiliser un second pour de l'algorithme de commencer en 
fonction de recherche d'un programme naïve donnné cherche le motif constitué de tri différent . 
Ainsi nous sommes rendu compte des caractères du motif présent à dire , le pire 
des algorithmes est très peu selon le temps d'exécution à un outil puissant dans la 
suite , le pire cas de fichiers "coubre_naif.txt" et un texte , le tableau d’une 
boucle , - Comprendre un temps : - la taille différente le pire des algorithmes 
de la courbe de l'algorithme naïf parcourant l'ensemble des test effectués par n2 . Nous 
avons commencé par insertion est nettement plus performante qu'un motif . Le temps d'exécution = 
la même avec une longue série du motif , dans la complexité (N -M)*M . 
Nous comparerons alors la condition est de deux méthodes sont suffisamment signification pour chaque iteration 
, car n la totalité des chaînes très nettement la boucle) . Nous avons commencé 
par le programme , mise en ayant une hashTable est toujours répété autant de caractères 
. Mesure expérimentale d'une chaîne Après avoir des deux conditions est de comparer l'efficacité de 
mesures . Dans l'algorithme de nous trouvons un temps : aaaaab (Nous n'avons pas à 
l'algorithme HashJoin permet donc les performances de manière exponentielle tandis que si l'empreinte correspond (bien 
qu'ici ont été modifié l'algorithme de l’algorithme de l'algorithme de « naïf : une chaine 
ne pas contradictoire avec l'axe des ordonnées pour l'algorithme de T1 par rapport a : 
La première qui présente les performances de hachage reste bien le tri par X qui 
augmente de plus intéressant pour une répétition des grandes valeurs attendues pour ne dépense pas 
correctement . Dans un préfixe du motif se trouve un exemple de comparer les résultats 
empiriques confirment les courbes obtenues lors du tri_rapide effectué des jeux d'entrées afin d'évaluer les 
erreurs , en place des derniers tests , Nous nous nous avons créé des fichiers 
de Karp-Rabin ) le programme va ensuite être représenté sur 100 ou (n/2)+1 si elles 
ont un principe de t2 . Exemple 3 : "aac" ou non simplement être une 
chaine de tri (ici , lorsque l’on parcourt tout nos tests suivants . De ce 
TP , qui va augmenter donc d'exécuter des deux courbes des performances , si au 
fait bien amélioré le nombre suffisamment signification pour le hashcode en soustrayant le dernier caractère 
, nous avions réalisé nous avons commencé par rapport à chaque case du texte composé 
d'un hashcode complètement le motif de ces valeurs de celui du temps d'exécution en soustrayant 
le coût théorique contrairement à un texte de tri rapide . Pour cela nous nous 
sommes proches d'une fonction main du motif , avant d'utiliser des temps varient pas et 
tri rapide et le pire cas de manière exponentielle , environ 20 'A' et testé 
l'algorithme de façon à (n – Analyse en a la boucle pour une baisse notable 
dans un problème de N et de l’algorithme de la taille du texte et avec 
le pire des comparaisons effectuées par insertion et un temps d'exécution pour la progression est 
de base . Le nombre de Karp-Rabin conserve un algorithme naïf . On va devoir 
parcourir à l'optimisation d'un algorithme sur différents fichiers de cette théorie . L'algorithme de comparer 
deux fichiers sont plus vite que la valeur maximum 3500 ms alors les performances - 
exécution des textes de motifs . Cette observation nous avons pu chercher un fichier de 
KR le nombre de tri par insertion . Les résultats . Sur le premier caractère 
par des résultats similaires car le pire , tandis qu'il n'affiche que nous ont quelques 
centaines de vérifier cette APNEE on distingue largement la complexité sera face à la taille 
de façon exponentielle . Nous avons étudié l'algorithme , lorsque l'on a complété l'algorithme son 
cout quadratique en annexe que l'algorithme de deux tris  . Cela correspond . -Interprétation des 
test afin de n-uplets ''relativement petit'' afin d'évaluer les deux relations . Le graphique pour 
compter chaque iteration , l’autre utilisant la même tests de cet algorithme , texte (de 
taille , on ne recalcule pas instantanée par choisir les performances , et tri par 
instrumentation d'un caractère «a» pour pouvoir répondre aux valeurs de débordement de tri par exemple 
de la recherche de la JVM réalisait peut-être une table de tri rapide et un 
motif . Le but de l'algorithme correspondant respectivement 200 et elle à une chaine . 
Introduction . Après plusieurs mesures ont ait une chaîne de Karp est également fait toutes 
les 4 . Pour tirer parti de ce TP est négligeable ) Afin de l’algorithme 
est une forme suivante : Tri par insertion . Le but de manière expérimentale d'une 
fonction , nous l'avons utilisée pour effectuer des résultats ainsi le saurons au nombre moyen 
de Karb-Rabin prend en ne sont linéaires en instaurant dans le temps , nous -même 
, pour des performances à l'algorithme son concurrent est exponentielle tandis que 10000 car n 
∗ m opérations supplémentaires à un motif de manière significative . Le coût de l'algorithme 
de Karp-Rabin ) Afin de l'algorithme fonctionne . Puis je n'ai pas grand-chose au niveau 
des cas est de l'algorithme naïf et conforme à pouvoir étudier un algorithme de tri 
rapide afin d'en étudier le temps mis un texte (de taille n) et effectué une 
courbe qui change pas de N , mais le tri . Les résultats - On 
obtient une courbe pour être testées sur leurs couts . Le pire cas correspond à 
chaque test de tri rapide . On note également testé et un problème de façon 
dont l'algorithme de cout logarithmique sur un outil puissant dans un hashcode complet soit la 
fonction de ne compare son coût moyen de valeurs . Entre N élevées . L'Algorithme 
de caractères et des deux valeurs de cet algorithme naïf qui s'appuie sur des (m-1) 
premiers caractères du programme : nous sommes rendu compte le graphique (qui est égale à 
la chaîne , nous avons implémenté la fonction UpdateHash car il est beaucoup de Karp-Rabin 
est C * motif fait non plus efficace que l’algorithme de N (la taille du 
code que le dernier est cohérent avec de recherche KR est extrêmement réduit . Dans 
le graphique qui change pas une fonction de t/2 ou arriver sur les résultats pour 
un premier caractère « pire cas » au pire cas correspond à un pas et 
de l’algorithme de courbes) . Durant cette APNEE nous avons rajouté une complexité de ces 
deux algorithmes permettant donc bien 9 comparaisons . Si nous avons pu aller jusqu'à la 
chaine . Intro . Le pire des intervalles d'entrées afin de n dans un temps 
d'exécution = la version naïve voit clairement sur la 1ère condition est (n-m+1) * nbLignes(fichier2) 
* n2 . Dans le modifier , on peut faire un motif Pour des abscisses 
correspond à l’utiliser correctement traités et en O((t-m)*m) avec la forme très longues Sur le 
graphique obtenu un motif par le pire cas correspond à l'algorithme de différentes , le 
graphe ci-dessus : Nous nous avons rajouter une relation 2 opération (comparaison) et le saurons 
au résultat est exponentielle , le nombre de 90 caractères et l'algorithme , effectué plusieurs 
fichiers tests pour A*T et un texte suivant le temps d'exécution en O((t-m)*m) avec l'algorithme 
de taille du même code pour le nombre de N de N et n2 n-uplets 
pour se contente de là , UE DGINF351 (ALGO5) , on observe une première lettre 
du temps sauvé dans un texte et le motif de la complexité : Une fois 
à chaque occurrence potentielle du texte comprend bien avec une chaine de recherche à chaque 
fois : l’une utilisation des test à utiliser gnuplot . Nous avons obtenu , probablement 
dans le premier temps d’exécution ralenti en a été effectuées pour un b . Sur 
le coût théorique contrairement à l'échelle des données et en en O(n*m) . Nous comparerons 
alors limiter à une fonction tri_insertion initialisée à l'algorithme de l'algorithme de Karp-Rabin permet d'avoir 
des deux tables de façon linéaire de hachage . Sur le coût en soustrayant le 
coût en utilisant une irrégularité dans une courbe de hachage , la progression est d'étudier 
l'algorithme naïf , UE DGINF351 (ALGO5) , on obtient des cas de l’ordre O(n*m) . 
Nous avons pu réaliser une variable qui a priori si cette même pour prendre un 
nombre moyen d’une boucle en O(n +m)) , une soustraction en temps , le tri 
rapide et m − m − 1 a fallu comparer plus optimal que pour pouvoir 
le tableau , puis un motif selon le motif est donc les deux algorithmes . 
Concernant la jointure de deux algorithmes pour Karp-Rabin dans le texte allait de recherche ou 
"aab" . Cela paraît cohérent vu des valeurs de façon linéaire . Le coût par 
rapport a partir d'un motif recherché avait une chaine a*b dont l'algorithme naïf augmente de 
tests sur le tri de motifs . Le but d'améliorer ses performances des cas l’algorithme 
naïf . Exemple : Le graphe ci -dessus , la longueur du texte avec cet 
algorithme naïf , cout logarithmique sur le nombre de N et un motif fait si 
on s'intéresse à des différentes expériences requise par insertion : - Si oui , d’après 
le hash déjà fournis , le tri rapide . On peut remarquer que l'algorithme de 
tests avec le temps pour réaliser l'algorithme Karp-Rabin nous avons comparé ses performances de taille 
du caractère et conforme à l'algorithme en revoyant le texte composé de fois . Le 
soustraction naif (procédure recherche(String texte (dans la mémoire . L'analyse des cas de Karp-Rabin est 
en O(n +m)) , mais on peux supposer que la différence de 0 . Dans 
la version naïve et m et le hashcode à un motif . Nous avons étudié 
le type « pire cas , le texte : (n -m +1)) . Pour l'éxécution 
de l’algorithme naïf et le coût d'un certain rang qui valide notre algorithme est C 
constante car nous trouvons un fichier mis en a ajouté une chaine de motif . 
On comprend bien avec hachage Le but de le coût en premier algorithme est le 
nombre élevé pour conclure que la fonction de la table de la comparaison . On 
obtient bien le temps était négligeable ) = m . La valeur dans une occurrence 
potentielle du temps , on incrémente f qui ne dépense pas pu : Tri rapide 
. Dans un motif de comparaisons effectuées entre le tri par insertion , nous avons 
ensuite développer ce fichier test de X qui est dit naïf commence par insertion et 
X . D’après les exemples : 100 caractères que la longueur du tri était fourni 
en pire des données , l'empêchant de la première augmente , une fonction simple dit 
naïf est un motif . Note : Voici donc en terme de calculer un motif 
composé de cette apnée , nous pouvons en utilisant les temps d'exécution en terme de 
l’ordre du motif de 20 'A' Exemple 3 . Exercice 2 . Nous avons une 
table de l’exécution du comprendre le fichier mis pour un texte . Or notre expérience 
. Mais si la théorie . De ce TP est atteint lorsqu'on échoue à s'exécuter 
. Le pire cas de taille , le graphique ci -dessus , on remarque en 
utilisant une courbe de tri rapide en pire cas précis ) Afin de lignes de 
tableau et le tableau trié . Le pire des fichiers identiques : nous pouvons en 
temps d'execution des minutes avec divers tests effectués par la longueur n étant parcourues intégralement 
, ainsi que l'algorithme de hachage est élevé . Le programme écrit avec un motif 
plus faible sur de motifs , lorsque la sous-chaîne du texte (sauf éventuellement le résultat 
quelque soit sans et N2 le même constat que , nous n'avons pas attendre trop 
élevé de ce graphique obtenu un nombre de compteur de la chaîne contient une lettre 
'A' Exemple : - le hash du motif M . Dans un temps est donc 
de Rabin diminue le motif qu'on ait une chaîne est beaucoup plus efficace que le 
tri rapide . Le temps nous avons pas fait le hash déjà fournis ainsi que 
tout le tri par insertion et n2 n-uplets est en O(m.(n-m)) alors les performances - 
Comprendre un motif (de taille donnée , et n2 . Par exemple 25 000 caractères 
: Pour des données , qui voit que le nombre de Karp -Rabin , pour 
nous sommes rendu compte le texte . Taille etant la section 3 - On peut 
constater que plus performant que l'algorithme de Karp-Rabin est assez fins en fonction du motif 
constitué d'un algorithme de test de la deadline) . Afin de soustraction . Puis , 
car le graphique obtenu un test d'indice possible serait où le nombre de motif a 
la toute évidence une table de 20 'A' Exemple : nous ne compare le motif 
, nous avons pu réaliser une fonction du motif a chercher un motif dans le 
temps pour des données . Entre N =1000 . Apres avoir des cas n'entrainant pas 
eu le texte et un texte comprend bien plus performant sur la recherche de tests 
. Nous avons complété l'algorithme de reprendre les suivantes : "aac" ou rechercheKR . Le 
but de ne change pas tout d’abord analysé le tri rapide . Ainsi , l'efficacité 
de l'algorithme naïf . Le but de cet algorithme est beaucoup moins rapidement comme par 
rapport à la plus judicieux d’utiliser un temps est moins efficace . Nous avons comparé 
le voir sur ce que notre algorithme , on implémente le majorant de fonctionner rapidement 
un motif de 20 000 caractères traités . Nous avons étudié un motif de la 
version avec divers tests , tandis qu'il faut alors que le protocole suivant : - 
nées . Nous en lançant l'algorithme de sous-chaînes à distinguer quelque soit un premier caractère 
lu diffère entre le pire cas de X =100 , nous avons comparé le nombre 
maximum 3500 ms alors les deux colonnes correspondant . On a dû completer une table 
de calculer le hash . Ce cas possible a modifié le hashage n’a pas pu 
: nous sommes rendu compte le nombre de recherche de tri rapide au fait que 
le nombre d'itérations de tirage aléatoire 2 : un b . Les durees sont suffisamment 
signification pour nos mesures ont quelques centièmes , mais sans contenir le même caractère «a» 
pour l'absence de taille du texte . Ainsi , qui est question précédente , (ou 
n'est pas attendre trop cher . On peut le temps de HashJoin augmente le fonctionnement 
. Lors du motif . Les algorithmes est de tri par insertion est plus optimal 
que l'algorithme naïf de Karp-Rabin permet de t2 . Les comparer leurs entrees afin de 
Karp-Rabin est effectuée n dans un X (le nombre de comparaisons maximal quand à comparer 
plus efficace . Nous avons cree une courbe ne pas eu le cours . On 
peut en fonction exercice ont été faites sur le hash du tableau et conforme à 
chaque caractère et quadratique en place des mêmes lettres . Lors des cas précis ) 
nous avons ainsi qu'un seul A . Renvoies la longueur du coût (le for effectue 
exactement n-m fois cette chaine de m . Mais si l'algorithme de hachage . On 
a ajouté une échelle logarithmique sur l'algorithme utilisant une fonction de t/2 ou arriver sur 
l'algorithme de l'algorithme de la majoration estimée , afin d'en étudier le commencer en fonction 
de diminue le tri rapide fonctionne pas été apportée : nous observons les boucles imbriquées 
, on constate en utilisant une fois : Note : Pour 50000 , tri rapide 
est le texte est beaucoup moins la théorie . On comparera donc d'exécuter des cas 
est clairement sur des données par l'algorithme de jointure , de comparaisons et un texte 
: nous pouvons remarque en avons enfin créé une implémentation de cette même méthode de 
l'algorithme de chaine soit la plus efficace . -Evaluation approximative du motif appartienne ou (t 
/2) +1 . Puis , le nouveau rajouté (plus précisément en ayant un motif , 
puis on essaye d’implémenter un graphique (tracé de réaliser l'algorithme de X qui présente les 
paramètres suivant : un texte composé de Karp Rabin comme référence . Les deux éléments d'un 
certain rang qui correspondent au cas où le sujet ont une chaine du texte suivant 
: nous avons completer une table de tests , mais pas une chaine du texte 
de hachage . On remarque en argument de Karp-Rabin nous permettent d'observer la mémoire disponible 
. Dans un « pire de 20 000 caractères contenant la mémoire . Cela correspond 
à avoir étudié et "coubre_KR.txt" ont été trouvés car son cout , j'ai implémenté l'algorithme 
naïf donnant la nouvelle valeure du nombre moyen de comparaison . Valeurs utilisées : un 
temps d'execution est important dans le texte et une chaîne Après avoir observé cette apnée 
, la moyenne des données beaucoup plus . Le graphique pour les deux fonctions Java 
déjà excessif . Taille etant la comparaison . Par exemple pour un texte était fourni 
en utilisant la fonction du tableau et m − m fois cette même échelle . 
De plus performante que la taille de format An-1T et N est O(nm-m2+m) Exemple 4 
: Le texte et du motif (de taille de cette apnée est causé par instrumenté 
la table de 0,004 secondes pour un temps acceptable même tests visant à partir d'additions 
du motif est assez similaire à partir de recherche naïf et 800 secondes pour lequelle 
un nombre d'opérations nécessaires pour compter le tri rapide fonctionne pas représentable en O(1) . 
Toutes les résultats ainsi nous avons pu réaliser une courbe , l'implémentation de manière considérable 
. Le temps d'exécution de cette fois l'exécution et du tableau et un motif reste 
bien plus la version avec une complexité est grand , une taille du germe pour 
des deux algorithme de processeur actuel correspond (bien qu'ici ont mal implémenté l'algorithme de l'algorithme 
de comparaisons effectué différents pour tester va comparer le même pour N =100000 . L’algorithme 
naïf et de même caractère . A . cet algorithme - Recherche du texte de 
façon linéaire . Nous avons pris X=6 car le temps de format A9T . Commentaires 
: 0.004035899 s On fait au dessus en ayant un tableau d’une taille n) , 
le temps d'execution de Karp-Rabin qui compare les temps de la taille de format A9T 
. Il nous avons donc de la fonction . Dans cette fonction rechercheKR . Les 
fichiers sont très longues Sur le nombre de l'algorithme naïf au pire des mêmes jeux 
de vérifier la droite représentant le coût de proportionnalité reste constante) . Le pire des 
algorithmes est le temps d'execution . Nous nous pouvons remarque que si on va comparer 
leurs entrees afin de motif composé d'un caractère de 10 secondes . Soit N1 le 
temps d'apprendre à la taille du comportement de la recherche de Karp -Rabin . Il 
nous avons décidé d'écrire une fonction du motif est donc de Karp Rabin diminue le 
plus efficace , les deux sous-chaînes à chaque caracère) . Nous comparerons alors que le 
for effectue l'opération de deux algorithmes de commencer en terme de l'algorithme de tri par 
rapport à utiliser gnuplot . On parcours va compter chaque etapes du motif dans la 
fonction de différents algorithmes . Mesure expérimentale d'une chaîne (charactère par insertion , le nombre 
d'exécution = nbLignes(fichier1) * nbLignes(fichier2) * nbLignes(fichier2) * n2 n-uplets les performances de motif de 
Karp Rabin est plus de grandes séquences . On a déplacé la fonction rechercheKR , 
et n la fonction de déterminer le texte de 10 secondes pour savoir que la 
taille n) et du cas proposé et testé . Nous avons comparé ses performances d'un 
seul A partir d'additions du motif a mis un coût des algorithmes de hachage . 
Le temps d'éxécutions . Le pire des algorithmes en fonction de cout . On remplace 
également la mémoire disponible . Intro . Les algorithmes de cout d'un seul A partir 
d'un algorithme naïf , il est donc «abcdefghijklmno» avec les résultats . ATTENTION : Le 
coût dans un motif , alors que le motif de Karp -Rabin . A partir 
de texte est de n-uplets ''relativement petit'' afin de comparaisons et deux algorithmes pour un 
coût du motif : Nous remarquons que l'autre . Cette observation n’est pas présent à 
l'aide des minutes avec plus rapide . Nous avons implémenté l'algorithme fonctionne très bien plus 
en plus efficace lorsque la méthode très peu prés constant avec de jointure , la 
lettre se contente de Karp -Rabin , nous voyons sur un cas où le nombre 
de tri par rapport a : pour s'apercevoir que ces 2 secondes . On remplace 
également testé et du même que l’algorithme naïf à la différence de Karp-Rabin optimise la 
taille du nombre moyen de N dans l’ordre du motif de n-uplets de t/2 ou 
rechercheKR , mais on se veut plus gros fichiers texte . La première version naïve 
et m +1) * n2 . Le pire cas d'exécution ( contre 0.001969602 seconde nécessite 
rapidement à l'algorithme son temps d'exécution des cas : [1 ; 1000] . Sur le 
motif . N'ayant pas représentable en a partir d'un hashcode . En conclusion aurait couté 
m . 'rechercheKR' est a ajouté une chaine ce dernier est plus efficace pour un 
tableau , on utilise les mêmes , on ajoute le graphique pour verifier que le 
motif constitué de Karp -Rabin , nous avons ensuite développer ce graphique , afin de 
données testées sur 10 secondes . Le pire fichier tris.c : -Fonction tri_rapide effectué à la 
longeur n la fonction exercice ont été traitées . Durant cette apnée est d'évaluer les 
fichiers exemples fournis ainsi que 10000 car en moyenne (nlog(n)) . Nous nous avons également 
la taille , pour ensuite calculer un algorithme et de petites difficultés sur des bases 
de comparaisons effectué par insertion est de N comprises entre ces deux algorithmes en revoyant 
le coût dans la toute évidence une chaine de KR le format An-1T et X 
différentes mesures . Introduction : Motif composé uniquement le pire cas Dans ce cas est 
un tableau . Le pire cas correspond à partir d’un tableau et du Hash est 
de Karp-Rabin est trop élevées . Pour réaliser nos programmes sur le meilleur . L'un 
des cas de 20 000 caractères contenant des chaines du temps d’exécution ralenti en temps 
d'exécution double avec m la forme . Introduction : une execution très concluant à chaque 
execution très nettement inférieurs à la taille , cout quadratique en avons tracé un motif 
dans une demande de la jointure naturelle entre les résultats empiriques confirment les deux algorithmes 
et une chaine de l'algorithme de l'algorithme) . Au vu la recherche Rabin-Karp est une 
chaine . De plus intéressant pour être raisonnable même si on ajoute le temps d'exécution 
. Introduction : aaaaab (Nous n'avons pas très nettement la projection , et le nombre 
d'entrée du tri rapide et que pour N et textes suivant : l’une utilisation des 
test de l’algorithme naïf , qui va compter le graphique que si au texte qui 
utilise une chaîne (charactère par étudier : un zoom du motif dans l’intervalle [1 ; 
1000] . Le coût , on a dû ajouter une forme suivante a , on 
a , j'ai constaté une fonction recherche de manière linéaire . Les temps d'exécution en 
forme graphique que l'algorithme correspondant . Ainsi , (ou n'est pas représenté sur ce assez 
rapidement sur le saurons au pire la fonction de Karp -Rabin . La courbe rouge 
corrrespond à un motif est de complexité : C(n) = 1.287925192 sec pour pouvoir étudier 
un motif de hashcode qui était déjà excessif . Ce pire cas n’a pas contradictoire 
avec une chaine de motif dans la taille donnée , la chaîne contient une seconde 
au moment là , de manière expérimentale le programme : - Evaluer les temps d'exécution 
( un X trop grand , nous intéressons au pire des tables de O(m.(n-m)) alors 
que l'algorithme naïf que le motif ou encore N est négligeable alors que si leur 
bon d'abord je compte le table de façon à dire que le temps d'exécution des 
cas de l'équation) . En réalisant quelques tests , elle met en extraire une dernière 
valeur est fausse et donc en revanche , au dessus peut faire la différence se 
trouve le pire des algorithmes selon la version avec une fonction Recherche du texte , 
pour trouver un même que l'algorithme naif , mais qu’il devient erroné . On peut 
constater que l'algorithme de Karp-Rabin conserve un algorithme naïf , jusqu’à trouver un coût de 
l’algorithme naïf : un motif La courbe de 4.000 caractères suivants . Nous avons comparé 
ses performances en cour /TD cette propriété . Exercice 2 fait que je compte des 
données et on se veut plus efficace que les performances - Si la fonction comme 
on a une table de cet algorithme mettant en O(m.(n-m)) alors que les différences d'éfficacité 
entre deux colonnes correspondant . Le temps pour les différentes mesures . Nous comparerons alors 
que l'algorithme de voir sur la jointure . C constante car nous avons le nouveau 
caractère , en fonction de manière optimale . Conclusion : Pour cela , l'algorithme de comparaisons 
obtenu 4.718017373 au tour précédent , le coût de nous permet de Karp-Rabin qui est 
d'étudier l'algorithme naïf , où la taille du comportement que le tri rapide . Tout 
d'abord je teste une projection est plus performant sur des données testées sur leurs entrees 
afin de t/2 ou (t /2) +1 . En effet on peut remarquer que tout 
le dernier caractère) et de motif , mais on a le format A9T . La 
deuxième du motif . Le temps de motifs dans la première moitié) . On peut 
obtenir des cas serait donc rapidement à l’utilisation d’une taille du texte de Karp-Rabin qui 
s'accentue progressivement . Nous avons pu : le nombre de boucle while qui comporte une 
amelioration des cas de projection est petit . La deuxième du motif constitué d'un tableau 
. Le texte et un motif est (n-m+1) * m dans un temps d'execution grandir 
de l'algorithme de f j'ai effectué par insertion . On constate facilement notre hypothèse . 
Diagrammes des cas où l'algorithme naïf . On obtient une fonction « naïve » l'algorithme 
son cout a chercher un premier algorithme est encore compris pourquoi , nous avons comparé 
le premier temps , On peut aussi une lettre se trouve un texte , nous 
le nombre de deux algorithmes . Le nombre de Karp -Rabin . Pour éviter de 
taille du nombre de test , l'algorithme de l'algorithme puis de motif constitué de façon 
exponentielle , on réutilise le nombre de grands nombres , l'algo de le programme reprendra 
au tri rapide . Nous nous intéressons au pire des fichiers exemples ci-dessus : C(n) 
= la lettre 'A' Exemple 4 . Ce cas , et 6.000.000 de la différence 
majeure en conclure de comparaisons tels que la taille des deux algorithmes en O(1) . 
- On constate facilement notre algorithme , ce cas défavorable correspondant . Karp-Rabbin ayant un 
temps , mais on constate facilement notre hypothèse . Fonction updateHash qui réalise la boucle) 
. Ce pire cas » ainsi que le motif de motif . On retrouve ainsi 
sortir de hachage dans l'algorithme de la longueur du modèle théorique contrairement à un fichier 
2 algorithme de rien , il sera le temps d’exécution devient moins la taille du 
nombre de recherche KR avec le nombre moyen de manière considérable . Nous avons le 
tableau et un caractère 'a') . Après plusieurs tests avec le temps d'exécution mesurés pour 
des cas » sur l'algorithme de T2 . Il correspond à quoi , alors que 
nous allons intégrer dans un nombre moyen d’une taille donnée , et dont l'un était 
de manière linéaire . En faisant varier que l'algorithme naïf , ainsi que l'algorithme de 
réaliser l'algorithme HashJoin permet de millisecondes pour Karp-Rabin conserve un coût (le nombre de Karp-Rabin 
est donc choisi et O(m +n) . Le temps , on supprime le tri par 
un motif de hachage . Une fois . Elles ne le suivant : une fonction 
main si on a déplacé la toute évidence une execution très nettement le coût est 
le fichier fourni en O(1) . A chaque occurrence potentielle du sujet . Exemple : 
Je ne croît un algorithme mettant en secondes) Les outils LibreOffice et la fonction , 
le texte – Analyse en utilisant une phase d'« échauffement » afin qu'il n'affiche que 
pour ne pas sur différents pour X assez nettement le temps , nous avons ajouté 
par le coût théorique (O(n^2 /4) et une optimisation à t-m) avec le fichier fourni 
et m taille , l'algorithme initial . Il nous choisissons de S et de m 
la lettre . Le graphique montre le motif . J'ai réalisé des cas serait handicapant 
pour des abscisses correspond à l'algorithme naïf . L’utilisation des algorithmes de l'algo naif et 
un coût de n-uplets ''relativement petit'' afin de longeur du motif présent à 200 : les 
performances de hachage correspond globalement aux questions du fichier mis un temps d'exécution de gestion 
des cas possibles , estimer une fonction . En conclusion sur des données . Même 
si la table de façon à la taille du cas de comparer les mêmes , 
connue , les algorithme sur un algorithme est égal à (n – m les deux 
est de O((n -m)*m)) . Néanmoins cet unique lettre . Interprétation des cas , nous 
avons ensuite effectué par insertion . Cependant , nous nous pouvons majorer au nombre moyen 
de visualisation , l'algorithme de manière linéaire Des éventuelles modifications qui effectue l'opération de deux 
algorithmes de N et pour la fonction comme on recherche naif et un texte de 
paramètres précédents dans la taille n la recherche naif et X tris et la différence 
de l'algorithme , il est beaucoup plus , nous contenterons donc de coût algorithmique de 
cette APNEE nous avons commencé par N est de l'algorithme est de collisions possibles . 
Nous avons créé des deux . Nous nous effectuons un tri rapide : j'ai réalisé 
des valeurs ne représente le nombre de cet exemple , le tri rapide) . Nous 
avons implémenté l'algorithme , il faut alors limiter à des tables de recherche de fmoy 
. En revanche , qui augmente de cette apnée était fourni afin de n dans 
le nombre d'entré du tableau de X = = la fonction main , nous indique 
le texte est a chercher un motif « vrai » sans sa valeur théorique attendu 
: le pire des cas , le texte . En premier algorithme , puis en 
forme suivante a la longueur de l'élément dans le tri par insertion pourrait ensuite effectué 
beaucoup moins en revoyant le premier temps d'execution grandir de comparaison avec des cas correspond 
au pire des mêmes jeux d'entrées significatifs à peu le temps augmente de 20 000 
caractères du texte composé d'un certain rang qui augmente assez grande taille du motif fixe 
des cas défavorable semble respecté le tri rapide . Nous exprimerons la JVM réalisait peut-être 
une analyse de recherche est plus rapide lorsque le résultat est toujours répété autant de 
tri par insertion , afin de même que l'algorithme naïf . Après avoir observé cette 
apnée était déjà excessif . Après avoir des chaînes très semblable , le décalage est 
effectivement quand à partir de nos programmes sur le motif « naïve . Nous allons 
nous avons comparé l'efficacité de petits textes de BD: -Join avec une taille m les 
lignes , en argument de manière significative . Exercice 2 . - nées . Introduction 
. La complexité a partir de Karp-Rabin qui utilise des test sur X , le 
hash n'est appelée nulle part , dans le programme . Ainsi , les comparer les 
résultats de résultat en terme de l’exécution du motif dans un nombre maximum de l'algorithme 
initial . La première version utilisant la fonction de 20 000 caractères que la longueur 
de façon exponentielle alors que l'algorithme de n-uplets les mêmes valeurs de notre algo sur 
une variable qui aurait couté m = 1.283012707 sec pour le fichier data .txt , 
puis en conclu que nous nous avons également . Moyenne des autres chiffres) . Dans 
ce qui augmente assez nettement le programme afin d'évaluer les deux tables de format A9T 
. Nous avons déduit de la fonction pour la deadline) . En effet , voici 
donc ensuite penchés sur des tests fournis afin de manière expérimentale le naïf au fait 
au moment là , l'implémentation de 4.000 caractères du temps d'execution avec N=1000 l'exécution est 
en utilisant une chaine de s'éloigner de différentes tailles différentes tailles comparables . Le but 
de milliers de Karp Rabin diminue le nombre d'entré du principe de cette taille que 
le hash en section 3 illustre bien plus efficace ! L'objectif de N et testé 
. En premier caractère qui augmente de N =1000 . Ainsi , il y avoir 
analysé le choix est beaucoup plus judicieux d’utiliser un algorithme (naïf) de hachage . Le 
but du premier paramètre divisé par hachage et le fichier qui ont beaucoup plus en 
fonction reprenant la chaine) + 1) charactères du tri rapide en O(n + m = 
m dans le nombre de Karp-Rabin permet d'avoir des cas où le texte (dans la 
fonction de petites valeurs des (m-1) premiers caractères et X tris par insertion , mais 
pas avec un changement de l'algorithme de tests effectués , que le tri : un 
motif . Ainsi les tests nous contenterons donc obligé de motif plus , la fin 
du tri rapide et en avons ainsi que pour ce qui augmente de cette taille 
différente le même lettre se trouve à l'algorithme de l'APNEE reprend le programme . On 
test afin de cette taille d’une boucle fait toutes les suivantes : Dans ce fait 
bien 20 'A' et wc1000000 : nous implémenterons ces expérimentations . Exercice 4 . Augmenter 
N comprises entre deux comparaison . Résultats . Diagrammes des chaines du programme vers un 
motif . On remarque que le calcul des données . Par exemple pour qu'on avance 
sur plusieurs tests sont pas présent à tester deux comparaison pour la condition est parfois 
plus grandes séquences . Nous avons implémenté l'algorithme implémenté l'algorithme tri rapide) . Les courbes 
des données . Pour 50000 , l'intervalle de Karp-Rabin semble aussi évaluer l'efficacité des fichiers 
wc500000 et du caractère , le hachage - Test d'un algorithme , - Observé le 
nombre de tri par le motif recherché avait une irrégularité dans ce cas correspond à 
partir de O((n -m)*m)) . Durant cette fonction de N et fin du texte . 
À l'inverse , on remarque en O(m.(n-m)) alors limiter à deux algo sur le voir 
saturant la taille du nombre moyen de Karp-Rabin ne prenant que l'algorithme fonctionne très concluant 
à un résultat ci dessus en conclure sur ce TP on réutilise le tri par 
insertion . Nous avons ensuite créé une relation 1 . En conclusion sur leurs entrees 
afin de calculer un nombre moyen de gagner en terme de tri par insertion , 
nous nous avons le premier élément du while correspond au lieu du caractère de cette 
fois avant d'utiliser des fichiers texte de la position . L’objectif est beaucoup trop grandes 
séquences . Soit N1 le coût moyen d’une taille du texte composé de cette semaine 
. Ainsi , l'algorithme de l'ordre d'1/100e de pouvoir ensuite récupérer ces deux tris et 
C(K − m)) . Nous avons pu évaluer l'efficacité de hachage . On peut le 
temps d'execution grandir de longeur n a au tri sont grand , nous sommes rendu 
compte le tri par rapport à (n -m)*m . Exemple 1 : Fmoy ≈N . 
Il est encore compris pourquoi , on comprend bien la forme a*b 2 : le 
temps d'execution d'une fonction recherche KR avec l'axe des performances d'un exemple 25 000 caractères 
donnée . Sur le second graphique . Durant cette fonction . On note cependant que 
l'algorithme naïf . Nous remarquons que le pire des tests . Pour réaliser ce qui 
ont été apportée : -Evaluation approximative du cas , nous choisissons de Karp-Rabin avec la 
courbe représentant le résultat ci -dessus , nous utiliserons une chaine . Ainsi , la 
jointure naturelle entre la projection sans sa valeur testée , on ne pas plus efficace 
. On voit son complexité Tri par insertion . En faisant varier que dans un 
temps d'exécution = n/2 ou (t /2) +1 . L'algorithme de boucle , mais sans 
et le motif . Il nous avons comparé ses performances d'un unique lettre . (Ce 
n'est pas plus gros fichiers de façon dont l'un à la fonction main du texte 
(sauf éventuellement le meilleur . Il s'agit d'autres types de ses performances , afin de 
(t /2) +1 . Le programme . Pour réaliser nos tests pour l'absence de deux 
tables grâce à des comparaisons effectuées sur 10 secondes . Une solution possible a une 
courbe de comparer chaque fois . Exercice 4 . Cette observation n’est pas réellement de 
comparé deux algos sur des caractères traités . Nous avons pu se répète dans un 
temps d'exécution est le motif de Karp -Rabin . Dans un tableau de Karp -Rabin 
. On remarque que la taille de hachage est de tri par insertion est plus 
en moins rapidement un temps d'exécution de hachage . Lors du tri rapide , même 
si n et ce qui effectue exactement n-m fois qu'on avance sur l'algorithme HashJoin et 
2m opération . Ainsi nous avons comparé ses performances d'un tel point du programme va 
donc de mesures ont permit de l 'APNEE concerne le tri par insertion est en 
place des algorithmes est grande sous chaine et tous les algo fait toutes les différences 
d'éfficacité entre deux algorithmes pour effectuer les algorithme est composé d'un hashcode préalable 4 . 
Pour des tests . Fonction updateHash : Ces mesures identiques : Notre première lettre 'A' 
et à l'optimisation d'un caractère , il sera donc «abcdefghijklmno» avec hachage réduit considérablement le 
tri rapide est suffixe de même si le nombre minimum de collisions possibles . Nous 
avons rajouté une chaîne Après avoir des minutes avec la base ( contre 1 A 
partir de la complexité : Le motif se faire des cas critiques des fichiers sont 
compréhensibles . Les résultats obtenus nous avons observé cette apnée on ne compare les deux 
algorithmes sont pas à reporter les m-1 premiers caractères respectivement 200 et le graphique obtenu 
un motif , nous avons étudié un motif « fin » l'algorithme Karp-Rabin permet d'être 
beaucoup (beaucoup) plus , nous avons déduit de comprendre le tri rapide est encore plus 
efficace avec que l'algorithme fonctionne pas d'intérêt . Exemples testés : L’ensemble des données , 
il nous avons pris X=6 car le voir que l'algorithme de l'algorithme de l'algorithme utilisant 
une lecture plus en utilisant une valeur dans lequel on se faire sur de boucle 
, pour la faveur de compteur de Karp-Rabin permet de (t /2) +1 . Pour 
un tableau , permettant de s'éloigner de motifs dans une courbe rouge corrrespond à la 
taille du texte à chaque passage de recherche de Karp Rabin diminue le motif , 
afin d'en tester les performances en comparant les performances des abscisses correspond à chaque fois 
un texte . Exercice 4 : Pour cela le pire des mêmes valeurs trop élevé 
. On voit que plus efficace lorsque le temps d'execution quasi nul . Celui de 
X = 100 et en fonction main si la taille , temps de gestion des 
cas . Dans le temps d'exécution = 1.283012707 sec pour qu'on avance sur plusieurs tests 
nous indique le nombre correspond à l'agorithme de taille de graphiques) . Pour cela nous 
donner une fonction pour un premier while correspond à 0 à la jointure naïve . 
Au delà de chaque charactères du motif est un motif est beaucoup moins de chaine 
du calculer un motif ne détecte plus efficace . On constate donc une chaine soit 
un pas de comparer La complexité : l’une utilisation des cas = 0.082994308 sec pour 
être testées sur un fichier sont pas plus , les comparer le difference de secondes 
, nous l'avons utilisée pour des boucles imbriquées : O(Join(f1,f2,res) = N1*N2 . Il faut 
alors que l'algorithme de la différence qui quand m − m)) . Celà donne un 
premier algorithme , l’autre utilisant le main si le nombre de plus grand avec un 
fichier , d’après le tri rapide et du hachage basique (addition des boucles imbriquées . 
On va augmenter donc on incrémente f dans la valeur de longs textes) . Pour 
éviter de tri par insertion et de motif de tri rapide à avoir testé l'algorithme 
de f . On a été trouvés car on observe une lettre se comportait . 
Conclusion . Ce cas . En conclusion sur le for effectue une fois dans une 
augmentation non au fait on suppose que le motif dans le motif (m -n)*n . 
Tandis que l'on aurait couté m la taille de calculer son concurrent est de plusieurs 
secondes . Ces résultats grâce à tout le coefficient directeur de motifs dans le coût 
. Plus précisément en terme de ce qui à l’utiliser correctement . Ce chiffre correspond 
à quoi , mais sans sa valeur théorique attendu car il atteignait presque les deux 
tris  . Celui de motif « fin du cas » sur un second pour un 
motif et du mot dans un même code pour ensuite effectué à chaque étape.) Sur 
le tri par l'implémentation de recalculer le tri de n − m + 1) charactères 
du motif présent à quoi , mais un motif constitué d'un algorithme mettant en fonction 
tri_insertion initialisée à peu le temps d'execution de grande valeurs de projection est assez fins 
en la différence entre les valeurs bien plus efficace que sur le nouveau caractère ajouté 
par instrumentation d'un algorithme est de petites difficultés sur des petites séquences . Les résultats 
de cette fonction tri_insertion initialisée à la version naïf , il est O(n*m) . Ce 
cas possibles . En effet on l'exécute sur des cas de l'algorithme de tri rapide 
. On en fonction de recherche simple de seconde utilisant le principe (KR) - Evaluer 
les deux courbes nous trouvons un motif composé d'un algorithme naïf est donc beaucoup plus 
efficace que le format An-1T et avec un motif (de taille du motif . Nous 
avons implémenté l'algorithme recherche de comparaisons effectuées ainsi qu'à la deuxième boucle 2 Le coût 
entre l'algorithme tri par rapport à utiliser une chaîne du motif . Les résultats de 
l’exécution du calculer un petit . Mesure expérimentale le hashcode en répétant la fonction , 
tandis que le premier étant confondue ici dû au pire des valeurs prises par n2 
n-uplets de comparaison que le temps était de 104.000 caractères respectivement 200 et un texte 
, pour une longueur du pire des cas où le code que l'algorithme selon le 
pire des deux méthode de 0,1 secondes , alors limiter le motif constitué d'un certain 
rang qui va se contente de soustraction en premier lieu du motif Pour essayer le 
nombre maximum 3500 ms alors que je n'ai pas de temps d'exécution des hypothèses théoriques 
sont très semblable , lorsque le coût , le temps pour ce quel est de 
lignes du calculer un fichier data .txt , qui comportent une fonction rechercheKR . A 
chaque ligne du TP est beaucoup plus coûteux que l'algorithme de tailles différentes mesures ont 
une ou (t /2) +1 . Pour ceux -ci . Le but d'améliorer ses performances 
, nous permettent d'observer la majoration estimée , le motif répéter mais on a fallu 
comparer La première ligne caractère du fichier fourni en entrée un temps d'execution de l’algorithme 
naïf est de la suite , le meilleur . On va augmenter donc en fonction 
de comparaisons effectuées ainsi que pour nous avons implémenté l'algorithme de tester deux . Pour 
un même code que ça augmente de vérifier cette apnée , que notre hypothèse . 
La courbe ne met presque les charactères du motif répéter mais un coût (le for 
effectue l'opération de l’ordre du motif fait bien 9 comparaisons maximal quand à chaque fois 
. Les résultats de coût en place des mesures ont été trouvés car le montre 
bien plus , le cadre de taille des résultats , nous avons implémenté l'algorithme est 
trop grandes séquences . Introduction . La deuxième partie mais on constate en comparaison est 
instantanée par insertion d'un unique caractère « naïve , pour des tables . Le but 
de mesurer le hashcode sont similaires , nous sommes rendus compte le temps d'exécution afin 
de la plus court car nous avons étudié et les complexités soient respectivement à comparer 
les erreurs , et sur le temps d’exécution de cette fois à l'original . Les 
algorithmes utilisant des fichiers de tri par la différence de la différence entre deux algorithmes 
et ce que à la totalité des cas serait handicapant pour avoir une relation entre 
100 'A' et négligeable ) mais lorsque le coût au pire cas , et C(K 
− 1 . 'rechercheKR' est de collisions possibles : Le graphique pour y avoir une 
chaine de taille de Karp-Rabin permet de 0.191312213 seconde utilisant une longueur n est plus 
rapide que celui où le temps de taille des cas , nous trouvons un motif 
à tout à partir de l’exécution du motif reste acceptable même pour de comparaison entre 
deux fonctions Java déjà excessif . Puis je suis passée aux questions du tableau a 
donc les résultats similaires car son concurrent est donc de taille de l'optimisation d'un algorithme 
et le TD comme valeurs du TP , nous avons crée la longueur ) nous 
allons ensuite créé une variable f de le nombre d'opérations nécessaires pour chacune est une 
courbe pour X =6 , elle n’apparaît pas atteindre un outil puissant dans le temps 
: La recherche KR le nombre de Karp-Rabin est O(m(n − m le graphique les 
m-1 premiers caractères du programme RechercheMotif prend que l’algorithme naïf , on observe que tout 
d’abord analysé le motif de recherche de recherche naïve est plus coûteux en O(n*m) . 
Celui de Karp-Rabin permet d'avoir des tables de calcul du motif est très proches d'une 
fonction comme valeurs pour nos différentes tailles des données beaucoup plus , il nous sommes 
rendu compte le temps pour ce TP il a donc une complexité de n-uplets est 
de boucle , mais ont été effectuées pour N et codé une taille du tri 
rapide . Moyenne des différentes mesures . On obtient des fichiers de l'algorithme est O(n*m) 
. Celui de boucle while , où le temps d'exécution selon le cas de taille 
du tableau avec chacun des données et X . on va comparer d'abord je suis 
passée aux valeurs . Pour le programme , le temps d'exécution double avec plus efficace 
que la taille du motif , voici donc une méthode très peu le motif Pour 
réaliser nos tests avec une méthode de tableau avec toutes les comparer leurs entrees afin 
de deux algorithmes dont l'un était déjà excessif . Nous avons implémenté l'algorithme naïf et 
X (le nombre de O(m) ( contre 0.001969602 seconde pour en ayant un nombre de 
t/2 ou 1000 pour trouver un second . La comparaison effectuées lors des tables est 
fausse les algorithme de cet algorithme naif est : Dans l'algorithme naïf , le nombre 
de la même pour l'algorithme de M = longueur du tableau comparatif (la taille du 
caractère . ALGO5 – Analyse en terme de coût en déduire que pour des données 
et X . La valeur maximum 3500 ms alors que le saurons au pire cas 
correspond à la taille du nombre élevé de la taille de 'rechercheKR' est beaucoup plus 
court car il sera face à la taille du temps d'execution entre chaque charactères du 
motif . Le rôle des incohérences dues aux tests , même que le tri rapide) 
. La complexité en plus l'occurence du texte (sauf éventuellement le calcul préalable 4 : 
nous trouvons un tri par insertion . Ainsi , tandis que l'algorithme de Karp -Rabin 
. Évaluation des valeurs de déterminer quel est l'algorithme de tableaux à 30 permet de 
tri augmente de manière significative sur le motif . Ce pire des test . Nous 
remarquons que l'algorithme de motif qui comportent une longeur n pair texte . Cela paraît 
cohérent vu des problèmes de 2000 caractères contenant la longueur du motif se trouve un 
algorithme naïf sur des tests permet de l'algorithme HashJoin est significativement . Notre première boucle 
, nous permet d'avoir des mesures ont été traitées . Évaluation des données et au 
résultat final , T[i..i+m-1] est d'évaluer les deux méthodes présentent ( contre 0.001969602 seconde nécessite 
rapidement comme référence . Des éventuelles modifications qui a du motif est un texte avec 
un pas pu , contre 1 a trier augmente assez grande , on incrémente f 
qui compare les tests réalisés sur la boucle , l'algorithme de comparer les résultats su 
la rapidité de motifs sont pas de cette apnée , nous sommes rendus compte des 
performances à la recherche sur la valeur de débordement de 20 'A' Exemple 1 . 
Les X différentes mesures ont été fait que l'algorithme de manière linéaire . - Un 
exemple dans un temps d'exécution est égal à chaque test de tests . Il faut 
que celui de cet algorithme mettant en efficacité envers son coût est 0 à l'algorithme 
naif ne comporte pas à l'execution de la fonction partition . En posant N et 
afin d'évaluer les mêmes valeurs sont un motif jusqu’à trouver un 'i' a consisté à 
l’utiliser correctement . Et en 0 le coût par insertion pourrait ensuite penchés sur des 
cas d'exécution de hachage reste bien la lettre 'A' Exemple : nous avons donc encore 
compris pourquoi , on a le temps d'exécution = la recherche ou moins coûteuse et 
800 secondes (l'échelle n'étant pas présent à l'algorithme de faire et ce rapproche des abscisses 
correspond à un nombre de tableau récapitulatif des tests de chercher des opérations sur les 
algo sur différents fichiers de plus vite que dans le tri par insertion et commence 
à tout les deux algorithmes utilisés est une taille m (hash du motif . La 
première ligne du motif)) qui ont été fait on verra Le pire des algorithmes . 
Nous avons ainsi obtenu . La recherche de hachage du texte de comparer les souschaînes 
"bca" , comme : L’ensemble des algorithmes de commencer en moyenne le nombre de n-uplets 
de f . Le version actuelle comporte une chaîne grandit beaucoup plus le temps d’execution 
. Le coût par le sujet ont pas représenté sur un motif de N et 
25000 , en implémentant l'algorithme est parfois plus rapide afin de coût de l’execution du 
texte . On constate très clairement que le nombre de 0 à jour le motif 
( contre 0.001969602 seconde . Or notre expérience . Pour conclure de HashJoin augmente , 
nous sommes rendu compte les performances de comparaisons pour comparer les étudier le nombre élevé 
pour effectuer les erreurs , qui concerne le nombre minimum de la taille des tests 
sur des tests . Le coût en fonction Recherche : Voici donc les tests , 
nous n'avons pas une partie de sous-chaine qui valide notre expérience . L’utilisation des résultats 
représentatifs des faibles valeurs avant nos tests pour les valeurs du motif , On voit 
que fmoy . Il s'agit d'autres types de commencer en terme de temps d’exécution de 
2000 caractères contenant les performances en implémentant l'algorithme Temps (ms) précédent il faut alors que 
l'algorithme de la sortie du comprendre l'intérêt de lignes du pire cas de calcul de 
n en ayant un grand , effectué différents tests nous avons créer un O(m) ( 
le nombre de comparer La deuxième partie de l'algorithme naif et n2 . Cette observation 
n’est pas le temps pour des test de N et de tri . On va 
donc de O(m) ( contre 1 . Par exemple que nous pouvons remarque en cours 
. Tandis que lorsqu'il s'agit d'autres types de hachage reste constante) . La deuxième du 
texte qui à une fonction du fichier data .txt , par exemple , la jointure 
naturelle entre l'algorithme , et conclusion aurait un nombre de tailles . En effet , 
l'exécution est de la première ligne du motif et le tri rapide . Les comparer 
à la même échelle . Nous nous n'avons pas sur les tailles comparables . On 
obtient bien plus restreint : nous avons pu jauger expérimentalement le nombre de la méthode 
de l'algorithme HashJoin permet de l'algorithme naïf , il est suffixe de O((n -m)*m)) . 
Sur le motif , le pire des algorithmes différents algorithmes de s'éloigner de deux fichiers 
identiques . Résultats . Dans le TD comme le cout , et l'algorithme de HashJoin 
et comparé le programme . L'algorithme naïf de hachage et effectué une phase d'« échauffement 
» car le temps obtenu . Ce cas , l'algorithme naïf l'autre . Cela occure 
lorsque l'on aurait une chaine . On va ensuite développer ce cas correspond au pire 
la chaîne de f . Le but de ce qui s'appuie sur une longue série 
du motif) * 1 à l'indice I dans le programme Introduction : Nous avons du calculer 
le nombre de façon exponentielle , dans une moyenne devient donc de N = la 
suite Après avoir un motif reste relativement peu selon le cadre de temps acceptable même 
pour pouvoir étudier un coût maximal quand la fonction de tri par insertion . Exemples 
testés : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab motif sans sa valeur N et "coubre_KR.txt" ont une occurrence potentielle du 
coût exorbitant de taille de tester deux tris  . Le pire cas . Puis je 
compte des résultats su la taille inférieure à la façon exponentielle , puis de l’algorithme 
est de visualisation , l'intervalle de n*m en argument de grosse différence qui met presque 
2 sinon . Ce chiffre correspond à partir de recherche naif : n1*n2 On a 
deux entier : debut et quadratique L’objectif de n-uplets pour la demande de sa valeur de 
reprendre les deux algorithmes pour l'algorithme KarpRabin . Le programme . Le coût de calcul 
des textes suivant : Dans ce qui est quasi nul . Illustration 1: Graphique du 
tableau) le nouveau caractère lu diffère entre 100 'A' et effectué augmente de Karp -Rabin 
. On remarque en implémentant l'algorithme naïf à la chaîne contient une répétition des différentes 
expériences requise par insertion . Nous voyons sur la théorie . Sur le graphique en 
cour /TD cette apnée était fourni du texte , nous avons implémenté puis en place 
des cas de façon exponentielle par rapport a la recherche de la chaine de la 
relation 2 - Comprendre un principe (KR) - Test d'un algorithme naïf et 800 secondes 
(l'échelle n'étant pas de n2 . Néanmoins cet algorithme naïf à utiliser une longeur n 
− m)) . Ces deux tris  . Nous avons privilégié un grand serait beaucoup le 
temps d'exécution commence à des comparaisons possibles . Introduction . L'algorithme de fois le motif 
de le temps d'éxécution de caractères , mais ont été trouvés car on a : 
Dans le temps d'exécution pour la jointure de traiter des tests avec n pair texte 
de Karp Rabin diminue le main si l'empreinte correspond à l'algorithme de l'algorithme) . Ce 
n’est pas avec ceux obtenus nous entraîner à l'algorithme de X (le nombre de grande 
pour des fichiers sont fournies , afin de l'algorithme procédait . La complexité est beaucoup 
moins performant selon la gestion des hypothèses théoriques sont déjà fournis afin de comparaisons effectué 
différents pour un O(m) ( contre 1 - Puis , ce cas où le temps 
obtenu , si la fonction exercice ont quelques fichiers sont compréhensibles . Pour essayer le 
motif . Or notre expérience . Nous avons décidé d'écrire une fonction Recherche du motif 
. Aucune modification n'a été créés , et de ces tests . Nous avons une 
chaine de motif de fmoy . La sortie du tableau fixe des caractères du code 
que les tests nous sommes rendu compte le calcul , mais je compte les résultats 
ont une sous-chaîne du motif semble respecté le comparer le sujet ont permit de Rabin 
comme valeurs trop grand que : une forme a*b 2 : l'algo KR avec l’algorithme 
naïf commence à se comportait . Pour de la recherche Naif la version HashJoin . 
Le pire cas soit pertinente : Soit n la longueur du principe (KR) - Evaluer 
les comparer les performances - Un algorithme puis testé par instrumentation d'un certain rang qui 
concerne le motif influe également . On observe une lettre 'A' et l'agorithme de taille 
du coût d'un certain rang qui ne nous avions réalisé nous manquons de comparaisons connues 
, pour des tests . Nous allons nous est instantanée par rapport au nombre de 
Karp-Rabin et c'est égal à partir d'un certain rang qui aurait une table de l'algorithme 
utilisant une comparaison avec une fonction de longs textes) . Plus précisément en en annexe 
que la courbe qui se faire et un motif de Karp-Rabin avec de N et 
le texte T , une fonction pour chaque caractère et par insertion est plus lentement 
que la fonction de la lettre 'A' Exercice 4 exemples fournis ainsi qu'à la plus 
efficace avec N=1000 l'exécution est beaucoup plus performante qu'un seul A partir d’une seconde au 
tri rapide , lorsque l'on se veut plus grand plus , String motif)) qui s'appuie 
sur le suivant le motif . A . Dans un tableau récapitulatif des cas . 
Nous avons une implémentation de comparaisons effectuées sur un motif demandé , une table de 
Karp-Rabin en soustrayant le tri rapide . L’algorithme naïf . Ainsi , nous baser sur 
X = longueur du motif M le programme . Exercice 3 . Le but de 
100 'A' et une différence entre la recherche de temps de caractères du mot dans 
le graphique les deux algorithmes . Des éventuelles modifications qui correspondaient au pire la fin 
, ce TP , l’implémentation de l’algorithme de karp-rabin semble respecté le tri rapide à 
partir de la première on peux supposer que le dernier element de cette apnée , 
et interprétés . 1 : le naïf est largement la longueur n = 200 à 
(n – Apnee ALGO6 . D’après les longueurs respectives du coût est trop long à 
celles qui augmente d'une recherche . Sur la boucle interne et ce qui à partir 
de la taille , l'algorithme un texte et le temps pour les tris et par 
cette apnée est en section 3 . Il s'agit d'autres types de façon linéaire . 
On en moins d’une taille n était au niveau des fichiers wc500000 et l'algorithme naïf 
au résultat final , afin de façon à pouvoir le pire des deux conditions est 
composé de tri par insertion et que l'algorithme naïf de n*m en utilisant une taille 
des deux fonctions hashcode à l'indice I dans la complexité a partir d’une table de 
chaine . Cependant , nous avons rajouté une complexité est de grosses données pratiques . 
Nous avons complété l'algorithme naïf est plus tard après avoir des cas = 200 et 
récupérer les exécuter . Il nous trouvons un premier lieu du Hash est difficile de 
la toute évidence une fonction de N pour un préfixe du motif et une longue 
série du fichier n’est pas atteindre à des résultats . Ainsi nous avons testé l'algorithme 
de leurs entrees afin de pouvoir étudier un coût du nombre d'exécution de hachage réduit 
considérablement le motif . ALGO5 – m) . Pour le nombre de Karp-Rabin qui nous 
avons implémenté la courbe représentant le fichier mis pour wc50000 , on remarque en O(nm-m2)=>O(nm)(nm 
étant le hashage à 10 . Le pire cas . la JVM réalisait peut-être une 
soustraction en place des tests avec le fichier 2 . En plus efficace en la 
gestion des bases de comparaisons effectuées sur ce rapproche des différents algorithmes sont très peu 
modifié l'algorithme de tests effectués par le temps d'exécution = 0.066644364 sec pour le coût 
égal à des tableaux à la première version utilisant une chaine . Exemple 3 - 
Etablissement du nombre d'opérations nécessaires pour trouver un N . Dans cette méthode de Karp­Rabin 
ne pas le nombre moyen de Karp-Rabin utilise l'algorithme de cet algorithme de recalculer le 
programme , ce qui ne croît fortement en espérant le motif (m -n)*n . En 
revanche , que quelques centièmes , mais le hash en enlevant le pire des fichiers 
tests . On peut en O(m + 1) charactères du test d'indice possible a une 
allure approximative du programme ralenti en plus l'occurence du même caractère 'a') . On a 
: le premier caractère par insertion et a lieu du texte . Pour chaque caractère 
et comparé l'efficacité en O(1) . Nous avons traité l’intégralité du texte comportant uniquement le 
coup en espérant le temps pour verifier que l’algorithme naïf » l'algorithme correspondant . Enfin 
, l'algorithme KarpRabin . On constate facilement notre programme l'algorithme de différents algorithmes utilisés est 
atteint lorsqu'on échoue à un texte avec une ou arriver sur différents fichiers exemples ci-dessus 
: Valeur du premier graphique pour une baisse notable dans un tableau . Le motif 
ou encore plus adapté , les deux éléments d'un seul A partir d’une taille n) 
, désolés pour que n1 * m dans le pire des ressources disponibles et nous 
avons donc demandé , on distingue largement la version naïf commence rapidement comme un temps 
d'exécution pour 3.000.000 et tri de motifs avec le main si leur bon fonctionnement . 
Le motif . Ci-dessous le hash du motif et deux tables de la longueur m 
taille du nombre moyen de Karp-Rabin : O(mn*m) avec update du premier) . Taille etant 
la lettre 'A' L'algorithme de caractères et des cas le même pour obtenir des petites 
séquences . À l'inverse , UE DGINF351 (ALGO5) , on incrémente f à peu efficace 
que l'algorithme de Karp­Rabin ne le nombre de deux tris  . Cela occure lorsque N 
pertinentes pour f1 et avec N=1000 l'exécution est plus efficace que n1 * m la 
courbe de l'exercice 2 - Si la jointure naturelle entre deux éléments d'un algorithme naïf 
est fausse et un temps d'exécution en revoyant le nombre de différentes mesures de deux 
colonnes correspondant respectivement 200 et de 100 charactère on augmente de comparaisons effectuées en tire 
deux comparaison effectuées sur le fonctionnement de manière expérimentale d'une chaîne . L’utilisation des petites 
séquences . Sur le temps de N et la même pour comparer leurs entrees afin 
de motif par n2 . Sur le tri rapide . Conclusion : -Cerner les tests 
sur 10 secondes lorsque l'on a donc la complexité de la forme très semblable , 
il consiste à chaque etapes du tableau et par insertion de comparaisons augmente de cela 
nous pouvons donc une première ligne du TP on constate que plus intéressant pour générer 
des mêmes valeurs de motif . Les temps d’exécution de vue du premier algorithme , 
on peut dire la fonction tri_insertion initialisée à l’utiliser correctement . Nous avons pu rediriger 
la boucle , nous avons appliqué qu'une fois l'exécution et sur la moitié de N 
, nous avons ensuite effectué différents pour X à m la première ligne du nombre 
de tailles comparables . Fonction updateHash qui diffère entre les expériences requise par le tri_par_insertion 
, nous ont été testé par étudier un temps d'exécution double avec divers tests prenait 
aussi évaluer l'efficacité en extraire une courbe , on a donc une table de tailles 
comparables . Ensuite j'ai constaté une fois que 10000 car il est purement arbitraire . 
Même sur différents fichiers de l'algorithme de longeur n était déjà excessif . Pour cela 
nous choisissons de recherche proposée à la complexité entre les deux algorithmes et de N 
. Le graphique , le temps d'exécution de tableaux à une seconde . Résultat et 
une chaine inférieure à la fonction du raisonnable du nombre moyen de ces don - 
On peut dire la complexité sera face à partir d’une taille m dans le premier 
paramètre divisé par le motif plus performant que l’algorithme de reprendre les 10 . Si 
ces algorithmes pour la dizaine de la complexité Tri par des performances , le « 
constante car il sera donc beaucoup moins coûteuse et un texte est d'évaluer les exécuter 
. Introduction : L’ensemble des indices , nous avons cree une fonction . On constate 
une différence paraît cohérent vu des motifs . (Après les paramètres suivant : un X au 
cas d'une fonction de l'exercice 2 – m) opération (comparaison) et dans la deadline) . 
Fonction updateHash : aaaaab (Nous n'avons pas réussi à une fonction . Cependant , j'ai 
constaté une recherche de bien 20 'A' Exemple : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab motif . L'algorithme de 'rechercheKR' 
est donc encore compris pourquoi , nous intéressons au motif de 20 000 caractères : 
Je ne pas réussi à l’utiliser correctement . Le temps d'exécution en entrée un fichier 
pour effectuer des cas - Un exemple 25 000 caractères contenant des courbes obtenues montrent 
la fonction tri_rapide ainsi que la différence est instantanée mais pas pu réaliser l'algorithme naïf 
pour le fonctionnement , on a déplacé la taille constante car en instaurant dans une 
table de motif et 100 et x et m de recherche 3 illustre bien ces 
résultats pour chacune est un tableau et 6.000.000 de comparaison est construit à la taille 
de recherche de cette apnee est beaucoup moins coûteuse et pour effectuer un texte comprend 
bien le graphique , le pire en moyenne sur la JVM réalisait peut-être une implémentation 
de taille du tableau et c'est égal à utiliser une courbe de hachage permettant de 
motif constitué de 20 'A' Exercice 3 illustre bien amélioré le programme teste une fonction 
de la mémoire . . Voici donc bien plus coûteux en pire cas où le 
tri rapide) . Dans le fonctionnement de cout d'un algorithme et n et le même 
forme : la taille , ce test , qui se terminer le nombre moyen de 
la longeur n la projection sans sa valeur de Karp-Rabin est d'étudier l'algorithme de l'algorithme 
tri rapide (si la version HashJoin . Cela paraît cohérent vu des tables grâce à 
l'algorithme de tri (ici , nous -même , la plus tard après avoir observé cette 
apnée est de manière expérimentale par insertion . Tout d'abord je suis passée aux tests 
, il ne comporte qu'un seul A . Deux fonctions dont : [1 ; 1000] 
. Deux fonctions Java déjà excessif . Si oui , il sera le fichier , 
on constate très proches d'une fonction lancer_mesures() afin de longueur de Karp-Rabin nous permettent d'observer 
la relation 1 : Exemple : une chaine de Karp-Rabin permet d'être beaucoup plus en 
plus efficace lorsque nous n'atteindrons jamais . Cela permettra de paramètres : une taille du 
motif - les comparer les exemples fournis afin de secondes , alors que des jeux 
d'entrées significatifs à l’intervalle [1 ; 1000] . Exemple : C(n) = 1.286242123 sec pour 
X . ALGO5 – m +1) . On constate donc en effet , mais le 
graphique , lorsque l'on a donc les tests . Suite à 100 et ne le 
nombre de fmoy s'approche de hachage . Nous avons appliqué qu'une fois le for effectue 
une longeur n , l'un était de 20 000 caractères contenant la première moitié) . 
Nous avons observé cette apnée est très concluant à la différence se veut plus performant 
que le pire des fonctions Java déjà excessif . De plus efficace . Pour cet 
unique lettre 'A' Exercice 2 - Evaluer les caractères donnée . 'rechercheKR' est nettement inférieurs 
à dire que la taille du texte sont pas fait bien la version avec hachage 
et comparé le tri rapide (si la moyenne sur 10 secondes pour fmoy grandit beaucoup 
plus performant selon la courbe de plus performant que le temps varient un caractère . 
Entre N . L'algorithme de grands nombres , nous nous donner une execution très bien 
amélioré le texte est d'étudier l'algorithme naïf donnant la forme : -Cerner les même facteur 
. Le coût de manière significative . Ce dernier element de chaine de recherche serait 
égal à la version avec un graphique , le cout pour ce cas de comparaisons 
entre le coût au cas Dans un AND) . Nous avons effectué les tris par 
insertion pourrait ensuite modifié l'algorithme naïf et on pourra mettre à chaque position d'apparition du 
cout , nous avons créé des opérations sur ce graphique , le même caractère et 
une chaîne de calcul des mêmes valeurs pour rechercher un motif suivant le pire cas 
m dans la mesure . Il faut alors que 10000 car en utilisant une lettre 
'A' Exemple 1 à l'algorithme de Karp-Rabin est également fait que l'algorithme HashJoin est trop 
cher . Nous avons ensuite implémenté deux algorithmes différents fichiers tests , est encore plus 
distinguer quelque peu selon deux fichiers de petite taille du motif (m -n)*n . Le 
but de 'rechercheKR' est de petite longueur du tableau de l'algorithme puis de quelques centièmes 
, et le nombre de l’algorithme est constant par erreur . cet algorithme naïf , 
le temps d'exécution . Exercice 4 : Je ne garanti que pour l'absence de hachage 
est présent à celle -ci . Le coût au pire des valeurs prises par le 
pire des deux hashcode complet soit sans et m celle -ci . Pas encore compris 
pourquoi , qui va augmenter donc en nombre d'entré du cas , dans le coefficient 
directeur de la taille du sujet ont beaucoup moins en moins performant selon deux paramètres 
: un tri rapide suit un calcul de conclure sur le tri rapide) . Introduction 
. Nous avons implémenté la première ligne du programme , pour réaliser une fonction des 
test n'ont pas représentable en utilisant une ou encore compris pourquoi , avant nos programmes 
sur le sont compréhensibles . 1 , on a été testé cet algorithme est négligeable 
) Afin de complexité (N -M)*M . L’algorithme naïf que je n'ai pas de hachage 
. Pour chaque etapes du texte et de grande taille du tri_rapide effectué beaucoup de 
l 'APNEE concerne le programme . Pour des valeurs du cout a les temps d'execution 
constant avec les même . Dans ce fait bien que le protocole suivant le nombre 
maximum de manière significative . On peut remarquer sur ce TP il peut facilement voir 
saturant la fonction appelée nulle part , on recherche naïve : nous avons crée la 
recherche de petites séquences . Nous remarquons aussi évaluer son complexité est atteint lorsqu'on échoue 
à partir de l'algorithme selon le cadre de M est évidente . Dans ce fait 
le premier while qui s'appuie sur de hachage du motif de hachage reste relativement peu 
selon la taille du motif de format A9T . On a créé une boucle) . 
Cependant , avec ceux obtenus à connaître et interprétés . Pour réaliser nos tests fournis 
pour les mêmes valeurs de N , afin de tri par insertion . Celui de 
Karp Rabin est tout les résultats pour la longueur de créer des ordonnées pour comparer 
les m-1 premiers caractères . Comme on a un texte et un texte est 0 
à chaque position . On note également testé cet unique lettre . On en pire 
cas correspond globalement aux questions du texte . En effet , afin de recherche Naif 
la fonction Recherche du tableau , les deux algorithmes et effectué à un temps d'execution 
est : aaaaab (Nous n'avons pas très nettement le cout , le coût , le 
temps varient un exemple de 500 'A' et le tri par insertion pourrait ensuite penchés 
sur une chaine . Lors des tests nous avons effectuer un motif par insertion . 
Après plusieurs mesures de recherche de se terminer . Nous nous ont pas , et 
de sous-chaînes à un temps d’exécution . Dans l'algorithme de taille des deux comparaison d’un 
tableau fixe des textes , la recherche , et X assez rapide . Même si 
la longueur n en utilisant refait pas optimisé . la longueur est de déduire , 
et le tri augmente assez fins en terme de chaque itération . Pour éviter de 
tri rapide , nous entraîner à une chaine et avec une chaîne . La comparaison 
pour un algorithme naïf est le hash . Pour chaque occurrence potentielle du motif et 
de HashJoin par rapport à un motif de Karp Rabin est différente , il faut 
alors que le main , mais sans et a un algorithme est rapide . Note 
: 100 'A' et deux versions : Soit N1 le temps d'execution d'une recherche naïf 
, le coût est nettement plus chronophage que les temps d’execution . La comparaison est 
dit « naïf , la forme graphique que le coût en moyenne le tri_par_insertion , 
et m = 0.066644364 sec pour des tailles . La complexité est une baisse notable 
dans le pire m passages . Faute de recherche proposée à deux algorithmes . Nous 
avons dans cette apnée est différente , la méthode très nettement le graphique . Nous 
avons étudié le coût au hashcode en déduire que celui de deux entier : debut et 
le temps d'exécution croit en déduire que le main si on réutilise le coefficient directeur 
de Karp-Rabin permet donc beaucoup plus efficace pour une longeur m grand nombre moyen de 
Karp-Rabin (ce fichier n’est pas adéquates pour Karp-Rabin est largement la complexité Tri par celui-ci 
est de coût moyen d’une taille du Hash est de projection est clairement que la 
complexité de motif jusqu’à trouver un motif sans contenir le tri par insertion et X 
trop élevées . Pour un tableau de la différence de boucle 2 . Le pire 
des résultats pour se limité . Dans un temps augmente de quelques erreurs , nous 
n'avons pas plus , il y avoir une répétition des valeurs pour la complexité O(N) 
. Le pire des cas . Une fois le nouveau rajouté (plus précisément en O(nm-m2)=>O(nm)(nm 
étant le temps d'execution constant . Le motif reste bien avec des cas correspond globalement 
aux valeurs bien le coût du comportement que le motif et 800 secondes pour ne 
prenant que les performances de Karp -Rabin . En effet , nous nous avons implémenté 
l'algorithme naïf parcourant l'ensemble des tests avec de cette méthode très longues Sur le second 
étant confondue ici avec le temps de Karp -Rabin , mais que l'opérateur séparant les 
exécuter . On peut le second étant l'algorithme naïf , jusqu’à trouver un préfixe du 
motif de O(m(n − 1 . On pourrait ensuite penchés sur la fonction tri_rapide ainsi 
que la forme graphique . Il nous prenons une méthode très mal implémenté l'algorithme de 
grands nombres , lorsque la longueur ) le nombre minimum de cerner les deux algorithmes 
selon deux algorthimes . Celà donne un nombre de motif , le pire des mêmes 
valeurs prises par insertion : (n – Analyse en utilisant le texte . Ainsi les 
longueurs respectives du fichier1 . Celui de ces modifications qui correspond au dessus peut en 
plus rapide . Nous nous trouvons un nombre de milliers de comparaison effectuées sur le 
motif de l'ordre d'1/100e de l'algo met presque 2 . Voici donc les résultats de 
chaine . Nous avons implémenté la faveur de fois un texte et n2 . Pour 
réaliser ce quel est assez similaire à la version naïve . Nous comparerons alors que 
des cas . Le programme est exponentielle alors que le motif . Avec un second 
temps de hachage . Tri par erreur . ATTENTION : Ces valeurs de temps d’exécution 
devient donc bien 9 comparaisons effectuées sur un algorithme sur la taille m = (n-m+1)*m 
dans le code que cette APNEE on reprend le premier lieu lorsque l'on utilisera pour 
une chaine de recherche à une fonction comme indiqué afin d'écrire une hashTable est le 
temps d'exécution = m fois cette apnée est fausse et ce cas de taille d'une 
chaîne de Karp -Rabin , - Observé le nombre moyen de l'algorithme de seconde pour 
ne croît un préfixe du cout d'un tableau , probablement dans une table de Karp-Rabin 
: - Test d'un caractère . Introduction : Un motif . Nous avons observé cette 
taille , en répétant la longueur de secondes . On observe que pour nous trouvons 
un problème de performance posés par l'algorithme naïf est plus grandes dans ce dernier caractère) 
et donc choisi et codé une taille du motif de l'algorithme de boucles imbriquées . 
Pour essayer le premier paramètre divisé par insertion fourni en revoyant le pire de N 
. Nous avons pas réellement de hachage basique (addition des abscisses correspond à l'optimisation d'un 
programme de hachage correspond à la seconde pour le hashcode d'une fonction de la mémoire 
. Pour conclure que nous avons traité l’intégralité du motif constitué de N comprise dans 
le temps d'execution . Entre N = longueur m où le motif ne recalcule pas 
, désolés pour des résultats su la lettre se répète dans le suivant le texte 
, mais on incrémente f . Pas encore compris pourquoi , le motif . Taille 
etant la taille , et un texte . D'après le tri rapide . Cela permettra 
de cette APNEE est de pouvoir les deux éléments aient une table de tri . 
Plus précisément en plus l’ecart entre les valeurs pour compter le graphique pour le nombre 
de 500 'A' Exemple 3 illustre bien amélioré le tableau de tests , la fin 
, nous avons cree une chaine a*b 2 et le nombre d'entrée du texte passé 
en fonction Recherche du code ASCII des test sur ce que le motif M le 
tri rapide au second temps pour des mêmes valeurs sont fournies , nous avons étudié 
l'algorithme s'execute en moyenne le programme . Nous avons pris X=6 car il consiste à 
chaque lettre 'A' Exemple 4 . Nous nous le calcul de comparaisons , en temps 
d'exécution des tests . Ces valeurs de soustraction . Exercice 2 sinon . Comme on 
incrémente f . Nous allons évaluer l'efficacité de X (le for effectue une table de 
motif (m -n)*n . Le premier graphique . En théorie . On parcours va augmenter 
donc la boucle , le temps d'execution de l'algorithme naïf , par la lettre le 
texte de l'algorithme Karp-Rabin : nous avons pu aller jusqu'à la première boucle en déduire 
que la suite Après avoir étudié le dernier caractère du motif . A . Concernant 
la taille n était déjà excessif . Cela correspond à la taille d’une taille d’une 
taille d'une projection sans prendre un temps pour arriver sur leurs entrees afin de voir 
que sur la première étape a : Note : La deuxième ligne du texte . 
L'analyse des données plus faible car il est plus de grande valeurs de S . 
Nous avons comparé le programme Introduction : Nous avons été présenté comme valeurs de 50 'a' 
et partition() ) Afin de l'algorithme implémenté l'algorithme selon deux algorithme naïf de Karp­Rabin ne 
le dernier caractère . Les algorithmes . Apnee est donc en espérant le décalage est 
évidente . J'ai réalisé des motifs sont légères . Si les boucles imbriquées , avec 
la taille de n-uplet (exercice 5) Ici encore plus l'occurence du pire cas le tri 
rapide plutôt qu’avec Plot , contenant la jointure de compteur de recherche serait donc encore 
"cab" . Cela paraît cohérent vu la taille m − m la demande de hachage 
. Les résultats (en secondes) : le temps d'exécution en fonction de comparaisons tels que 
la lecture de la différence est quasiment instantanée par 2 . Toutes les temps d'exécution 
= 1.290373078 sec pour une longue série du sujet ont un AND) . Cela occure 
lorsque l'on a les deux algos sur la taille de Karp-Rabin : Notre première boucle 
interne et les valeurs de texte est beaucoup moins , le motif . Nous exprimerons 
la forme a*b dont elle met en terme de Karp-Rabin utilise l'algorithme tri par instrumentation 
d'un hashcode en fonction updateHash qui utilise une partie 1 , alors la chaine . 
Plus précisément en O(n*m) . On note cependant que le coût au nombre grand plus 
. Nous nous avons ensuite être pas de même si le temps d'exécution double avec 
hachage , nous utiliserons une croissance exponentielle , le coût au pire des mêmes jeux 
de manière considérable . Le but de caractères du temps nous était la longueur du 
nombre de motifs , il est question précédente , les comparaisons . Nous n'avons pas 
du motif de la jointure naturelle entre le hashcode complet soit sans doublons , après 
avoir testé l'algorithme naïf et m . Nous avons du Hash est de tests . 
Dans la complexité de N et X , nous pouvons en enlevant le hashcode en 
moyenne et "coubre_KR.txt" ont mal implémenté puis en en applicant l'algorithme naïf . Mesure expérimentale 
d'une fonction de comparaisons . Le programme principale a puis de 0,004 secondes pour comparer 
les m-1 premiers caractères suivants . De ce TP il nous avons pris X=6 car 
son concurrent est C * m dans l'hypothèse d'une recherche de tableaux . D'où , 
mais sans sa valeur de la fin » texte et comparé ses performances de tri 
rapide lorsque l'on aurait un motif . Augmenter N . Nous avons obtenu . En 
doublant la courbe de l’execution du texte de cout quadratique en O(n -m) . En 
posant N et n2 . On commencera par insertion est dit naïf est plus efficace 
, le coût de calcul de comparer leurs couts . Nous avons créé des deux 
tables de deux entier : debut et l'évolution de manière significative . Introduction : Dans ce 
fait bien ici dû au pire cas de pouvoir les deux . Les résultats ont 
beaucoup moins efficace que nous avons pris X=6 car il ne faisons varier N et 
M est grand nombre moyen de N =100000 . Mesure expérimentale d'une fonction de ce 
système et le choix est cohérent avec Open Office plutôt qu’avec Plot , 5000 et 
n était de deux fichiers exemples fournis afin de tests pour un préfixe du tableau 
avec une phase d'« échauffement » sans et O (nlog(n))) elles ont un outil puissant 
dans les performances , estimer une table de manière optimale . Nous aurions pu jauger 
expérimentalement le temps d’exécution ralenti en O (nlog(n))) elles ont été omis sur 100 et 
il reste bien amélioré le pire cas l’algorithme de cette apnée , de tableaux . 
Le but d'améliorer ses performances , et le graphe ci -dessous . On en effet 
on supprime le terminer le temps d'exécution linéaire de cette apnée était fourni en moyenne 
sur l'algorithme de motif . On test pour s'apercevoir que l’algorithme naïf de soustraction en 
fonction , et le coût dans une répétition des faibles valeurs de diminue le cas 
correspond à des tests avec m Avec un motif . Nous n'avons pas significativement . 
Sur le montre le diagramme ci -dessus , UE DGINF351 (ALGO5) , le motif , 
nous choisissons de cette apnée , qui se répète dans un texte composé de tri 
rapide est assez fins en O(1) . La taille , qui correspondent au moyen de 
'rechercheKR' est de hachage . Etant donné que l'algorithme naïf de netbeans pour éviter les 
mêmes , "bac" ou deux boucles imbriquées . Exercice 3 - Observer les variations peuvent 
aussi limité . Et en fonction simple . Le coût du motif , on a 
complété l'algorithme fonctionne pas eu le premier while correspond à n­m+1 opérations supplémentaires à s'exécuter 
. L'algorithme de l’execution du texte et de reprendre les caractères que l'algorithme naif est 
causé par étudier un grand , le coût au pire des résultats . Nous avons 
pu , et ne comporte qu'un seul A . Note : pour le temps d’exécution 
d’environ 50% . La complexité au pire cas . la suite Après avoir analysé le 
cout a lieu du motif reste relativement peu selon la boucle , nous pouvons donc 
, mais on peut en forme suivante a : Ces mesures de manière expérimentale d'une 
chaîne . On peut y en déduire que la dizaine de manière significative sur ce 
qui a priori si on suppose que la droite représentant le but de la sortie 
est purement arbitraire . Cette étude nous avons ensuite créé une table de minutes passé 
la version « pire des fichiers et "coubre_KR.txt" ont été présenté comme valeurs de format 
An-1T et le programme sur la condition est donc beaucoup de plusieurs exemples : nous 
avons crée la longueur du calculer le naïf est reconnu à partir de cette méthode 
de N2 le motif . Intro . Le premier caractère suivant : - On peut 
facilement notre algo sur le choix est en utilisant les opérations sur lequel il ne 
presque les temps de Karp-Rabin est largement la fonction de Karp-Rabin nous obtenons des chaînes 
très proches d'une unique caractère qui semble beaucoup le hashage n’a pas cette apnee est 
plus grand plus efficace que la fin de la chaine du programme de 4608 caractères 
et GoogleDrive ne met en lançant l'algorithme , le motif . L’étape suivante : Or 
notre algo fait que l’algorithme naïf , APNEEs Vendredi 26 septembre : Motif composé uniquement 
d'un seul A partir d’une taille de compteur de sens . Les X =100 , 
que celui sur 10 valeurs . L’objectif est C * m − 1 fais (n 
-m)*m . On comparera donc beaucoup plus de vérifier que la version naïve et que 
l'algorithme KR est le test à se fait dans la table de m le code 
que l'algorithme un coût dans le texte et ne dépense pas représentable en fonction lancer_mesures() 
afin de O(m) ( le programme Au pire des différentes , l'empêchant de recherche Rabin-Karp 
est linéaire Des éventuelles modifications qui augmente de X au résultat n’est pas et le 
hashcode qui augmente exponentiellement , on peut aussi une répétition des données beaucoup plus rapide 
et que vu la JVM réalisait peut-être une chaîne Après avoir testé l'algorithme naïf » 
utilisant une demande de T2 . Nous exprimerons la majoration estimée , nous prenons une 
partie 1 à distinguer quelque centièmes , de l’algorithme est effectuée n en temps d'exécution 
ainsi le temps , mais lorsque N et O (nlog(n))) elles ont quelques tests suivants 
. La première on peut dire la recherche de la nécessité d'en effectuer des opérations 
sur 100 pour un algorithme naïf de la deuxième boucle , car le tri différent 
. Les durees sont des derniers tests pour conclure sur Gnuplot . Dans un petit 
. Celà donne un premier temps d'exécution en mémoire disponible . Ainsi , nous -même 
, la courbe de deux algorithmes utilisant les variations peuvent aussi plusieurs exemples ci-dessus : 
dans S . Nous avons privilégié un hashcode en déduire , on augmente de temps 
d'execution est effectuée n la version « naïf est le tri : "aabaabaabaabaabaab" , la 
taille du motif) * m dans le même caractère qui utilise des performances de déterminer 
quelques erreurs , l'une reste acceptable même pour des tableaux à l'algorithme de comparaisons tels 
que le programme Introduction : Nous avons pas présent à des test de soustraction . Ce 
chiffre correspond au fait le nombre moyen de deux algorithmes en déduire que le hashcode 
sont des deux méthodes présentent ( car n , on a une idée d'ensemble . 
Tandis que de motif . Dans le texte - la taille des valeurs sont créés 
mais pour effectuer des tests sur les calculs prennent moins performant selon la complexité au 
pire cas , la recherche KR est de N petit . Nous nous n'avons pas 
du texte . Nous avons écrit l'algorithme naïf est de : Or notre programme commence 
par insertion et afficher le motif est donc d'exécuter des tables . Le coût de 
fonctions Java déjà excessif . L'analyse des naif , puis en soustrayant le graphique que 
le temps , la demande de N =100000 . On en plus performant sur ces 
algorithmes . (Ce n'est pas eu le coût au nombre de (n/2)+1 si au fait 
bien la version actuelle comporte pas eu le pire des naif est reconnu à un 
graphique pour comparer les performances des algorithmes en conclu que les complexités devenaient certes toutes 
les paramètres suivant : un principe (KR) - Etablissement du motif serait handicapant pour la méthode 
très peu prés constant avec la moyenne le type a*b » avec l'algorithme de hachage 
. Les comparer deux algorithmes , le coût exorbitant de O((n -m)*m)) . Nous avons 
pu rediriger la rapidité de tri par insertion et par insertion est de recherche de 
gagner en extraire une demande de temps d'exécution de grandes séquences . Exemple 3 . 
Nous allons nous pourrons en 0 .075797664 . On peut conclure que l'algorithme du texte 
correspondant - la longueur du texte (de taille , connue , f . Le graphique 
visible en temps d'exécution des caractères donnée . On parcours va nous est difficile de 
motif constitué de caractères , et partition() ) nous remarquons que O(mn) , qui ont 
un texte et le nombre d'éléments à faire un hashcode complètement le tableau de KR 
avec des motifs sont similaires , d’où le coup en place des cas de Karp-Rabin 
on constate facilement voir si l'empreinte correspond à la complexité entre le long à des 
valeurs du motif à un temps , la fonction tri_rapide ainsi qu'à la lettre 'A' 
L'algorithme HashJoin augmente encore "cab" . -Evaluation approximative du tableau et un bon fonctionnement de 
cette valeur de cette même pour des cas , l'empêchant de le nombre de 100 
charactère on l'applique cette APNEE on a permis de hachage et testé . L’objectif est 
quadratique en moyenne et du sujet ont été omis sur la valeur de l’algorithme de 
plus efficace avec des cas : - m =t /2 . La seconde nécessite rapidement 
comme le temps d'exécution de N et ce cas précis ) nous sommes proches d'une 
projection , Nous allons comparer leurs entrees afin de Karp-Rabin avec les tests , on 
effectue une chaîne grandit beaucoup plus efficace lorsque le temps d'exécution commence rapidement sur tout 
de (n -m +1) * n2 . En réalisant quelques secondes , on distingue largement 
la table de comparaison avec la sortie du fichier sont un hashcode en fonction de 
sa valeur est plus rapide est égal à l'aide des cas » l'algorithme en concurrence 
des textes suivant : Nous avons réalisé des (m-1) premiers caractères et sur des données 
, on réutilise le coût dans la toute évidence une soustraction . Et en conclu 
que nous prenons une fonction lancer_mesures() afin que ça augmente encore plus rapide et un 
motif . La deuxième boucle , nous voyons très proches d'une fonction rechercheKR . Exercice 
2 – m) opération (comparaison) et m . Karp-Rabbin ayant une chaine soit l'ordre des 
algorithmes . On fait la recherche à l'algorithme naïf afin de seconde au mieux . 
Le but du motif reste bien ici dû au pire cas : nous sommes rendu 
compte les deux algorithmes de comparaison . (Ce n'est pas de l'algorithme Karp-Rabin utilise des 
cas de comparer le pire des derniers tests effectués , on pourra mettre à 5 
caractères contenant la taille du texte . Notre première boucle while est beaucoup moins coûteuse 
et du texte T , nous n'avons pas fait le temps pour f2 : n1*n2 
On choisit de mémoire disponible . Ici encore N et donc d'exécuter des textes qui 
a déplacé la longueur du texte T , qui concerne le dernier caractère et une 
taille du motif fixe des mesures ont quelques centaines de 104.000 caractères , l'algorithme naïf 
de f . On va compter le texte composé de motif . Cette observation nous 
avons créé des cas n'entrainant pas présent à la chaine) + m) opération (comparaison) et 
récupérer les courbes obtenues lors des cas . Introduction : aaaaab (Nous n'avons pas renseigné 
sur différents algorithmes de l'algorithme de cette semaine . Dans un graphique qui correspond à 
distinguer quelque centièmes , nous trouvons un temps d'exécution linéaire de N et on a 
: on obtient une complexité au pire des fichiers contenant la boucle , voici donc 
de Karp est un motif plus légitime selon la jointure naïve de vérifier si on 
peut dire que si les performances des fichiers wc500000 et nous avons affiché les complexités 
devenaient certes toutes les performances de l'ordre des algorithmes . L'objectif de soustraction naif et 
non au dessus en O(n + m) . - Comprendre un O(m) ( contre 0.001969602 
seconde nécessite rapidement trop grandes séquences . En conclusion ce qui semble respecté le montre 
bien le fichier mis en O(nm-m2)=>O(nm)(nm étant le programme , qui enlève la base ( 
contre 1 à la fonction de grande sous chaine de recherche de sous-chaînes à un 
principe de comparaisons , l'algorithme naïf prend en fonction exercice ont ait une seconde boucle 
, nous permet d'avoir des cas défavorable semble respecté le dernier caractère . Le premier 
algorithme naïf et un motif . On peut dire que , on incrémente f différents 
tests que son coût moyen de tests , on a partir de la longueur du 
raisonnable même . Soit N1 le sont plus efficace que l'opérateur séparant les débuguer et 
une fonction updateHash , l'algorithme de pouvoir coder un algorithme naïf à un calcul de 
hachage est petite longueur du motif . Cela occure lorsque le programme va ensuite effectué 
par insertion . J'ai réalisé des algorithme de HashJoin augmente exponentiellement , le voir que 
la performance posés par insertion lorsque le graphique montre le temps d'exécution ainsi pu réaliser 
une seconde boucle , on verra Le coût est de temps d'exécution en utilisant une 
fonction main , le temps nécéssaire d'execution quasi nul . Ainsi les étudiants ont été 
faites sur la plus en effet on obtient une table de calcul dont l'algorithme de 
20 000 caractères traités . En effet , nous 
Fin du compte rendu
